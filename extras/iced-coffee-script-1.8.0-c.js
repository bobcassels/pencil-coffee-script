/**
 * Pencil Code IcedCoffeeScript Compiler v1.8.0-c
 * https://github.com/PencilCode/pencil-coffee-script
 *
 * Copyright 2011, Jeremy Ashkenas, Maxwell Krohn
 * Released under the MIT License
 */
(function(root){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.CoffeeScript=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var CoffeeScript, compile, compileCount, runScripts,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CoffeeScript = _dereq_('./coffee-script');

  CoffeeScript.require = _dereq_;

  CoffeeScript.code = {};

  compile = CoffeeScript.compile;

  compileCount = 0;

  CoffeeScript["eval"] = function(code, options) {
    if (options == null) {
      options = {};
    }
    if (options.bare == null) {
      options.bare = true;
    }
    return eval(compile(code, options));
  };

  CoffeeScript.run = function(code, options) {
    if (options == null) {
      options = {};
    }
    options.bare = true;
    options.shiftLine = true;
    return Function(compile(code, options))();
  };

  if (typeof window === "undefined" || window === null) {
    return;
  }

  if ((typeof btoa !== "undefined" && btoa !== null) && (typeof JSON !== "undefined" && JSON !== null) && (typeof unescape !== "undefined" && unescape !== null) && (typeof encodeURIComponent !== "undefined" && encodeURIComponent !== null)) {
    compile = function(code, options) {
      var error, js, name, v3SourceMap, _ref;
      if (options == null) {
        options = {};
      }
      name = "coffeescript-" + (compileCount++) + ".js";
      options.sourceMap = true;
      options.inline = true;
      try {
        _ref = CoffeeScript.compile(code, options), js = _ref.js, v3SourceMap = _ref.v3SourceMap;
      } catch (_error) {
        error = _error;
        if (error instanceof SyntaxError) {
          CoffeeScript.code[name] = {
            syntaxError: error
          };
        }
        throw error;
      }
      CoffeeScript.code[name] = {
        coffee: code,
        map: v3SourceMap,
        js: js
      };
      return "" + js + "\n//# sourceMappingURL=data:application/json;base64," + (btoa(unescape(encodeURIComponent(v3SourceMap)))) + "\n//# sourceURL=" + name;
    };
  }

  CoffeeScript.load = function(url, callback, options, hold) {
    var xhr;
    if (options == null) {
      options = {};
    }
    if (hold == null) {
      hold = false;
    }
    options.sourceFiles = [url];
    xhr = window.ActiveXObject ? new window.ActiveXObject('Microsoft.XMLHTTP') : new window.XMLHttpRequest();
    xhr.open('GET', url, true);
    if ('overrideMimeType' in xhr) {
      xhr.overrideMimeType('text/plain');
    }
    xhr.onreadystatechange = function() {
      var param, _ref;
      if (xhr.readyState === 4) {
        if ((_ref = xhr.status) === 0 || _ref === 200) {
          param = [xhr.responseText, options];
          if (!hold) {
            CoffeeScript.run.apply(CoffeeScript, param);
          }
        } else {
          throw new Error("Could not load " + url);
        }
        if (callback) {
          return callback(param);
        }
      }
    };
    return xhr.send(null);
  };

  runScripts = function() {
    var coffees, coffeetypes, execute, i, index, s, script, scripts, _fn, _i, _len;
    scripts = window.document.getElementsByTagName('script');
    coffeetypes = ['text/coffeescript', 'text/literate-coffeescript', 'text/numeric-coffeescript'];
    coffees = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = scripts.length; _i < _len; _i++) {
        s = scripts[_i];
        if (_ref = s.type.toLowerCase(), __indexOf.call(coffeetypes, _ref) >= 0) {
          _results.push(s);
        }
      }
      return _results;
    })();
    index = 0;
    execute = function() {
      var param;
      param = coffees[index];
      if (param instanceof Array) {
        CoffeeScript.run.apply(CoffeeScript, param);
        index++;
        return execute();
      }
    };
    _fn = function(script, i) {
      var insensitiveType, options;
      insensitiveType = script.type.toLowerCase();
      options = {
        literate: insensitiveType === coffeetypes[1],
        numeric: insensitiveType === coffeetypes[2]
      };
      if (script.src) {
        return CoffeeScript.load(script.src, function(param) {
          coffees[i] = param;
          return execute();
        }, options, true);
      } else {
        options.sourceFiles = ['embedded'];
        return coffees[i] = [script.innerHTML, options];
      }
    };
    for (i = _i = 0, _len = coffees.length; _i < _len; i = ++_i) {
      script = coffees[i];
      _fn(script, i);
    }
    return execute();
  };

  if (window.addEventListener) {
    window.addEventListener('DOMContentLoaded', runScripts, false);
  } else {
    window.attachEvent('onload', runScripts);
  }

  window.iced = CoffeeScript.iced;

  module.exports = CoffeeScript;

}).call(this);

},{"./coffee-script":2}],2:[function(_dereq_,module,exports){
(function (process,global){
// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var Lexer, SourceMap, compile, ext, formatSourcePosition, fs, getSourceMap, helpers, iced_runtime, iced_transform, lexer, parser, path, sourceMaps, vm, withPrettyErrors, _base, _i, _len, _ref,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  fs = _dereq_('fs');

  vm = _dereq_('vm');

  path = _dereq_('path');

  Lexer = _dereq_('./lexer').Lexer;

  parser = _dereq_('./parser').parser;

  helpers = _dereq_('./helpers');

  SourceMap = _dereq_('./sourcemap').SourceMap;

  iced_transform = _dereq_('./iced').transform;

  iced_runtime = _dereq_('iced-runtime');

  exports.VERSION = '1.8.0-c';

  exports.FILE_EXTENSIONS = ['.coffee', '.litcoffee', '.coffee.md', '.iced', '.liticed', '.iced.md'];

  exports.helpers = helpers;

  withPrettyErrors = function(fn) {
    return function(code, options) {
      var err;
      if (options == null) {
        options = {};
      }
      try {
        return fn.call(this, code, options);
      } catch (_error) {
        err = _error;
        throw helpers.updateSyntaxError(err, code, options.filename);
      }
    };
  };

  exports.compile = compile = withPrettyErrors(function(code, options) {
    var answer, currentColumn, currentLine, extend, fragment, fragments, header, js, map, merge, newLines, _i, _len;
    merge = helpers.merge, extend = helpers.extend;
    options = extend({}, options);
    if (options.sourceMap) {
      map = new SourceMap;
    }
    fragments = (iced_transform(parser.parse(lexer.tokenize(code, options)), options)).compileToFragments(options);
    currentLine = 0;
    if (options.header) {
      currentLine += 1;
    }
    if (options.shiftLine) {
      currentLine += 1;
    }
    currentColumn = 0;
    js = "";
    for (_i = 0, _len = fragments.length; _i < _len; _i++) {
      fragment = fragments[_i];
      if (options.sourceMap) {
        if (fragment.locationData && !/^[;\s]*$/.test(fragment.code)) {
          map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], {
            noReplace: true
          });
        }
        newLines = helpers.count(fragment.code, "\n");
        currentLine += newLines;
        if (newLines) {
          currentColumn = fragment.code.length - (fragment.code.lastIndexOf("\n") + 1);
        } else {
          currentColumn += fragment.code.length;
        }
      }
      js += fragment.code;
    }
    if (options.header) {
      header = "Generated by IcedCoffeeScript " + this.VERSION;
      js = "// " + header + "\n" + js;
    }
    if (options.sourceMap) {
      answer = {
        js: js
      };
      answer.sourceMap = map;
      answer.v3SourceMap = map.generate(options, code);
      return answer;
    } else {
      return js;
    }
  });

  exports.tokens = withPrettyErrors(function(code, options) {
    return lexer.tokenize(code, options);
  });

  exports.nodes = withPrettyErrors(function(source, options) {
    if (typeof source === 'string') {
      return iced_transform(parser.parse(lexer.tokenize(source, options)), options);
    } else {
      return iced_transform(parser.parse(source), options);
    }
  });

  exports.run = function(code, options) {
    var answer, dir, mainModule, _ref;
    if (options == null) {
      options = {};
    }
    mainModule = _dereq_.main;
    mainModule.filename = process.argv[1] = options.filename ? fs.realpathSync(options.filename) : '.';
    mainModule.moduleCache && (mainModule.moduleCache = {});
    dir = options.filename ? path.dirname(fs.realpathSync(options.filename)) : fs.realpathSync('.');
    mainModule.paths = _dereq_('module')._nodeModulePaths(dir);
    if (!helpers.isCoffee(mainModule.filename) || _dereq_.extensions) {
      options.runtime = "interp";
      answer = compile(code, options);
      code = (_ref = answer.js) != null ? _ref : answer;
    }
    return mainModule._compile(code, mainModule.filename);
  };

  exports["eval"] = function(code, options) {
    var Module, Script, js, k, o, r, sandbox, v, _i, _len, _module, _ref, _ref1, _require;
    if (options == null) {
      options = {};
    }
    if (!(code = code.trim())) {
      return;
    }
    Script = vm.Script;
    if (Script) {
      if (options.sandbox != null) {
        if (options.sandbox instanceof Script.createContext().constructor) {
          sandbox = options.sandbox;
        } else {
          sandbox = Script.createContext();
          _ref = options.sandbox;
          for (k in _ref) {
            if (!__hasProp.call(_ref, k)) continue;
            v = _ref[k];
            sandbox[k] = v;
          }
        }
        sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;
      } else {
        sandbox = global;
      }
      sandbox.__filename = options.filename || 'eval';
      sandbox.__dirname = path.dirname(sandbox.__filename);
      if (!(sandbox !== global || sandbox.module || sandbox.require)) {
        Module = _dereq_('module');
        sandbox.module = _module = new Module(options.modulename || 'eval');
        sandbox.require = _require = function(path) {
          return Module._load(path, _module, true);
        };
        _module.filename = sandbox.__filename;
        _ref1 = Object.getOwnPropertyNames(_dereq_);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          r = _ref1[_i];
          if (r !== 'paths') {
            _require[r] = _dereq_[r];
          }
        }
        _require.paths = _module.paths = Module._nodeModulePaths(process.cwd());
        _require.resolve = function(request) {
          return Module._resolveFilename(request, _module);
        };
      }
    }
    o = {};
    for (k in options) {
      if (!__hasProp.call(options, k)) continue;
      v = options[k];
      o[k] = v;
    }
    o.bare = true;
    js = compile(code, o);
    if (sandbox === global) {
      return vm.runInThisContext(js);
    } else {
      return vm.runInContext(js, sandbox);
    }
  };

  exports.register = function() {
    return _dereq_('./register');
  };

  if (_dereq_.extensions) {
    _ref = this.FILE_EXTENSIONS;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ext = _ref[_i];
      if ((_base = _dereq_.extensions)[ext] == null) {
        _base[ext] = function() {
          throw new Error("Use CoffeeScript.register() or require the coffee-script/register module to require " + ext + " files.");
        };
      }
    }
  }

  exports._compileFile = function(filename, sourceMap, opts_passed) {
    var answer, err, k, opts, raw, stripped, v;
    if (sourceMap == null) {
      sourceMap = false;
    }
    if (opts_passed == null) {
      opts_passed = {};
    }
    raw = fs.readFileSync(filename, 'utf8');
    stripped = raw.charCodeAt(0) === 0xFEFF ? raw.substring(1) : raw;
    opts = {
      filename: filename,
      sourceMap: sourceMap,
      literate: helpers.isLiterate(filename)
    };
    for (k in opts_passed) {
      v = opts_passed[k];
      opts[k] = v;
    }
    try {
      answer = compile(stripped, opts);
    } catch (_error) {
      err = _error;
      throw helpers.updateSyntaxError(err, stripped, filename);
    }
    return answer;
  };

  lexer = new Lexer;

  parser.lexer = {
    lex: function() {
      var tag, token;
      token = this.tokens[this.pos++];
      if (token) {
        tag = token[0], this.yytext = token[1], this.yylloc = token[2];
        this.errorToken = token.origin || token;
        this.yylineno = this.yylloc.first_line;
      } else {
        tag = '';
      }
      return tag;
    },
    setInput: function(tokens) {
      this.tokens = tokens;
      return this.pos = 0;
    },
    upcomingInput: function() {
      return "";
    }
  };

  parser.yy = _dereq_('./nodes');

  exports.iced = iced_runtime;

  parser.yy.parseError = function(message, _arg) {
    var errorLoc, errorTag, errorText, errorToken, token, tokens, _ref1;
    token = _arg.token;
    _ref1 = parser.lexer, errorToken = _ref1.errorToken, tokens = _ref1.tokens;
    errorTag = errorToken[0], errorText = errorToken[1], errorLoc = errorToken[2];
    errorText = errorToken === tokens[tokens.length - 1] ? 'end of input' : errorTag === 'INDENT' || errorTag === 'OUTDENT' ? 'indentation' : helpers.nameWhitespaceCharacter(errorText);
    return helpers.throwSyntaxError("unexpected " + errorText, errorLoc);
  };

  formatSourcePosition = function(frame, getSourceMapping) {
    var as, column, fileLocation, fileName, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;
    fileName = void 0;
    fileLocation = '';
    if (frame.isNative()) {
      fileLocation = "native";
    } else {
      if (frame.isEval()) {
        fileName = frame.getScriptNameOrSourceURL();
        if (!fileName) {
          fileLocation = "" + (frame.getEvalOrigin()) + ", ";
        }
      } else {
        fileName = frame.getFileName();
      }
      fileName || (fileName = "<anonymous>");
      line = frame.getLineNumber();
      column = frame.getColumnNumber();
      source = getSourceMapping(fileName, line, column);
      fileLocation = source ? "" + fileName + ":" + source[0] + ":" + source[1] : "" + fileName + ":" + line + ":" + column;
    }
    functionName = frame.getFunctionName();
    isConstructor = frame.isConstructor();
    isMethodCall = !(frame.isToplevel() || isConstructor);
    if (isMethodCall) {
      methodName = frame.getMethodName();
      typeName = frame.getTypeName();
      if (functionName) {
        tp = as = '';
        if (typeName && functionName.indexOf(typeName)) {
          tp = "" + typeName + ".";
        }
        if (methodName && functionName.indexOf("." + methodName) !== functionName.length - methodName.length - 1) {
          as = " [as " + methodName + "]";
        }
        return "" + tp + functionName + as + " (" + fileLocation + ")";
      } else {
        return "" + typeName + "." + (methodName || '<anonymous>') + " (" + fileLocation + ")";
      }
    } else if (isConstructor) {
      return "new " + (functionName || '<anonymous>') + " (" + fileLocation + ")";
    } else if (functionName) {
      return "" + functionName + " (" + fileLocation + ")";
    } else {
      return fileLocation;
    }
  };

  sourceMaps = {};

  getSourceMap = function(filename) {
    var answer, _ref1;
    if (sourceMaps[filename]) {
      return sourceMaps[filename];
    }
    if (_ref1 = path != null ? path.extname(filename) : void 0, __indexOf.call(exports.FILE_EXTENSIONS, _ref1) < 0) {
      return;
    }
    answer = exports._compileFile(filename, true);
    return sourceMaps[filename] = answer.sourceMap;
  };

  Error.prepareStackTrace = function(err, stack) {
    var frame, frames, getSourceMapping;
    getSourceMapping = function(filename, line, column) {
      var answer, sourceMap;
      sourceMap = getSourceMap(filename);
      if (sourceMap) {
        answer = sourceMap.sourceLocation([line - 1, column - 1]);
      }
      if (answer) {
        return [answer[0] + 1, answer[1] + 1];
      } else {
        return null;
      }
    };
    frames = (function() {
      var _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = stack.length; _j < _len1; _j++) {
        frame = stack[_j];
        if (frame.getFunction() === exports.run) {
          break;
        }
        _results.push("  at " + (formatSourcePosition(frame, getSourceMapping)));
      }
      return _results;
    })();
    return "" + (err.toString()) + "\n" + (frames.join('\n')) + "\n";
  };

}).call(this);

}).call(this,_dereq_("FWaASH"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./helpers":4,"./iced":5,"./lexer":6,"./nodes":7,"./parser":8,"./register":9,"./sourcemap":12,"FWaASH":15,"fs":13,"iced-runtime":20,"module":13,"path":14,"vm":16}],3:[function(_dereq_,module,exports){
// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var COMPLEX, IS_STRING, RATIONAL, SIGNED_RATIONAL, addSub, canonicalizeExactComplex, canonicalizeInexact, canonicalizeRational, complexParts, exactAdd, exactMul, flipSign, flipSignNeeded, gcd, limitExact, rationalParts, rationalPartsAdd, rationalReduce, realPartsValue, signedRationalParts,
    __modulo = function(a, b) { return (+a % (b = +b) + b) % b; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  COMPLEX = /^([+-]?)(\d+\/\d+|\d*\.?\d+(?:e[+-]?\d+)?)(i|([+-])(\d+\/\d+|\d*\.?\d+(?:e[+-]?\d+)?)i)?$/i;

  RATIONAL = /^(\d+)(?:\/(\d+))?$/;

  complexParts = function(string) {
    var imagPart, initialSign, parts;
    parts = COMPLEX.exec(string);
    if (parts != null) {
      imagPart = parts[3];
      initialSign = parts[1] || '+';
      if (imagPart == null) {
        return [initialSign, parts[2], '+', '0'];
      } else if (/^i$/i.test(imagPart)) {
        return ['+', '0', initialSign, parts[2]];
      } else {
        return [initialSign, parts[2], parts[4], parts[5]];
      }
    }
  };

  rationalParts = function(string) {
    var parts;
    parts = RATIONAL.exec(string);
    if (parts) {
      return [parts[1], parts[2] || '1'];
    }
  };

  realPartsValue = function(sign, string, rationalParts) {
    var value;
    value = rationalParts != null ? +rationalParts[0] / +rationalParts[1] : +string;
    if (sign === '-') {
      value = -value;
    }
    return value;
  };

  limitExact = Math.pow(2, 53);

  exactAdd = function(aSign, a, bSign, b) {
    var result;
    if ((a != null) && (b != null)) {
      a = +a;
      b = +b;
      if (aSign === '-') {
        a = -a;
      }
      if (bSign === '-') {
        b = -b;
      }
      result = a + b;
      if (Math.abs(result) < limitExact) {
        return result;
      }
    }
  };

  exactMul = function(a, b) {
    var result;
    if ((a != null) && (b != null)) {
      result = +a * +b;
      if (Math.abs(result) < limitExact) {
        return result;
      }
    }
  };

  gcd = function(a, b) {
    var _ref;
    while (b !== 0) {
      _ref = [b, __modulo(a, b)], a = _ref[0], b = _ref[1];
    }
    return a;
  };

  canonicalizeInexact = function(x) {
    var xString;
    xString = x.toString();
    if (/[.eE]|^[^\d]+$/.test(xString)) {
      return xString;
    } else {
      return "" + xString + ".0";
    }
  };

  canonicalizeRational = function(numerator, denominator) {
    var factor;
    factor = gcd(numerator, denominator);
    numerator = numerator / factor;
    denominator = denominator / factor;
    if (denominator === 1) {
      return numerator.toString();
    } else {
      return "" + numerator + "/" + denominator;
    }
  };

  canonicalizeExactComplex = function(real, imag) {
    var imagSign;
    if (imag === '0') {
      return real;
    } else {
      if (real === '0') {
        real = '';
      }
      imagSign = real !== '' && /^-/.test(imag) ? '' : '+';
      return "" + real + imagSign + imag + "i";
    }
  };

  rationalPartsAdd = function(aSign, a, bSign, b) {
    var denominator, numerator;
    denominator = exactMul(a[1], b[1]);
    if (denominator != null) {
      numerator = exactAdd(aSign, exactMul(a[0], b[1]), bSign, exactMul(b[0], a[1]));
      if (numerator != null) {
        return canonicalizeRational(numerator, denominator);
      }
    }
  };

  flipSignNeeded = function(sign) {
    if (sign === '-') {
      return '+';
    } else {
      return '-';
    }
  };

  flipSign = function(sign) {
    if (sign === '-') {
      return '';
    } else {
      return '-';
    }
  };

  exports.negate = function(value) {
    var parts;
    parts = complexParts(value);
    if (parts[3] === '0') {
      if (parts[0] === '-') {
        return parts[1];
      } else {
        return "-" + parts[1];
      }
    } else {
      if (parts[1] === '0') {
        return "" + (flipSign(parts[2])) + parts[3] + "i";
      } else {
        return "" + (flipSign(parts[0])) + parts[1] + (flipSignNeeded(parts[2])) + parts[3] + "i";
      }
    }
  };

  addSub = function(value1, value2, operation) {
    var addSubNative, flipSignMaybe, imag, imagSign, parts1, parts2, rationalParts1imag, rationalParts1real, rationalParts2imag, rationalParts2real, real;
    parts1 = complexParts(value1);
    parts2 = complexParts(value2);
    rationalParts1real = rationalParts(parts1[1]);
    rationalParts1imag = rationalParts(parts1[3]);
    rationalParts2real = rationalParts(parts2[1]);
    rationalParts2imag = rationalParts(parts2[3]);
    if (rationalParts1real && rationalParts1imag && rationalParts2real && rationalParts2imag) {
      flipSignMaybe = function(sign) {
        if (operation === '-') {
          return flipSign(sign);
        } else {
          return sign;
        }
      };
      real = rationalPartsAdd(parts1[0], rationalParts1real, flipSignMaybe(parts2[0]), rationalParts2real);
      imag = rationalPartsAdd(parts1[2], rationalParts1imag, flipSignMaybe(parts2[2]), rationalParts2imag);
      if ((real != null) && (imag != null)) {
        return canonicalizeExactComplex(real, imag);
      }
    } else {
      addSubNative = function(a, b) {
        if (operation === '-') {
          return a - b;
        } else {
          return a + b;
        }
      };
      real = addSubNative(realPartsValue(parts1[0], parts1[1], rationalParts1real), realPartsValue(parts2[0], parts2[1], rationalParts2real));
      if (parts1[3] === '0' && parts2[3] === '0') {
        return canonicalizeInexact(real);
      } else {
        imag = addSubNative(realPartsValue(parts1[2], parts1[3], rationalParts1imag), realPartsValue(parts2[2], parts2[3], rationalParts2imag));
        imagSign = imag < 0 ? '' : '+';
        return "" + (canonicalizeInexact(real)) + imagSign + (canonicalizeInexact(imag)) + "i";
      }
    }
  };

  IS_STRING = /^['"]/;

  exports.add = function(value1, value2) {
    var string;
    if (IS_STRING.test(value1)) {
      if (IS_STRING.test(value2)) {
        string = eval(value1) + eval(value2);
        string = string.replace(/\n/g, '\\n');
        if (__indexOf.call(string, '"') >= 0) {
          if (__indexOf.call(string, "'") >= 0) {
            return "\"" + (string.replace(/"/g, '\\"')) + "\"";
          } else {
            return "'" + string + "'";
          }
        } else {
          return "\"" + string + "\"";
        }
      }
    } else if (!IS_STRING.test(value2)) {
      return addSub(value1, value2, '+');
    }
  };

  exports.sub = function(value1, value2) {
    return addSub(value1, value2, '-');
  };

  rationalReduce = function(num, den) {
    if ((num != null) && (den != null) && num < Math.pow(2, 53) && 0 < den && den < Math.pow(2, 53)) {
      return canonicalizeRational(num, den);
    }
  };

  SIGNED_RATIONAL = /^([+-]?)(\d+)(\/(\d+))?(i?)$/;

  signedRationalParts = function(string) {
    var match;
    match = SIGNED_RATIONAL.exec(string);
    return [match[1] !== '-', +match[2], +(match[4] || 1), match[5] !== ''];
  };

  exports.div = function(value1, value2) {
    var aDen, aImag, aNum, aPositive, bDen, bImag, bNum, bPositive, imag, positive, rational, sign, _ref, _ref1;
    if (SIGNED_RATIONAL.test(value1) && SIGNED_RATIONAL.test(value2)) {
      _ref = signedRationalParts(value1), aPositive = _ref[0], aNum = _ref[1], aDen = _ref[2], aImag = _ref[3];
      _ref1 = signedRationalParts(value2), bPositive = _ref1[0], bNum = _ref1[1], bDen = _ref1[2], bImag = _ref1[3];
      positive = aPositive === bPositive;
      rational = rationalReduce(exactMul(aNum, bDen), exactMul(aDen, bNum));
      imag = aImag === bImag ? '' : 'i';
      if (!aImag && bImag) {
        positive = !positive;
      }
      sign = positive ? '' : '-';
      if (rational) {
        return "" + sign + rational + imag;
      }
    }
  };

}).call(this);

},{}],4:[function(_dereq_,module,exports){
(function (process){
// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var buildLocationData, extend, flatten, last, repeat, syntaxErrorToString, _ref;

  exports.starts = function(string, literal, start) {
    return literal === string.substr(start, literal.length);
  };

  exports.ends = function(string, literal, back) {
    var len;
    len = literal.length;
    return literal === string.substr(string.length - len - (back || 0), len);
  };

  exports.repeat = repeat = function(str, n) {
    var res;
    res = '';
    while (n > 0) {
      if (n & 1) {
        res += str;
      }
      n >>>= 1;
      str += str;
    }
    return res;
  };

  exports.compact = function(array) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (item) {
        _results.push(item);
      }
    }
    return _results;
  };

  exports.count = function(string, substr) {
    var num, pos;
    num = pos = 0;
    if (!substr.length) {
      return 1 / 0;
    }
    while (pos = 1 + string.indexOf(substr, pos)) {
      num++;
    }
    return num;
  };

  exports.merge = function(options, overrides) {
    return extend(extend({}, options), overrides);
  };

  extend = exports.extend = function(object, properties) {
    var key, val;
    for (key in properties) {
      val = properties[key];
      object[key] = val;
    }
    return object;
  };

  exports.flatten = flatten = function(array) {
    var element, flattened, _i, _len;
    flattened = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      element = array[_i];
      if (element instanceof Array) {
        flattened = flattened.concat(flatten(element));
      } else {
        flattened.push(element);
      }
    }
    return flattened;
  };

  exports.del = function(obj, key) {
    var val;
    val = obj[key];
    delete obj[key];
    return val;
  };

  exports.last = last = function(array, back) {
    return array[array.length - (back || 0) - 1];
  };

  exports.some = (_ref = Array.prototype.some) != null ? _ref : function(fn) {
    var e, _i, _len;
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      e = this[_i];
      if (fn(e)) {
        return true;
      }
    }
    return false;
  };

  exports.invertLiterate = function(code) {
    var line, lines, maybe_code;
    maybe_code = true;
    lines = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = code.split('\n');
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        line = _ref1[_i];
        if (maybe_code && /^([ ]{4}|[ ]{0,3}\t)/.test(line)) {
          _results.push(line);
        } else if (maybe_code = /^\s*$/.test(line)) {
          _results.push(line);
        } else {
          _results.push('# ' + line);
        }
      }
      return _results;
    })();
    return lines.join('\n');
  };

  buildLocationData = function(first, last) {
    if (!last) {
      return first;
    } else {
      return {
        first_line: first.first_line,
        first_column: first.first_column,
        last_line: last.last_line,
        last_column: last.last_column
      };
    }
  };

  exports.addLocationDataFn = function(first, last) {
    return function(obj) {
      if (((typeof obj) === 'object') && (!!obj['updateLocationDataIfMissing'])) {
        obj.updateLocationDataIfMissing(buildLocationData(first, last));
      }
      return obj;
    };
  };

  exports.locationDataToString = function(obj) {
    var locationData;
    if (("2" in obj) && ("first_line" in obj[2])) {
      locationData = obj[2];
    } else if ("first_line" in obj) {
      locationData = obj;
    }
    if (locationData) {
      return ("" + (locationData.first_line + 1) + ":" + (locationData.first_column + 1) + "-") + ("" + (locationData.last_line + 1) + ":" + (locationData.last_column + 1));
    } else {
      return "No location data";
    }
  };

  exports.baseFileName = function(file, stripExt, useWinPathSep) {
    var parts, pathSep;
    if (stripExt == null) {
      stripExt = false;
    }
    if (useWinPathSep == null) {
      useWinPathSep = false;
    }
    pathSep = useWinPathSep ? /\\|\// : /\//;
    parts = file.split(pathSep);
    file = parts[parts.length - 1];
    if (!(stripExt && file.indexOf('.') >= 0)) {
      return file;
    }
    parts = file.split('.');
    parts.pop();
    if (parts[parts.length - 1] === 'coffee' && parts.length > 1) {
      parts.pop();
    }
    return parts.join('.');
  };

  exports.isCoffee = function(file) {
    return /\.((lit)?coffee|coffee\.md|iced|liticed|iced\.md)$/.test(file);
  };

  exports.isLiterate = function(file) {
    return /\.(litcoffee|coffee\.md|liticed|iced\.md)$/.test(file);
  };

  exports.throwSyntaxError = function(message, location) {
    var error;
    error = new SyntaxError(message);
    error.location = location;
    error.toString = syntaxErrorToString;
    error.stack = error.toString();
    throw error;
  };

  exports.updateSyntaxError = function(error, code, filename) {
    if (error.toString === syntaxErrorToString) {
      error.code || (error.code = code);
      error.filename || (error.filename = filename);
      error.stack = error.toString();
    }
    return error;
  };

  syntaxErrorToString = function() {
    var codeLine, colorize, colorsEnabled, end, filename, first_column, first_line, last_column, last_line, marker, start, _ref1, _ref2;
    if (!(this.code && this.location)) {
      return Error.prototype.toString.call(this);
    }
    _ref1 = this.location, first_line = _ref1.first_line, first_column = _ref1.first_column, last_line = _ref1.last_line, last_column = _ref1.last_column;
    if (last_line == null) {
      last_line = first_line;
    }
    if (last_column == null) {
      last_column = first_column;
    }
    filename = this.filename || '[stdin]';
    codeLine = this.code.split('\n')[first_line];
    start = first_column;
    end = first_line === last_line ? last_column + 1 : codeLine.length;
    marker = codeLine.slice(0, start).replace(/[^\s]/g, ' ') + repeat('^', end - start);
    if ((typeof process !== "undefined" && process !== null ? process.stdout : void 0) != null) {
      colorsEnabled = process.stdout.isTTY && !process.env.NODE_DISABLE_COLORS;
    }
    if ((_ref2 = this.colorful) != null ? _ref2 : colorsEnabled) {
      colorize = function(str) {
        return "\x1B[1;31m" + str + "\x1B[0m";
      };
      codeLine = codeLine.slice(0, start) + colorize(codeLine.slice(start, end)) + codeLine.slice(end);
      marker = colorize(marker);
    }
    return "" + filename + ":" + (first_line + 1) + ":" + (first_column + 1) + ": error: " + this.message + "\n" + codeLine + "\n" + marker;
  };

  exports.nameWhitespaceCharacter = function(string) {
    switch (string) {
      case ' ':
        return 'space';
      case '\n':
        return 'newline';
      case '\r':
        return 'carriage return';
      case '\t':
        return 'tab';
      default:
        return string;
    }
  };

}).call(this);

}).call(this,_dereq_("FWaASH"))
},{"FWaASH":15}],5:[function(_dereq_,module,exports){
// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  exports.transform = function(x, options) {
    return x.icedTransform(options);
  };

  exports.runtime = _dereq_('iced-runtime');

}).call(this);

},{"iced-runtime":20}],6:[function(_dereq_,module,exports){
// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var BOM, BOOL, CALLABLE, CODE, COFFEE_ALIASES, COFFEE_ALIAS_MAP, COFFEE_KEYWORDS, COMMENT, COMPARE, COMPOUND_ASSIGN, HEREDOC, HEREDOC_ILLEGAL, HEREDOC_INDENT, HEREGEX, HEREGEX_OMIT, IDENTIFIER, INDENTABLE_CLOSERS, INDEXABLE, INVERSES, JSTOKEN, JS_FORBIDDEN, JS_KEYWORDS, LINE_BREAK, LINE_CONTINUER, LOGIC, Lexer, MATH, MULTILINER, MULTI_DENT, NOT_REGEX, NOT_SPACED_REGEX, NUMBER, OPERATOR, REGEX, RELATION, RESERVED, Rewriter, SHIFT, SIMPLESTR, STRICT_PROSCRIBED, TRAILING_SPACES, UNARY, UNARY_MATH, WHITESPACE, compact, count, invertLiterate, key, last, locationDataToString, repeat, starts, throwSyntaxError, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = _dereq_('./rewriter'), Rewriter = _ref.Rewriter, INVERSES = _ref.INVERSES;

  _ref1 = _dereq_('./helpers'), count = _ref1.count, starts = _ref1.starts, compact = _ref1.compact, last = _ref1.last, repeat = _ref1.repeat, invertLiterate = _ref1.invertLiterate, locationDataToString = _ref1.locationDataToString, throwSyntaxError = _ref1.throwSyntaxError;

  exports.Lexer = Lexer = (function() {
    function Lexer() {}

    Lexer.prototype.tokenize = function(code, opts) {
      var consumed, i, tag, _ref2;
      if (opts == null) {
        opts = {};
      }
      this.literate = opts.literate;
      this.indent = 0;
      this.baseIndent = 0;
      this.indebt = 0;
      this.outdebt = 0;
      this.indents = [];
      this.ends = [];
      this.tokens = [];
      this.chunkLine = opts.line || 0;
      this.chunkColumn = opts.column || 0;
      code = this.clean(code);
      i = 0;
      while (this.chunk = code.slice(i)) {
        consumed = this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.heredocToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken();
        _ref2 = this.getLineAndColumnFromChunk(consumed), this.chunkLine = _ref2[0], this.chunkColumn = _ref2[1];
        i += consumed;
      }
      this.closeIndentation();
      if (tag = this.ends.pop()) {
        this.error("missing " + tag);
      }
      if (opts.rewrite === false) {
        return this.tokens;
      }
      return (new Rewriter).rewrite(this.tokens);
    };

    Lexer.prototype.clean = function(code) {
      if (code.charCodeAt(0) === BOM) {
        code = code.slice(1);
      }
      code = code.replace(/\r/g, '').replace(TRAILING_SPACES, '');
      if (WHITESPACE.test(code)) {
        code = "\n" + code;
        this.chunkLine--;
      }
      if (this.literate) {
        code = invertLiterate(code);
      }
      return code;
    };

    Lexer.prototype.identifierToken = function() {
      var colon, colonOffset, forcedIdentifier, id, idLength, input, match, poppedToken, prev, tag, tagToken, _ref2, _ref3, _ref4;
      if (!(match = IDENTIFIER.exec(this.chunk))) {
        return 0;
      }
      input = match[0], id = match[1], colon = match[2];
      idLength = id.length;
      poppedToken = void 0;
      if (id === 'own' && this.tag() === 'FOR') {
        this.token('OWN', id);
        return id.length;
      }
      if (id === 'from' && this.tag() === 'YIELD') {
        this.token('FROM', id);
        return id.length;
      }
      forcedIdentifier = colon || (prev = last(this.tokens)) && (((_ref2 = prev[0]) === '.' || _ref2 === '?.' || _ref2 === '::' || _ref2 === '?::') || !prev.spaced && prev[0] === '@') && id !== 'defer';
      tag = 'IDENTIFIER';
      if (!forcedIdentifier && (__indexOf.call(JS_KEYWORDS, id) >= 0 || __indexOf.call(COFFEE_KEYWORDS, id) >= 0)) {
        tag = id.toUpperCase();
        if (tag === 'WHEN' && (_ref3 = this.tag(), __indexOf.call(LINE_BREAK, _ref3) >= 0)) {
          tag = 'LEADING_WHEN';
        } else if (tag === 'FOR') {
          this.seenFor = true;
        } else if (tag === 'UNLESS') {
          tag = 'IF';
        } else if (__indexOf.call(UNARY, tag) >= 0) {
          tag = 'UNARY';
        } else if (__indexOf.call(RELATION, tag) >= 0) {
          if (tag !== 'INSTANCEOF' && this.seenFor) {
            tag = 'FOR' + tag;
            this.seenFor = false;
          } else {
            tag = 'RELATION';
            if (this.value() === '!') {
              poppedToken = this.tokens.pop();
              id = '!' + id;
            }
          }
        }
      }
      if (__indexOf.call(JS_FORBIDDEN, id) >= 0) {
        if (forcedIdentifier) {
          tag = 'IDENTIFIER';
          id = new String(id);
          id.reserved = true;
        } else if (__indexOf.call(RESERVED, id) >= 0) {
          this.error("reserved word \"" + id + "\"");
        }
      }
      if (!forcedIdentifier) {
        if (__indexOf.call(COFFEE_ALIASES, id) >= 0) {
          id = COFFEE_ALIAS_MAP[id];
        }
        tag = (function() {
          switch (id) {
            case '!':
              return 'UNARY';
            case '==':
            case '!=':
              return 'COMPARE';
            case '&&':
            case '||':
              return 'LOGIC';
            case 'true':
            case 'false':
              return 'BOOL';
            case 'break':
            case 'continue':
              return 'STATEMENT';
            default:
              return tag;
          }
        })();
      }
      tagToken = this.token(tag, id, 0, idLength);
      if (poppedToken) {
        _ref4 = [poppedToken[2].first_line, poppedToken[2].first_column], tagToken[2].first_line = _ref4[0], tagToken[2].first_column = _ref4[1];
      }
      if (colon) {
        colonOffset = input.lastIndexOf(':');
        this.token(':', ':', colonOffset, colon.length);
      }
      return input.length;
    };

    Lexer.prototype.numberToken = function() {
      var binaryLiteral, lexedLength, match, number, octalLiteral;
      if (!(match = NUMBER.exec(this.chunk))) {
        return 0;
      }
      number = match[0];
      if (/^0[BOX]/.test(number)) {
        this.error("radix prefix '" + number + "' must be lowercase");
      } else if (/E/.test(number) && !/^0x/.test(number)) {
        this.error("exponential notation '" + number + "' must be indicated with a lowercase 'e'");
      } else if (/^0\d*[89]/.test(number)) {
        this.error("decimal literal '" + number + "' must not be prefixed with '0'");
      } else if (/^0\d+/.test(number)) {
        this.error("octal literal '" + number + "' must be prefixed with '0o'");
      }
      lexedLength = number.length;
      if (octalLiteral = /^0o([0-7]+)/.exec(number)) {
        number = '0x' + parseInt(octalLiteral[1], 8).toString(16);
      }
      if (binaryLiteral = /^0b([01]+)/.exec(number)) {
        number = '0x' + parseInt(binaryLiteral[1], 2).toString(16);
      }
      this.token('NUMBER', number, 0, lexedLength);
      return lexedLength;
    };

    Lexer.prototype.stringToken = function() {
      var inner, innerLen, numBreak, octalEsc, pos, quote, string, trimmed;
      switch (quote = this.chunk.charAt(0)) {
        case "'":
          string = (SIMPLESTR.exec(this.chunk) || [])[0];
          break;
        case '"':
          string = this.balancedString(this.chunk, '"');
      }
      if (!string) {
        return 0;
      }
      inner = string.slice(1, -1);
      trimmed = this.removeNewlines(inner);
      if (quote === '"' && 0 < string.indexOf('#{', 1)) {
        numBreak = pos = 0;
        innerLen = inner.length;
        while (inner.charAt(pos++) === '\n' && pos < innerLen) {
          numBreak++;
        }
        this.interpolateString(trimmed, {
          strOffset: 1 + numBreak,
          lexedLength: string.length
        });
      } else {
        this.token('STRING', quote + this.escapeLines(trimmed) + quote, 0, string.length);
      }
      if (octalEsc = /^(?:\\.|[^\\])*\\(?:0[0-7]|[1-7])/.test(string)) {
        this.error("octal escape sequences " + string + " are not allowed");
      }
      return string.length;
    };

    Lexer.prototype.heredocToken = function() {
      var doc, heredoc, match, quote, strOffset;
      if (!(match = HEREDOC.exec(this.chunk))) {
        return 0;
      }
      heredoc = match[0];
      quote = heredoc.charAt(0);
      doc = this.sanitizeHeredoc(match[2], {
        quote: quote,
        indent: null
      });
      if (quote === '"' && 0 <= doc.indexOf('#{')) {
        strOffset = match[2].charAt(0) === '\n' ? 4 : 3;
        this.interpolateString(doc, {
          heredoc: true,
          strOffset: strOffset,
          lexedLength: heredoc.length
        });
      } else {
        this.token('STRING', this.makeString(doc, quote, true), 0, heredoc.length);
      }
      return heredoc.length;
    };

    Lexer.prototype.commentToken = function() {
      var comment, here, match;
      if (!(match = this.chunk.match(COMMENT))) {
        return 0;
      }
      comment = match[0], here = match[1];
      if (here) {
        this.token('HERECOMMENT', this.sanitizeHeredoc(here, {
          herecomment: true,
          indent: repeat(' ', this.indent)
        }), 0, comment.length);
      }
      return comment.length;
    };

    Lexer.prototype.jsToken = function() {
      var match, script;
      if (!(this.chunk.charAt(0) === '`' && (match = JSTOKEN.exec(this.chunk)))) {
        return 0;
      }
      this.token('JS', (script = match[0]).slice(1, -1), 0, script.length);
      return script.length;
    };

    Lexer.prototype.regexToken = function() {
      var flags, length, match, prev, regex, _ref2, _ref3;
      if (this.chunk.charAt(0) !== '/') {
        return 0;
      }
      if (length = this.heregexToken()) {
        return length;
      }
      prev = last(this.tokens);
      if (prev && (_ref2 = prev[0], __indexOf.call((prev.spaced ? NOT_REGEX : NOT_SPACED_REGEX), _ref2) >= 0)) {
        return 0;
      }
      if (!(match = REGEX.exec(this.chunk))) {
        return 0;
      }
      _ref3 = match, match = _ref3[0], regex = _ref3[1], flags = _ref3[2];
      if (regex === '//') {
        return 0;
      }
      if (regex.slice(0, 2) === '/*') {
        this.error('regular expressions cannot begin with `*`');
      }
      this.token('REGEX', "" + regex + flags, 0, match.length);
      return match.length;
    };

    Lexer.prototype.heregexToken = function() {
      var body, flags, flagsOffset, heregex, match, plusToken, prev, re, tag, token, tokens, value, _i, _len, _ref2, _ref3, _ref4;
      if (!(match = HEREGEX.exec(this.chunk))) {
        return 0;
      }
      heregex = match[0], body = match[1], flags = match[2];
      if (0 > body.indexOf('#{')) {
        re = this.escapeLines(body.replace(HEREGEX_OMIT, '$1$2').replace(/\//g, '\\/'), true);
        if (re.match(/^\*/)) {
          this.error('regular expressions cannot begin with `*`');
        }
        this.token('REGEX', "/" + (re || '(?:)') + "/" + flags, 0, heregex.length);
        return heregex.length;
      }
      this.token('IDENTIFIER', 'RegExp', 0, 0);
      this.token('CALL_START', '(', 0, 0);
      tokens = [];
      _ref2 = this.interpolateString(body, {
        regex: true,
        strOffset: 3
      });
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        token = _ref2[_i];
        tag = token[0], value = token[1];
        if (tag === 'TOKENS') {
          tokens.push.apply(tokens, value);
        } else if (tag === 'NEOSTRING') {
          if (!(value = value.replace(HEREGEX_OMIT, '$1$2'))) {
            continue;
          }
          value = value.replace(/\\/g, '\\\\');
          token[0] = 'STRING';
          token[1] = this.makeString(value, '"', true);
          tokens.push(token);
        } else {
          this.error("Unexpected " + tag);
        }
        prev = last(this.tokens);
        plusToken = ['+', '+'];
        plusToken[2] = prev[2];
        tokens.push(plusToken);
      }
      tokens.pop();
      if (((_ref3 = tokens[0]) != null ? _ref3[0] : void 0) !== 'STRING') {
        this.token('STRING', '""', 0, 0);
        this.token('+', '+', 0, 0);
      }
      (_ref4 = this.tokens).push.apply(_ref4, tokens);
      if (flags) {
        flagsOffset = heregex.lastIndexOf(flags);
        this.token(',', ',', flagsOffset, 0);
        this.token('STRING', '"' + flags + '"', flagsOffset, flags.length);
      }
      this.token(')', ')', heregex.length - 1, 0);
      return heregex.length;
    };

    Lexer.prototype.lineToken = function() {
      var diff, indent, match, noNewlines, size;
      if (!(match = MULTI_DENT.exec(this.chunk))) {
        return 0;
      }
      indent = match[0];
      this.seenFor = false;
      size = indent.length - 1 - indent.lastIndexOf('\n');
      noNewlines = this.unfinished();
      if (size - this.indebt === this.indent) {
        if (noNewlines) {
          this.suppressNewlines();
        } else {
          this.newlineToken(0);
        }
        return indent.length;
      }
      if (size > this.indent) {
        if (noNewlines) {
          this.indebt = size - this.indent;
          this.suppressNewlines();
          return indent.length;
        }
        if (!this.tokens.length) {
          this.baseIndent = this.indent = size;
          return indent.length;
        }
        diff = size - this.indent + this.outdebt;
        this.token('INDENT', diff, indent.length - size, size);
        this.indents.push(diff);
        this.ends.push('OUTDENT');
        this.outdebt = this.indebt = 0;
        this.indent = size;
      } else if (size < this.baseIndent) {
        this.error('missing indentation', indent.length);
      } else {
        this.indebt = 0;
        this.outdentToken(this.indent - size, noNewlines, indent.length);
      }
      return indent.length;
    };

    Lexer.prototype.outdentToken = function(moveOut, noNewlines, outdentLength) {
      var decreasedIndent, dent, lastIndent, _ref2;
      decreasedIndent = this.indent - moveOut;
      while (moveOut > 0) {
        lastIndent = this.indents[this.indents.length - 1];
        if (!lastIndent) {
          moveOut = 0;
        } else if (lastIndent === this.outdebt) {
          moveOut -= this.outdebt;
          this.outdebt = 0;
        } else if (lastIndent < this.outdebt) {
          this.outdebt -= lastIndent;
          moveOut -= lastIndent;
        } else {
          dent = this.indents.pop() + this.outdebt;
          if (outdentLength && (_ref2 = this.chunk[outdentLength], __indexOf.call(INDENTABLE_CLOSERS, _ref2) >= 0)) {
            decreasedIndent -= dent - moveOut;
            moveOut = dent;
          }
          this.outdebt = 0;
          this.pair('OUTDENT');
          this.token('OUTDENT', moveOut, 0, outdentLength);
          moveOut -= dent;
        }
      }
      if (dent) {
        this.outdebt -= moveOut;
      }
      while (this.value() === ';') {
        this.tokens.pop();
      }
      if (!(this.tag() === 'TERMINATOR' || noNewlines)) {
        this.token('TERMINATOR', '\n', outdentLength, 0);
      }
      this.indent = decreasedIndent;
      return this;
    };

    Lexer.prototype.whitespaceToken = function() {
      var match, nline, prev;
      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\n'))) {
        return 0;
      }
      prev = last(this.tokens);
      if (prev) {
        prev[match ? 'spaced' : 'newLine'] = true;
      }
      if (match) {
        return match[0].length;
      } else {
        return 0;
      }
    };

    Lexer.prototype.newlineToken = function(offset) {
      while (this.value() === ';') {
        this.tokens.pop();
      }
      if (this.tag() !== 'TERMINATOR') {
        this.token('TERMINATOR', '\n', offset, 0);
      }
      return this;
    };

    Lexer.prototype.suppressNewlines = function() {
      if (this.value() === '\\') {
        this.tokens.pop();
      }
      return this;
    };

    Lexer.prototype.literalToken = function() {
      var match, prev, tag, value, _ref2, _ref3, _ref4, _ref5;
      if (match = OPERATOR.exec(this.chunk)) {
        value = match[0];
        if (CODE.test(value)) {
          this.tagParameters();
        }
      } else {
        value = this.chunk.charAt(0);
      }
      tag = value;
      prev = last(this.tokens);
      if (value === '=' && prev) {
        if (!prev[1].reserved && (_ref2 = prev[1], __indexOf.call(JS_FORBIDDEN, _ref2) >= 0)) {
          this.error("reserved word \"" + (this.value()) + "\" can't be assigned");
        }
        if ((_ref3 = prev[1]) === '||' || _ref3 === '&&') {
          prev[0] = 'COMPOUND_ASSIGN';
          prev[1] += '=';
          return value.length;
        }
      }
      if (value === ';') {
        this.seenFor = false;
        tag = 'TERMINATOR';
      } else if (__indexOf.call(MATH, value) >= 0) {
        tag = 'MATH';
      } else if (__indexOf.call(COMPARE, value) >= 0) {
        tag = 'COMPARE';
      } else if (__indexOf.call(COMPOUND_ASSIGN, value) >= 0) {
        tag = 'COMPOUND_ASSIGN';
      } else if (__indexOf.call(UNARY, value) >= 0) {
        tag = 'UNARY';
      } else if (__indexOf.call(UNARY_MATH, value) >= 0) {
        tag = 'UNARY_MATH';
      } else if (__indexOf.call(SHIFT, value) >= 0) {
        tag = 'SHIFT';
      } else if (__indexOf.call(LOGIC, value) >= 0 || value === '?' && (prev != null ? prev.spaced : void 0)) {
        tag = 'LOGIC';
      } else if (prev && !prev.spaced) {
        if (value === '(' && (_ref4 = prev[0], __indexOf.call(CALLABLE, _ref4) >= 0)) {
          if (prev[0] === '?') {
            prev[0] = 'FUNC_EXIST';
          }
          tag = 'CALL_START';
        } else if (value === '[' && (_ref5 = prev[0], __indexOf.call(INDEXABLE, _ref5) >= 0)) {
          tag = 'INDEX_START';
          switch (prev[0]) {
            case '?':
              prev[0] = 'INDEX_SOAK';
          }
        }
      }
      switch (value) {
        case '(':
        case '{':
        case '[':
          this.ends.push(INVERSES[value]);
          break;
        case ')':
        case '}':
        case ']':
          this.pair(value);
      }
      this.token(tag, value);
      return value.length;
    };

    Lexer.prototype.sanitizeHeredoc = function(doc, options) {
      var attempt, herecomment, indent, match, _ref2;
      indent = options.indent, herecomment = options.herecomment;
      if (herecomment) {
        if (HEREDOC_ILLEGAL.test(doc)) {
          this.error("block comment cannot contain \"*/\", starting");
        }
        if (doc.indexOf('\n') < 0) {
          return doc;
        }
      } else {
        while (match = HEREDOC_INDENT.exec(doc)) {
          attempt = match[1];
          if (indent === null || 0 < (_ref2 = attempt.length) && _ref2 < indent.length) {
            indent = attempt;
          }
        }
      }
      if (indent) {
        doc = doc.replace(RegExp("\\n" + indent, "g"), '\n');
      }
      if (!herecomment) {
        doc = doc.replace(/^\n/, '');
      }
      return doc;
    };

    Lexer.prototype.tagParameters = function() {
      var i, stack, tok, tokens;
      if (this.tag() !== ')') {
        return this;
      }
      stack = [];
      tokens = this.tokens;
      i = tokens.length;
      tokens[--i][0] = 'PARAM_END';
      while (tok = tokens[--i]) {
        switch (tok[0]) {
          case ')':
            stack.push(tok);
            break;
          case '(':
          case 'CALL_START':
            if (stack.length) {
              stack.pop();
            } else if (tok[0] === '(') {
              tok[0] = 'PARAM_START';
              return this;
            } else {
              return this;
            }
        }
      }
      return this;
    };

    Lexer.prototype.closeIndentation = function() {
      return this.outdentToken(this.indent);
    };

    Lexer.prototype.balancedString = function(str, end) {
      var continueCount, i, letter, match, prev, stack, _i, _ref2;
      continueCount = 0;
      stack = [end];
      for (i = _i = 1, _ref2 = str.length; 1 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 1 <= _ref2 ? ++_i : --_i) {
        if (continueCount) {
          --continueCount;
          continue;
        }
        switch (letter = str.charAt(i)) {
          case '\\':
            ++continueCount;
            continue;
          case end:
            stack.pop();
            if (!stack.length) {
              return str.slice(0, +i + 1 || 9e9);
            }
            end = stack[stack.length - 1];
            continue;
        }
        if (end === '}' && (letter === '"' || letter === "'")) {
          stack.push(end = letter);
        } else if (end === '}' && letter === '/' && (match = HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i)))) {
          continueCount += match[0].length - 1;
        } else if (end === '}' && letter === '{') {
          stack.push(end = '}');
        } else if (end === '"' && prev === '#' && letter === '{') {
          stack.push(end = '}');
        }
        prev = letter;
      }
      return this.error("missing " + (stack.pop()) + ", starting");
    };

    Lexer.prototype.interpolateString = function(str, options) {
      var column, errorToken, expr, heredoc, i, inner, interpolated, len, letter, lexedLength, line, locationToken, nested, offsetInChunk, pi, plusToken, popped, regex, rparen, strOffset, tag, token, tokens, value, _i, _len, _ref2, _ref3, _ref4;
      if (options == null) {
        options = {};
      }
      heredoc = options.heredoc, regex = options.regex, offsetInChunk = options.offsetInChunk, strOffset = options.strOffset, lexedLength = options.lexedLength;
      offsetInChunk || (offsetInChunk = 0);
      strOffset || (strOffset = 0);
      lexedLength || (lexedLength = str.length);
      tokens = [];
      pi = 0;
      i = -1;
      while (letter = str.charAt(i += 1)) {
        if (letter === '\\') {
          i += 1;
          continue;
        }
        if (!(letter === '#' && str.charAt(i + 1) === '{' && (expr = this.balancedString(str.slice(i + 1), '}')))) {
          continue;
        }
        if (pi < i) {
          tokens.push(this.makeToken('NEOSTRING', str.slice(pi, i), strOffset + pi));
        }
        if (!errorToken) {
          errorToken = this.makeToken('', 'string interpolation', offsetInChunk + i + 1, 2);
        }
        inner = expr.slice(1, -1);
        if (inner.length) {
          _ref2 = this.getLineAndColumnFromChunk(strOffset + i + 2), line = _ref2[0], column = _ref2[1];
          nested = new Lexer().tokenize(inner, {
            line: line,
            column: column,
            rewrite: false
          });
          popped = nested.pop();
          if (((_ref3 = nested[0]) != null ? _ref3[0] : void 0) === 'TERMINATOR') {
            popped = nested.shift();
          }
          if (len = nested.length) {
            if (len > 1) {
              nested.unshift(this.makeToken('(', '(', strOffset + i + 1, 0));
              nested.push(this.makeToken(')', ')', strOffset + i + 1 + inner.length, 0));
            }
            tokens.push(['TOKENS', nested]);
          }
        }
        i += expr.length;
        pi = i + 1;
      }
      if (i > pi && pi < str.length) {
        tokens.push(this.makeToken('NEOSTRING', str.slice(pi), strOffset + pi));
      }
      if (regex) {
        return tokens;
      }
      if (!tokens.length) {
        return this.token('STRING', '""', offsetInChunk, lexedLength);
      }
      if (tokens[0][0] !== 'NEOSTRING') {
        tokens.unshift(this.makeToken('NEOSTRING', '', offsetInChunk));
      }
      if (interpolated = tokens.length > 1) {
        this.token('(', '(', offsetInChunk, 0, errorToken);
      }
      for (i = _i = 0, _len = tokens.length; _i < _len; i = ++_i) {
        token = tokens[i];
        tag = token[0], value = token[1];
        if (i) {
          if (i) {
            plusToken = this.token('+', '+');
          }
          locationToken = tag === 'TOKENS' ? value[0] : token;
          plusToken[2] = {
            first_line: locationToken[2].first_line,
            first_column: locationToken[2].first_column,
            last_line: locationToken[2].first_line,
            last_column: locationToken[2].first_column
          };
        }
        if (tag === 'TOKENS') {
          (_ref4 = this.tokens).push.apply(_ref4, value);
        } else if (tag === 'NEOSTRING') {
          token[0] = 'STRING';
          token[1] = this.makeString(value, '"', heredoc);
          this.tokens.push(token);
        } else {
          this.error("Unexpected " + tag);
        }
      }
      if (interpolated) {
        rparen = this.makeToken(')', ')', offsetInChunk + lexedLength, 0);
        rparen.stringEnd = true;
        this.tokens.push(rparen);
      }
      return tokens;
    };

    Lexer.prototype.pair = function(tag) {
      var wanted;
      if (tag !== (wanted = last(this.ends))) {
        if ('OUTDENT' !== wanted) {
          this.error("unmatched " + tag);
        }
        this.outdentToken(last(this.indents), true);
        return this.pair(tag);
      }
      return this.ends.pop();
    };

    Lexer.prototype.getLineAndColumnFromChunk = function(offset) {
      var column, lineCount, lines, string;
      if (offset === 0) {
        return [this.chunkLine, this.chunkColumn];
      }
      if (offset >= this.chunk.length) {
        string = this.chunk;
      } else {
        string = this.chunk.slice(0, +(offset - 1) + 1 || 9e9);
      }
      lineCount = count(string, '\n');
      column = this.chunkColumn;
      if (lineCount > 0) {
        lines = string.split('\n');
        column = last(lines).length;
      } else {
        column += string.length;
      }
      return [this.chunkLine + lineCount, column];
    };

    Lexer.prototype.makeToken = function(tag, value, offsetInChunk, length) {
      var lastCharacter, locationData, token, _ref2, _ref3;
      if (offsetInChunk == null) {
        offsetInChunk = 0;
      }
      if (length == null) {
        length = value.length;
      }
      locationData = {};
      _ref2 = this.getLineAndColumnFromChunk(offsetInChunk), locationData.first_line = _ref2[0], locationData.first_column = _ref2[1];
      lastCharacter = Math.max(0, length - 1);
      _ref3 = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter), locationData.last_line = _ref3[0], locationData.last_column = _ref3[1];
      token = [tag, value, locationData];
      return token;
    };

    Lexer.prototype.token = function(tag, value, offsetInChunk, length, origin) {
      var token;
      token = this.makeToken(tag, value, offsetInChunk, length);
      if (origin) {
        token.origin = origin;
      }
      this.tokens.push(token);
      return token;
    };

    Lexer.prototype.tag = function(index, tag) {
      var tok;
      return (tok = last(this.tokens, index)) && (tag ? tok[0] = tag : tok[0]);
    };

    Lexer.prototype.value = function(index, val) {
      var tok;
      return (tok = last(this.tokens, index)) && (val ? tok[1] = val : tok[1]);
    };

    Lexer.prototype.unfinished = function() {
      var _ref2;
      return LINE_CONTINUER.test(this.chunk) || ((_ref2 = this.tag()) === '\\' || _ref2 === '.' || _ref2 === '?.' || _ref2 === '?::' || _ref2 === 'UNARY' || _ref2 === 'MATH' || _ref2 === 'UNARY_MATH' || _ref2 === '+' || _ref2 === '-' || _ref2 === 'YIELD' || _ref2 === '**' || _ref2 === 'SHIFT' || _ref2 === 'RELATION' || _ref2 === 'COMPARE' || _ref2 === 'LOGIC' || _ref2 === 'THROW' || _ref2 === 'EXTENDS');
    };

    Lexer.prototype.removeNewlines = function(str) {
      return str.replace(/^\s*\n\s*/, '').replace(/([^\\]|\\\\)\s*\n\s*$/, '$1');
    };

    Lexer.prototype.escapeLines = function(str, heredoc) {
      str = str.replace(/\\[^\S\n]*(\n|\\)\s*/g, function(escaped, character) {
        if (character === '\n') {
          return '';
        } else {
          return escaped;
        }
      });
      if (heredoc) {
        return str.replace(MULTILINER, '\\n');
      } else {
        return str.replace(/\s*\n\s*/g, ' ');
      }
    };

    Lexer.prototype.makeString = function(body, quote, heredoc) {
      if (!body) {
        return quote + quote;
      }
      body = body.replace(RegExp("\\\\(" + quote + "|\\\\)", "g"), function(match, contents) {
        if (contents === quote) {
          return contents;
        } else {
          return match;
        }
      });
      body = body.replace(RegExp("" + quote, "g"), '\\$&');
      return quote + this.escapeLines(body, heredoc) + quote;
    };

    Lexer.prototype.error = function(message, offset) {
      var first_column, first_line, _ref2;
      if (offset == null) {
        offset = 0;
      }
      _ref2 = this.getLineAndColumnFromChunk(offset), first_line = _ref2[0], first_column = _ref2[1];
      return throwSyntaxError(message, {
        first_line: first_line,
        first_column: first_column
      });
    };

    return Lexer;

  })();

  JS_KEYWORDS = ['true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'debugger', 'yield', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super'];

  COFFEE_KEYWORDS = ['undefined', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when'];

  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(['await', 'defer']);

  COFFEE_ALIAS_MAP = {
    and: '&&',
    or: '||',
    is: '==',
    isnt: '!=',
    not: '!',
    yes: 'true',
    no: 'false',
    on: 'true',
    off: 'false'
  };

  COFFEE_ALIASES = (function() {
    var _results;
    _results = [];
    for (key in COFFEE_ALIAS_MAP) {
      _results.push(key);
    }
    return _results;
  })();

  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);

  RESERVED = ['case', 'default', 'function', 'var', 'void', 'with', 'const', 'let', 'enum', 'export', 'import', 'native', '__hasProp', '__extends', '__slice', '__bind', '__indexOf', 'implements', 'interface', 'package', 'private', 'protected', 'public', 'static'];

  STRICT_PROSCRIBED = ['arguments', 'eval', 'yield*'];

  JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);

  exports.RESERVED = RESERVED.concat(JS_KEYWORDS).concat(COFFEE_KEYWORDS).concat(STRICT_PROSCRIBED);

  exports.STRICT_PROSCRIBED = STRICT_PROSCRIBED;

  BOM = 65279;

  IDENTIFIER = /^([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)([^\n\S]*:(?!:))?/;

  NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?i?/i;

  HEREDOC = /^("""|''')((?:\\[\s\S]|[^\\])*?)(?:\n[^\n\S]*)?\1/;

  OPERATOR = /^(?:[-=]>|[-+*\/%<>&|^!?=]=|>>>=?|([-+:])\1|([&|<>*\/%])\2=?|\?(\.|::)|\.{2,3})/;

  WHITESPACE = /^[^\n\S]+/;

  COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|###$)|^(?:\s*#(?!##[^#]).*)+/;

  CODE = /^[-=]>/;

  MULTI_DENT = /^(?:\n[^\n\S]*)+/;

  SIMPLESTR = /^'[^\\']*(?:\\[\s\S][^\\']*)*'/;

  JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;

  REGEX = /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/;

  HEREGEX = /^\/{3}((?:\\?[\s\S])+?)\/{3}([imgy]{0,4})(?!\w)/;

  HEREGEX_OMIT = /((?:\\\\)+)|\\(\s|\/)|\s+(?:#.*)?/g;

  MULTILINER = /\n/g;

  HEREDOC_INDENT = /\n+([^\n\S]*)/g;

  HEREDOC_ILLEGAL = /\*\//;

  LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;

  TRAILING_SPACES = /\s+$/;

  COMPOUND_ASSIGN = ['-=', '+=', '/=', '*=', '%=', '||=', '&&=', '?=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '**=', '//=', '%%='];

  UNARY = ['NEW', 'TYPEOF', 'DELETE', 'DO'];

  UNARY_MATH = ['!', '~'];

  LOGIC = ['&&', '||', '&', '|', '^'];

  SHIFT = ['<<', '>>', '>>>'];

  COMPARE = ['==', '!=', '<', '>', '<=', '>='];

  MATH = ['*', '/', '%', '//', '%%'];

  RELATION = ['IN', 'OF', 'INSTANCEOF'];

  BOOL = ['TRUE', 'FALSE'];

  NOT_REGEX = ['NUMBER', 'REGEX', 'BOOL', 'NULL', 'UNDEFINED', '++', '--'];

  NOT_SPACED_REGEX = NOT_REGEX.concat(')', '}', 'THIS', 'IDENTIFIER', 'STRING', ']');

  CALLABLE = ['IDENTIFIER', 'STRING', 'REGEX', ')', ']', '}', '?', '::', '@', 'THIS', 'SUPER'];

  INDEXABLE = CALLABLE.concat('NUMBER', 'BOOL', 'NULL', 'UNDEFINED');

  LINE_BREAK = ['INDENT', 'OUTDENT', 'TERMINATOR'];

  INDENTABLE_CLOSERS = [')', '}', ']'];

  CALLABLE.push('DEFER');

}).call(this);

},{"./helpers":4,"./rewriter":10}],7:[function(_dereq_,module,exports){
(function (__dirname){
// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var Access, Arr, Assign, Await, Base, Block, Call, Class, Closure, Code, CodeFragment, Comment, CpsCascade, Defer, EXACT_REAL, Existence, Expansion, Extends, For, HEXNUM, IDENTIFIER, IDENTIFIER_STR, IcedReturnValue, IcedRuntime, IcedTailCall, If, In, Index, InlineRuntime, LEVEL_ACCESS, LEVEL_COND, LEVEL_LIST, LEVEL_OP, LEVEL_PAREN, LEVEL_TOP, Literal, METHOD_DEF, NEGATE, NO, NULL, NUMBER, Obj, Op, Param, Parens, RESERVED, Range, Return, SIMPLENUM, STRICT_PROSCRIBED, Scope, Slice, Slot, Splat, Switch, TAB, THIS, Throw, Try, UTILITIES, Value, While, YES, addLocationDataFn, compact, del, ends, extend, flatten, fragmentsToText, iced, isLiteralArguments, isLiteralThis, last, locationDataToString, merge, multident, parseNum, pathmod, quote_path_for_emission, require_top_dir, schemeNumberFunction, schemeNumberFunctionWrapper, schemeNumberValue, some, starts, throwSyntaxError, unfoldSoak, utility, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  Error.stackTraceLimit = Infinity;

  Scope = _dereq_('./scope').Scope;

  _ref = _dereq_('./lexer'), RESERVED = _ref.RESERVED, STRICT_PROSCRIBED = _ref.STRICT_PROSCRIBED;

  iced = _dereq_('iced-runtime');

  pathmod = _dereq_('path');

  _ref1 = _dereq_('./helpers'), compact = _ref1.compact, flatten = _ref1.flatten, extend = _ref1.extend, merge = _ref1.merge, del = _ref1.del, starts = _ref1.starts, ends = _ref1.ends, last = _ref1.last, some = _ref1.some, addLocationDataFn = _ref1.addLocationDataFn, locationDataToString = _ref1.locationDataToString, throwSyntaxError = _ref1.throwSyntaxError;

  exports.extend = extend;

  exports.addLocationDataFn = addLocationDataFn;

  exports.ConstantFold = _dereq_('./constant-fold');

  YES = function() {
    return true;
  };

  NO = function() {
    return false;
  };

  THIS = function() {
    return this;
  };

  NEGATE = function() {
    this.negated = !this.negated;
    return this;
  };

  NULL = function() {
    return new Value(new Literal('null', 'NULL'));
  };

  exports.CodeFragment = CodeFragment = (function() {
    function CodeFragment(parent, code) {
      var _ref2;
      this.code = "" + code;
      this.locationData = parent != null ? parent.locationData : void 0;
      this.type = (parent != null ? (_ref2 = parent.constructor) != null ? _ref2.name : void 0 : void 0) || 'unknown';
    }

    CodeFragment.prototype.toString = function() {
      return "" + this.code + (this.locationData ? ": " + locationDataToString(this.locationData) : '');
    };

    return CodeFragment;

  })();

  fragmentsToText = function(fragments) {
    var fragment;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = fragments.length; _i < _len; _i++) {
        fragment = fragments[_i];
        _results.push(fragment.code);
      }
      return _results;
    })()).join('');
  };

  exports.Base = Base = (function() {
    function Base() {
      this.icedContinuationBlock = null;
      this.icedLoopFlag = false;
      this.icedNodeFlag = false;
      this.icedGotCpsSplitFlag = false;
      this.icedCpsPivotFlag = false;
      this.icedHasAutocbFlag = false;
      this.icedFoundArguments = false;
      this.icedParentAwait = null;
      this.icedCallContinuationFlag = false;
    }

    Base.prototype.compile = function(o, lvl) {
      return fragmentsToText(this.compileToFragments(o, lvl));
    };

    Base.prototype.compileToFragments = function(o, lvl) {
      var node;
      o = extend({}, o);
      if (lvl) {
        o.level = lvl;
      }
      node = this.unfoldSoak(o) || this;
      node.tab = o.indent;
      if (node.icedHasContinuation() && !node.icedGotCpsSplitFlag) {
        return node.icedCompileCps(o);
      } else if (o.level === LEVEL_TOP || !node.isStatement(o)) {
        return node.compileNode(o);
      } else {
        return node.compileClosure(o);
      }
    };

    Base.prototype.compileClosure = function(o) {
      var args, argumentsNode, func, jumpNode, meth;
      if (jumpNode = this.jumps()) {
        jumpNode.error('cannot use a pure statement in an expression');
      }
      o.sharedScope = true;
      this.icedClearAutocbFlags();
      func = new Code([], Block.wrap([this]));
      args = [];
      if ((argumentsNode = this.contains(isLiteralArguments)) || this.contains(isLiteralThis)) {
        args = [new Literal('this')];
        if (argumentsNode) {
          meth = 'apply';
          args.push(new Literal('arguments'));
        } else {
          meth = 'call';
        }
        func = new Value(func, [new Access(new Literal(meth))]);
      }
      return (new Call(func, args)).compileNode(o);
    };

    Base.prototype.cache = function(o, level, reused) {
      var ref, sub;
      if (!this.isComplex()) {
        ref = level ? this.compileToFragments(o, level) : this;
        return [ref, ref];
      } else {
        ref = new Literal(reused || o.scope.freeVariable('ref'));
        sub = new Assign(ref, this);
        if (level) {
          return [sub.compileToFragments(o, level), [this.makeCode(ref.value)]];
        } else {
          return [sub, ref];
        }
      }
    };

    Base.prototype.cacheToCodeFragments = function(cacheValues) {
      return [fragmentsToText(cacheValues[0]), fragmentsToText(cacheValues[1])];
    };

    Base.prototype.makeReturn = function(res) {
      var me;
      me = this.unwrapAll();
      if (res) {
        return new Call(new Literal("" + res + ".push"), [me]);
      } else {
        return new Return(me, this.icedHasAutocbFlag);
      }
    };

    Base.prototype.contains = function(pred) {
      var node;
      node = void 0;
      this.traverseChildren(false, function(n) {
        if (pred(n)) {
          node = n;
          return false;
        }
      });
      return node;
    };

    Base.prototype.lastNonComment = function(list) {
      var i;
      i = list.length;
      while (i--) {
        if (!(list[i] instanceof Comment)) {
          return list[i];
        }
      }
      return null;
    };

    Base.prototype.toString = function(idt, name) {
      var extras, tree;
      if (idt == null) {
        idt = '';
      }
      if (name == null) {
        name = this.constructor.name;
      }
      extras = [];
      if (this.icedNodeFlag) {
        extras.push("A");
      }
      if (this.icedLoopFlag) {
        extras.push("L");
      }
      if (this.icedCpsPivotFlag) {
        extras.push("P");
      }
      if (this.icedHasAutocbFlag) {
        extras.push("C");
      }
      if (this.icedParentAwait) {
        extras.push("D");
      }
      if (this.icedFoundArguments) {
        extras.push("G");
      }
      if (extras.length) {
        extras = " (" + extras.join('') + ")";
      }
      tree = '\n' + idt + name;
      tree = '\n' + idt + name;
      if (this.soak) {
        tree += '?';
      }
      tree += extras;
      this.eachChild(function(node) {
        return tree += node.toString(idt + TAB);
      });
      if (this.icedContinuationBlock) {
        idt += TAB;
        tree += '\n' + idt + "Continuation";
        tree += this.icedContinuationBlock.toString(idt + TAB);
      }
      return tree;
    };

    Base.prototype.eachChild = function(func) {
      var attr, child, _i, _j, _len, _len1, _ref2, _ref3;
      if (!this.children) {
        return this;
      }
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {
          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            child = _ref3[_j];
            if (func(child) === false) {
              return this;
            }
          }
        }
      }
      return this;
    };

    Base.prototype.traverseChildren = function(crossScope, func) {
      return this.eachChild(function(child) {
        var recur;
        recur = func(child);
        if (recur !== false) {
          return child.traverseChildren(crossScope, func);
        }
      });
    };

    Base.prototype.invert = function() {
      return new Op('!', this);
    };

    Base.prototype.unwrapAll = function() {
      var node;
      node = this;
      while (node !== (node = node.unwrap())) {
        continue;
      }
      return node;
    };

    Base.prototype.flattenChildren = function() {
      var attr, child, out, _i, _j, _len, _len1, _ref2, _ref3;
      out = [];
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {
          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            child = _ref3[_j];
            out.push(child);
          }
        }
      }
      return out;
    };

    Base.prototype.icedCompileCps = function(o) {
      var code;
      this.icedGotCpsSplitFlag = true;
      code = CpsCascade.wrap(this, this.icedContinuationBlock, null, o);
      o.sharedScope = true;
      return code.compileNode(o);
    };

    Base.prototype.icedWalkAst = function(p, o) {
      var child, _i, _len, _ref2;
      this.icedParentAwait = p;
      this.icedHasAutocbFlag = o.foundAutocb;
      _ref2 = this.flattenChildren();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        child = _ref2[_i];
        if (child.icedWalkAst(p, o)) {
          this.icedNodeFlag = true;
        }
      }
      return this.icedNodeFlag;
    };

    Base.prototype.icedWalkAstLoops = function(flood) {
      var child, _i, _len, _ref2;
      if (this.isLoop() && this.icedNodeFlag) {
        flood = true;
      }
      if (this.isLoop() && !this.icedNodeFlag) {
        flood = false;
      }
      this.icedLoopFlag = flood;
      _ref2 = this.flattenChildren();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        child = _ref2[_i];
        if (child.icedWalkAstLoops(flood)) {
          this.icedLoopFlag = true;
        }
      }
      return this.icedLoopFlag;
    };

    Base.prototype.icedWalkCpsPivots = function() {
      var child, _i, _len, _ref2;
      if (this.icedNodeFlag || (this.icedLoopFlag && this.icedIsJump())) {
        this.icedCpsPivotFlag = true;
      }
      _ref2 = this.flattenChildren();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        child = _ref2[_i];
        if (child.icedWalkCpsPivots()) {
          this.icedCpsPivotFlag = true;
        }
      }
      return this.icedCpsPivotFlag;
    };

    Base.prototype.icedClearAutocbFlags = function() {
      this.icedHasAutocbFlag = false;
      return this.traverseChildren(false, function(node) {
        node.icedHasAutocbFlag = false;
        return true;
      });
    };

    Base.prototype.icedCpsRotate = function() {
      var child, _i, _len, _ref2;
      _ref2 = this.flattenChildren();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        child = _ref2[_i];
        child.icedCpsRotate();
      }
      return this;
    };

    Base.prototype.icedIsCpsPivot = function() {
      return this.icedCpsPivotFlag;
    };

    Base.prototype.icedNestContinuationBlock = function(b) {
      return this.icedContinuationBlock = b;
    };

    Base.prototype.icedHasContinuation = function() {
      return !!this.icedContinuationBlock;
    };

    Base.prototype.icedCallContinuation = function() {
      return this.icedCallContinuationFlag = true;
    };

    Base.prototype.icedWrapContinuation = NO;

    Base.prototype.icedIsJump = NO;

    Base.prototype.icedUnwrap = function(e) {
      if (e.icedHasContinuation() && this.icedHasContinuation()) {
        return this;
      } else {
        if (this.icedHasContinuation()) {
          e.icedContinuationBlock = this.icedContinuationBlock;
        }
        return e;
      }
    };

    Base.prototype.icedStatementAssertion = function() {
      if (this.icedIsCpsPivot()) {
        return this.error("await'ed statements can't act as expressions");
      }
    };

    Base.prototype.children = [];

    Base.prototype.isStatement = NO;

    Base.prototype.jumps = NO;

    Base.prototype.isComplex = YES;

    Base.prototype.isChainable = NO;

    Base.prototype.isAssignable = NO;

    Base.prototype.isLoop = NO;

    Base.prototype.isNumber = NO;

    Base.prototype.isString = NO;

    Base.prototype.isNumberOrString = NO;

    Base.prototype.isPrimitive = NO;

    Base.prototype.isLiteralConstant = NO;

    Base.prototype.unwrap = THIS;

    Base.prototype.unfoldSoak = NO;

    Base.prototype.assigns = NO;

    Base.prototype.updateLocationDataIfMissing = function(locationData) {
      if (this.locationData) {
        return this;
      }
      this.locationData = locationData;
      return this.eachChild(function(child) {
        return child.updateLocationDataIfMissing(locationData);
      });
    };

    Base.prototype.error = function(message) {
      return throwSyntaxError(message, this.locationData);
    };

    Base.prototype.makeCode = function(code) {
      return new CodeFragment(this, code);
    };

    Base.prototype.wrapInBraces = function(fragments) {
      return [].concat(this.makeCode('('), fragments, this.makeCode(')'));
    };

    Base.prototype.joinFragmentArrays = function(fragmentsList, joinStr) {
      var answer, fragments, i, _i, _len;
      answer = [];
      for (i = _i = 0, _len = fragmentsList.length; _i < _len; i = ++_i) {
        fragments = fragmentsList[i];
        if (i) {
          answer.push(this.makeCode(joinStr));
        }
        answer = answer.concat(fragments);
      }
      return answer;
    };

    return Base;

  })();

  exports.Block = Block = (function(_super) {
    __extends(Block, _super);

    function Block(nodes) {
      Block.__super__.constructor.call(this);
      this.expressions = compact(flatten(nodes || []));
    }

    Block.prototype.children = ['expressions'];

    Block.prototype.push = function(node) {
      this.expressions.push(node);
      return this;
    };

    Block.prototype.pop = function() {
      return this.expressions.pop();
    };

    Block.prototype.unshift = function(node) {
      this.expressions.unshift(node);
      return this;
    };

    Block.prototype.unwrap = function() {
      if (this.expressions.length === 1) {
        return this.icedUnwrap(this.expressions[0]);
      } else {
        return this;
      }
    };

    Block.prototype.isEmpty = function() {
      return !this.expressions.length;
    };

    Block.prototype.isStatement = function(o) {
      var exp, _i, _len, _ref2;
      _ref2 = this.expressions;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        exp = _ref2[_i];
        if (exp.isStatement(o)) {
          return true;
        }
      }
      return false;
    };

    Block.prototype.jumps = function(o) {
      var exp, jumpNode, _i, _len, _ref2;
      _ref2 = this.expressions;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        exp = _ref2[_i];
        if (jumpNode = exp.jumps(o)) {
          return jumpNode;
        }
      }
    };

    Block.prototype.makeReturn = function(res) {
      var expr, foundReturn, len;
      len = this.expressions.length;
      foundReturn = false;
      while (len--) {
        expr = this.expressions[len];
        if (!(expr instanceof Comment)) {
          this.expressions[len] = expr.makeReturn(res);
          if (expr instanceof Return && !expr.expression && !expr.icedHasAutocbFlag) {
            this.expressions.splice(len, 1);
            foundReturn = true;
          } else if (!(expr instanceof If) || expr.elseBody) {
            foundReturn = true;
          }
          break;
        }
      }
      if (this.icedHasAutocbFlag && !this.icedNodeFlag && !foundReturn) {
        this.expressions.push(new Return(null, true));
      }
      return this;
    };

    Block.prototype.compileToFragments = function(o, level) {
      if (o == null) {
        o = {};
      }
      if (o.scope) {
        return Block.__super__.compileToFragments.call(this, o, level);
      } else {
        return this.compileRoot(o);
      }
    };

    Block.prototype.compileNode = function(o) {
      var answer, compiledNodes, fragments, index, node, top, _i, _len, _ref2;
      this.tab = o.indent;
      top = o.level === LEVEL_TOP;
      compiledNodes = [];
      _ref2 = this.expressions;
      for (index = _i = 0, _len = _ref2.length; _i < _len; index = ++_i) {
        node = _ref2[index];
        node = node.unwrapAll();
        node = node.unfoldSoak(o) || node;
        if (node instanceof Block) {
          compiledNodes.push(node.compileNode(o));
        } else if (top) {
          node.front = true;
          fragments = node.compileToFragments(o);
          if (!node.isStatement(o)) {
            fragments.unshift(this.makeCode("" + this.tab));
            fragments.push(this.makeCode(";"));
          }
          compiledNodes.push(fragments);
        } else {
          compiledNodes.push(node.compileToFragments(o, LEVEL_LIST));
        }
      }
      if (top) {
        if (this.spaced) {
          return [].concat(this.joinFragmentArrays(compiledNodes, '\n\n'), this.makeCode("\n"));
        } else {
          return this.joinFragmentArrays(compiledNodes, '\n');
        }
      }
      if (compiledNodes.length) {
        answer = this.joinFragmentArrays(compiledNodes, ', ');
      } else {
        answer = [this.makeCode("void 0")];
      }
      if (compiledNodes.length > 1 && o.level >= LEVEL_LIST) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    Block.prototype.compileRoot = function(o) {
      var exp, fragments, i, name, prelude, preludeExps, rest, _i, _len, _ref2;
      o.indent = o.bare ? '' : TAB;
      o.level = LEVEL_TOP;
      this.spaced = true;
      o.scope = new Scope(null, this, null);
      _ref2 = o.locals || [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        name = _ref2[_i];
        o.scope.parameter(name);
      }
      prelude = [];
      if (!o.bare) {
        preludeExps = (function() {
          var _j, _len1, _ref3, _results;
          _ref3 = this.expressions;
          _results = [];
          for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
            exp = _ref3[i];
            if (!(exp.unwrap() instanceof Comment)) {
              break;
            }
            _results.push(exp);
          }
          return _results;
        }).call(this);
        rest = this.expressions.slice(preludeExps.length);
        this.expressions = preludeExps;
        if (preludeExps.length) {
          prelude = this.compileNode(merge(o, {
            indent: ''
          }));
          prelude.push(this.makeCode("\n"));
        }
        this.expressions = rest;
      }
      fragments = this.compileWithDeclarations(o);
      if (o.bare) {
        return fragments;
      }
      return [].concat(prelude, this.makeCode("(function() {\n"), fragments, this.makeCode("\n}).call(this);\n"));
    };

    Block.prototype.compileWithDeclarations = function(o) {
      var assigns, declars, exp, fragments, i, post, rest, scope, spaced, _i, _len, _ref2, _ref3, _ref4;
      fragments = [];
      post = [];
      _ref2 = this.expressions;
      for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
        exp = _ref2[i];
        exp = exp.unwrap();
        if (!(exp instanceof Comment || exp instanceof Literal)) {
          break;
        }
      }
      o = merge(o, {
        level: LEVEL_TOP
      });
      if (i) {
        rest = this.expressions.splice(i, 9e9);
        _ref3 = [this.spaced, false], spaced = _ref3[0], this.spaced = _ref3[1];
        _ref4 = [this.compileNode(o), spaced], fragments = _ref4[0], this.spaced = _ref4[1];
        this.expressions = rest;
      }
      post = this.compileNode(o);
      scope = o.scope;
      if (scope.expressions === this) {
        declars = o.scope.hasDeclarations();
        assigns = scope.hasAssignments;
        if (declars || assigns) {
          if (i) {
            fragments.push(this.makeCode('\n'));
          }
          fragments.push(this.makeCode("" + this.tab + "var "));
          if (declars) {
            fragments.push(this.makeCode(scope.declaredVariables().join(', ')));
          }
          if (assigns) {
            if (declars) {
              fragments.push(this.makeCode(",\n" + (this.tab + TAB)));
            }
            fragments.push(this.makeCode(scope.assignedVariables().join(",\n" + (this.tab + TAB))));
          }
          fragments.push(this.makeCode(";\n" + (this.spaced ? '\n' : '')));
        } else if (fragments.length && post.length) {
          fragments.push(this.makeCode("\n"));
        }
      }
      return fragments.concat(post);
    };

    Block.wrap = function(nodes) {
      if (nodes.length === 1 && nodes[0] instanceof Block) {
        return nodes[0];
      }
      return new Block(nodes);
    };

    Block.prototype.icedThreadReturn = function(call) {
      var expr, len;
      call = call || new IcedTailCall;
      len = this.expressions.length;
      while (len--) {
        expr = this.expressions[len];
        if (expr.isStatement()) {
          break;
        }
        if (!(expr instanceof Comment) && !(expr instanceof Return)) {
          call.assignValue(expr);
          this.expressions[len] = call;
          return;
        }
      }
      return this.expressions.push(call);
    };

    Block.prototype.icedCompileCps = function(o) {
      this.icedGotCpsSplitFlag = true;
      if (this.expressions.length > 1) {
        return Block.__super__.icedCompileCps.call(this, o);
      } else {
        return this.compileNode(o);
      }
    };

    Block.prototype.icedCpsRotate = function() {
      var child, e, i, pivot, rest, _i, _j, _len, _len1, _ref2;
      pivot = null;
      _ref2 = this.expressions;
      for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
        e = _ref2[i];
        if (e.icedIsCpsPivot()) {
          pivot = e;
          pivot.icedCallContinuation();
        }
        e.icedCpsRotate();
        if (pivot) {
          break;
        }
      }
      if (!pivot) {
        return this;
      }
      if (pivot.icedContinuationBlock) {
        throw SyntaxError("unexpected continuation block in node");
      }
      rest = this.expressions.slice(i + 1);
      this.expressions = this.expressions.slice(0, i + 1);
      if (rest.length) {
        child = new Block(rest);
        pivot.icedNestContinuationBlock(child);
        for (_j = 0, _len1 = rest.length; _j < _len1; _j++) {
          e = rest[_j];
          if (e.icedNodeFlag) {
            child.icedNodeFlag = true;
          }
          if (e.icedLoopFlag) {
            child.icedLoopFlag = true;
          }
          if (e.icedCpsPivotFlag) {
            child.icedCpsPivotFlag = true;
          }
          if (e.icedHasAutocbFlag) {
            child.icedHasAutocbFlag = true;
          }
        }
        child.icedCpsRotate();
      }
      return this;
    };

    Block.prototype.icedAddRuntime = function(foundDefer, foundAwait) {
      var index, node;
      index = 0;
      while ((node = this.expressions[index]) && (node instanceof Comment || node.isString())) {
        index++;
      }
      return this.expressions.splice(index, 0, new IcedRuntime(foundDefer, foundAwait));
    };

    Block.prototype.icedTransform = function(opts) {
      var obj;
      obj = {};
      this.icedWalkAst(null, obj);
      if (!(opts != null ? opts.repl : void 0) && (obj.foundDefer || obj.foundAwait || opts.runforce)) {
        this.icedAddRuntime(obj.foundDefer, obj.foundAwait);
      }
      if (obj.foundAwait) {
        this.icedWalkAstLoops(false);
        this.icedWalkCpsPivots();
        this.icedCpsRotate();
      }
      return this;
    };

    Block.prototype.icedGetSingle = function() {
      if (this.expressions.length === 1) {
        return this.expressions[0];
      } else {
        return null;
      }
    };

    return Block;

  })(Base);

  exports.Literal = Literal = (function(_super) {
    __extends(Literal, _super);

    function Literal(value, kind) {
      this.value = value;
      this.kind = kind;
      if (this.value == null) {
        throw new Error("whoops!");
      }
      Literal.__super__.constructor.call(this);
    }

    Literal.prototype.makeReturn = function() {
      if (this.isStatement()) {
        return this;
      } else {
        return Literal.__super__.makeReturn.apply(this, arguments);
      }
    };

    Literal.prototype.isAssignable = function() {
      return IDENTIFIER.test(this.value);
    };

    Literal.prototype.isStatement = function() {
      var _ref2;
      return (_ref2 = this.value) === 'break' || _ref2 === 'continue' || _ref2 === 'debugger';
    };

    Literal.prototype.isComplex = NO;

    Literal.prototype.assigns = function(name) {
      return name === this.value;
    };

    Literal.prototype.jumps = function(o) {
      if (this.value === 'break' && !((o != null ? o.loop : void 0) || (o != null ? o.block : void 0))) {
        return this;
      }
      if (this.value === 'continue' && !(o != null ? o.loop : void 0)) {
        return this;
      }
    };

    Literal.prototype.compileNode = function(o) {
      var answer, code, _ref2;
      if (this.icedLoopFlag && this.icedIsJump()) {
        return this.icedCompileIced(o);
      }
      if (this.kind === 'Number') {
        if (o.numeric) {
          if (HEXNUM.test(this.value)) {
            return (new Value(new Literal(schemeNumberValue(this.value.replace(/0x/i, ''), 16)))).compileNode(o);
          }
          return (new Value(new Literal(schemeNumberValue(this.value)))).compileNode(o);
        } else {
          if (/i$/i.test(this.value)) {
            this.error("can't use imaginary values unless using Scheme numbers");
          }
        }
      }
      code = this.value === 'this' ? ((_ref2 = o.scope.method) != null ? _ref2.bound : void 0) ? o.scope.method.context : this.value : this.value.reserved ? "\"" + this.value + "\"" : this.value;
      answer = this.isStatement() ? "" + this.tab + code + ";" : code;
      return [this.makeCode(answer)];
    };

    Literal.prototype.toString = function() {
      return ' "' + this.value + '"' + (this.kind ? ", " + this.kind : '');
    };

    Literal.prototype.icedWalkAst = function(parent, o) {
      if (this.value === 'arguments' && o.foundAwaitFunc) {
        o.foundArguments = true;
        this.value = "_arguments";
      }
      return false;
    };

    Literal.prototype.icedIsJump = function() {
      var _ref2;
      return (_ref2 = this.value) === 'break' || _ref2 === 'continue';
    };

    Literal.prototype.icedCompileIced = function(o) {
      var call, d, func, l;
      d = {
        'continue': iced["const"].c_while,
        'break': iced["const"].b_while
      };
      l = d[this.value];
      func = new Value(new Literal(l));
      call = new Call(func, []);
      return call.compileNode(o);
    };

    return Literal;

  })(Base);

  exports.Undefined = (function(_super) {
    __extends(Undefined, _super);

    function Undefined() {
      return Undefined.__super__.constructor.apply(this, arguments);
    }

    Undefined.prototype.isAssignable = NO;

    Undefined.prototype.isComplex = NO;

    Undefined.prototype.compileNode = function(o) {
      return [this.makeCode(o.level >= LEVEL_ACCESS ? '(void 0)' : 'void 0')];
    };

    return Undefined;

  })(Base);

  exports.Null = (function(_super) {
    __extends(Null, _super);

    function Null() {
      return Null.__super__.constructor.apply(this, arguments);
    }

    Null.prototype.isAssignable = NO;

    Null.prototype.isComplex = NO;

    Null.prototype.compileNode = function() {
      return [this.makeCode("null")];
    };

    return Null;

  })(Base);

  exports.Bool = (function(_super) {
    __extends(Bool, _super);

    Bool.prototype.isAssignable = NO;

    Bool.prototype.isComplex = NO;

    Bool.prototype.compileNode = function() {
      return [this.makeCode(this.val)];
    };

    function Bool(val) {
      this.val = val;
    }

    return Bool;

  })(Base);

  exports.Return = Return = (function(_super) {
    __extends(Return, _super);

    function Return(expression, auto) {
      this.expression = expression;
      Return.__super__.constructor.call(this);
      this.icedHasAutocbFlag = auto;
    }

    Return.prototype.children = ['expression'];

    Return.prototype.isStatement = YES;

    Return.prototype.makeReturn = THIS;

    Return.prototype.jumps = THIS;

    Return.prototype.compileToFragments = function(o, level) {
      var expr, _ref2;
      expr = (_ref2 = this.expression) != null ? _ref2.makeReturn() : void 0;
      if (expr && !(expr instanceof Return)) {
        return expr.compileToFragments(o, level);
      } else {
        return Return.__super__.compileToFragments.call(this, o, level);
      }
    };

    Return.prototype.compileNode = function(o) {
      var answer;
      if (this.icedHasAutocbFlag) {
        return this.icedCompileIced(o);
      }
      answer = [];
      answer.push(this.makeCode(this.tab + ("return" + (this.expression ? " " : ""))));
      if (this.expression) {
        answer = answer.concat(this.expression.compileToFragments(o, LEVEL_PAREN));
      }
      answer.push(this.makeCode(";"));
      return answer;
    };

    Return.prototype.icedCompileIced = function(o) {
      var args, block, call, cb, ret;
      cb = new Value(new Literal(iced["const"].autocb));
      args = this.expression ? [this.expression] : [];
      call = new Call(cb, args);
      ret = new Literal("return");
      block = new Block([call, ret]);
      return block.compileNode(o);
    };

    return Return;

  })(Base);

  exports.Value = Value = (function(_super) {
    __extends(Value, _super);

    function Value(base, props, tag) {
      Value.__super__.constructor.call(this);
      if (!props && base instanceof Value) {
        return base;
      }
      this.base = base;
      this.properties = props || [];
      if (tag) {
        this[tag] = true;
      }
      return this;
    }

    Value.prototype.children = ['base', 'properties'];

    Value.prototype.copy = function() {
      return new Value(this.base, this.properties);
    };

    Value.prototype.add = function(props) {
      this.properties = this.properties.concat(props);
      return this;
    };

    Value.prototype.hasProperties = function() {
      return !!this.properties.length;
    };

    Value.prototype.bareLiteral = function(type) {
      return !this.properties.length && this.base instanceof type;
    };

    Value.prototype.isArray = function() {
      return this.bareLiteral(Arr);
    };

    Value.prototype.isRange = function() {
      return this.bareLiteral(Range);
    };

    Value.prototype.isComplex = function() {
      return this.hasProperties() || this.base.isComplex();
    };

    Value.prototype.isAssignable = function() {
      return this.hasProperties() || this.base.isAssignable();
    };

    Value.prototype.isNumber = function() {
      return this.bareLiteral(Literal) && this.base.kind === 'Number';
    };

    Value.prototype.isSimpleNumber = function() {
      return this.bareLiteral(Literal) && SIMPLENUM.test(this.base.value);
    };

    Value.prototype.isString = function() {
      return this.bareLiteral(Literal) && this.base.kind === 'String';
    };

    Value.prototype.isNumberOrString = function() {
      var _ref2;
      return this.bareLiteral(Literal) && ((_ref2 = this.base.kind) === 'Number' || _ref2 === 'String');
    };

    Value.prototype.isRegex = function() {
      return this.bareLiteral(Literal) && this.base.kind === 'RegExp';
    };

    Value.prototype.isLiteralConstant = function() {
      var _ref2;
      return this.bareLiteral(Literal) && ((_ref2 = this.base.kind) === 'Number' || _ref2 === 'String' || _ref2 === 'RegExp');
    };

    Value.prototype.isAtomic = function() {
      var node, _i, _len, _ref2;
      _ref2 = this.properties.concat(this.base);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        node = _ref2[_i];
        if (node.soak || node instanceof Call) {
          return false;
        }
      }
      return true;
    };

    Value.prototype.isNotCallable = function() {
      return this.isLiteralConstant() || this.isArray() || this.isRange() || this.isSplice() || this.isObject();
    };

    Value.prototype.isStatement = function(o) {
      return !this.properties.length && this.base.isStatement(o);
    };

    Value.prototype.assigns = function(name) {
      return !this.properties.length && this.base.assigns(name);
    };

    Value.prototype.jumps = function(o) {
      return !this.properties.length && this.base.jumps(o);
    };

    Value.prototype.isObject = function(onlyGenerated) {
      if (this.properties.length) {
        return false;
      }
      return (this.base instanceof Obj) && (!onlyGenerated || this.base.generated);
    };

    Value.prototype.isSplice = function() {
      return last(this.properties) instanceof Slice;
    };

    Value.prototype.looksStatic = function(className) {
      var _ref2;
      return this.base.value === className && this.properties.length && ((_ref2 = this.properties[0].name) != null ? _ref2.value : void 0) !== 'prototype';
    };

    Value.prototype.unwrap = function() {
      if (this.properties.length) {
        return this;
      } else {
        return this.base;
      }
    };

    Value.prototype.cacheReference = function(o) {
      var base, bref, name, nref;
      name = last(this.properties);
      if (this.properties.length < 2 && !this.base.isComplex() && !(name != null ? name.isComplex() : void 0)) {
        return [this, this];
      }
      base = new Value(this.base, this.properties.slice(0, -1));
      if (base.isComplex()) {
        bref = new Literal(o.scope.freeVariable('base'));
        base = new Value(new Parens(new Assign(bref, base)));
      }
      if (!name) {
        return [base, bref];
      }
      if (name.isComplex()) {
        nref = new Literal(o.scope.freeVariable('name'));
        name = new Index(new Assign(nref, name.index));
        nref = new Index(nref);
      }
      return [base.add(name), new Value(bref || base.base, [nref || name])];
    };

    Value.prototype.compileNode = function(o) {
      var fragments, prop, props, _i, _len;
      this.base.front = this.front;
      props = this.properties;
      fragments = this.base.compileToFragments(o, (props.length ? LEVEL_ACCESS : null));
      if ((this.base instanceof Parens || props.length) && SIMPLENUM.test(fragmentsToText(fragments))) {
        fragments.push(this.makeCode('.'));
      }
      for (_i = 0, _len = props.length; _i < _len; _i++) {
        prop = props[_i];
        fragments.push.apply(fragments, prop.compileToFragments(o));
      }
      return fragments;
    };

    Value.prototype.unfoldSoak = function(o) {
      return this.unfoldedSoak != null ? this.unfoldedSoak : this.unfoldedSoak = (function(_this) {
        return function() {
          var fst, i, ifn, prop, ref, snd, _i, _len, _ref2, _ref3;
          if (ifn = _this.base.unfoldSoak(o)) {
            (_ref2 = ifn.body.properties).push.apply(_ref2, _this.properties);
            return ifn;
          }
          _ref3 = _this.properties;
          for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
            prop = _ref3[i];
            if (!prop.soak) {
              continue;
            }
            prop.soak = false;
            fst = new Value(_this.base, _this.properties.slice(0, i));
            snd = new Value(_this.base, _this.properties.slice(i));
            if (fst.isComplex()) {
              ref = new Literal(o.scope.freeVariable('ref'));
              fst = new Parens(new Assign(ref, fst));
              snd.base = ref;
            }
            return new If(new Existence(fst), snd, {
              soak: true
            });
          }
          return false;
        };
      })(this)();
    };

    Value.prototype.icedToSlot = function(i) {
      var sufffix, suffix;
      if (this.base instanceof Obj) {
        return this.base.icedToSlot(i);
      }
      sufffix = null;
      if (this.properties && this.properties.length) {
        suffix = this.properties.pop();
      }
      return new Slot(i, this, suffix);
    };

    Value.prototype.icedToSlotAccess = function() {
      if (this["this"]) {
        return this.properties[0];
      } else {
        return new Access(this);
      }
    };

    return Value;

  })(Base);

  exports.Comment = Comment = (function(_super) {
    __extends(Comment, _super);

    function Comment(comment) {
      this.comment = comment;
      Comment.__super__.constructor.call(this);
    }

    Comment.prototype.isStatement = YES;

    Comment.prototype.makeReturn = THIS;

    Comment.prototype.compileNode = function(o, level) {
      var code, comment;
      comment = this.comment.replace(/^(\s*)# /gm, "$1 * ");
      code = "/*" + (multident(comment, this.tab)) + (__indexOf.call(comment, '\n') >= 0 ? "\n" + this.tab : '') + " */";
      if ((level || o.level) === LEVEL_TOP) {
        code = o.indent + code;
      }
      return [this.makeCode("\n"), this.makeCode(code)];
    };

    return Comment;

  })(Base);

  exports.Call = Call = (function(_super) {
    __extends(Call, _super);

    function Call(variable, args, soak) {
      this.args = args != null ? args : [];
      this.soak = soak;
      Call.__super__.constructor.call(this);
      this.isNew = false;
      this.isSuper = variable === 'super';
      this.variable = this.isSuper ? null : variable;
      if (variable instanceof Value && variable.isNotCallable()) {
        variable.error("literal is not a function");
      }
    }

    Call.prototype.children = ['variable', 'args'];

    Call.prototype.newInstance = function() {
      var base, _ref2;
      base = ((_ref2 = this.variable) != null ? _ref2.base : void 0) || this.variable;
      if (base instanceof Call && !base.isNew) {
        base.newInstance();
      } else {
        this.isNew = true;
      }
      return this;
    };

    Call.prototype.superReference = function(o) {
      var accesses, method;
      method = o.scope.namedMethod();
      if (method != null ? method.klass : void 0) {
        accesses = [new Access(new Literal('__super__'))];
        if (method["static"]) {
          accesses.push(new Access(new Literal('constructor')));
        }
        accesses.push(new Access(new Literal(method.name)));
        return (new Value(new Literal(method.klass), accesses)).compile(o);
      } else if (method != null ? method.ctor : void 0) {
        return "" + method.name + ".__super__.constructor";
      } else {
        return this.error('cannot call super outside of an instance method.');
      }
    };

    Call.prototype.superThis = function(o) {
      var method;
      if (o.scope.icedgen) {
        return "_this";
      } else {
        method = o.scope.method;
        return (method && !method.klass && method.context) || "this";
      }
    };

    Call.prototype.unfoldSoak = function(o) {
      var call, ifn, left, list, rite, _i, _len, _ref2, _ref3;
      if (this.soak) {
        if (this.variable) {
          if (ifn = unfoldSoak(o, this, 'variable')) {
            return ifn;
          }
          _ref2 = new Value(this.variable).cacheReference(o), left = _ref2[0], rite = _ref2[1];
        } else {
          left = new Literal(this.superReference(o));
          rite = new Value(left);
        }
        rite = new Call(rite, this.args);
        rite.isNew = this.isNew;
        left = new Literal("typeof " + (left.compile(o)) + " === \"function\"");
        return new If(left, new Value(rite), {
          soak: true
        });
      }
      call = this;
      list = [];
      while (true) {
        if (call.variable instanceof Call) {
          list.push(call);
          call = call.variable;
          continue;
        }
        if (!(call.variable instanceof Value)) {
          break;
        }
        list.push(call);
        if (!((call = call.variable.base) instanceof Call)) {
          break;
        }
      }
      _ref3 = list.reverse();
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        call = _ref3[_i];
        if (ifn) {
          if (call.variable instanceof Call) {
            call.variable = ifn;
          } else {
            call.variable.base = ifn;
          }
        }
        ifn = unfoldSoak(o, call, 'variable');
      }
      return ifn;
    };

    Call.prototype.compileNode = function(o) {
      var arg, argIndex, compiledArgs, compiledArray, fragments, preface, _i, _len, _ref2, _ref3;
      if ((_ref2 = this.variable) != null) {
        _ref2.front = this.front;
      }
      compiledArray = Splat.compileSplattedArray(o, this.args, true);
      if (compiledArray.length) {
        return this.compileSplat(o, compiledArray);
      }
      compiledArgs = [];
      _ref3 = this.args;
      for (argIndex = _i = 0, _len = _ref3.length; _i < _len; argIndex = ++_i) {
        arg = _ref3[argIndex];
        arg.icedStatementAssertion();
        if (argIndex) {
          compiledArgs.push(this.makeCode(", "));
        }
        compiledArgs.push.apply(compiledArgs, arg.compileToFragments(o, LEVEL_LIST));
      }
      fragments = [];
      if (this.isSuper) {
        preface = this.superReference(o) + (".call(" + (this.superThis(o)));
        if (compiledArgs.length) {
          preface += ", ";
        }
        fragments.push(this.makeCode(preface));
      } else {
        if (this.isNew) {
          fragments.push(this.makeCode('new '));
        }
        fragments.push.apply(fragments, this.variable.compileToFragments(o, LEVEL_ACCESS));
        fragments.push(this.makeCode("("));
      }
      fragments.push.apply(fragments, compiledArgs);
      fragments.push(this.makeCode(")"));
      return fragments;
    };

    Call.prototype.compileSplat = function(o, splatArgs) {
      var answer, base, fun, idt, name, ref;
      if (this.isSuper) {
        return [].concat(this.makeCode("" + (this.superReference(o)) + ".apply(" + (this.superThis(o)) + ", "), splatArgs, this.makeCode(")"));
      }
      if (this.isNew) {
        idt = this.tab + TAB;
        return [].concat(this.makeCode("(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "var child = new ctor, result = func.apply(child, args);\n" + idt + "return Object(result) === result ? result : child;\n" + this.tab + "})("), this.variable.compileToFragments(o, LEVEL_LIST), this.makeCode(", "), splatArgs, this.makeCode(", function(){})"));
      }
      answer = [];
      base = new Value(this.variable);
      if ((name = base.properties.pop()) && base.isComplex()) {
        ref = o.scope.freeVariable('ref');
        answer = answer.concat(this.makeCode("(" + ref + " = "), base.compileToFragments(o, LEVEL_LIST), this.makeCode(")"), name.compileToFragments(o));
      } else {
        fun = base.compileToFragments(o, LEVEL_ACCESS);
        if (SIMPLENUM.test(fragmentsToText(fun))) {
          fun = this.wrapInBraces(fun);
        }
        if (name) {
          ref = fragmentsToText(fun);
          fun.push.apply(fun, name.compileToFragments(o));
        } else {
          ref = 'null';
        }
        answer = answer.concat(fun);
      }
      return answer = answer.concat(this.makeCode(".apply(" + ref + ", "), splatArgs, this.makeCode(")"));
    };

    return Call;

  })(Base);

  exports.Extends = Extends = (function(_super) {
    __extends(Extends, _super);

    function Extends(child, parent) {
      this.child = child;
      this.parent = parent;
      Extends.__super__.constructor.call(this);
    }

    Extends.prototype.children = ['child', 'parent'];

    Extends.prototype.compileToFragments = function(o) {
      return new Call(new Value(new Literal(utility('extends'))), [this.child, this.parent]).compileToFragments(o);
    };

    return Extends;

  })(Base);

  exports.Access = Access = (function(_super) {
    __extends(Access, _super);

    function Access(name, tag) {
      this.name = name;
      Access.__super__.constructor.call(this);
      this.name.asKey = true;
      this.soak = tag === 'soak';
    }

    Access.prototype.children = ['name'];

    Access.prototype.compileToFragments = function(o) {
      var name;
      name = this.name.compileToFragments(o);
      if ((IDENTIFIER.test(fragmentsToText(name))) || this.name instanceof Defer) {
        name.unshift(this.makeCode("."));
      } else {
        name.unshift(this.makeCode("["));
        name.push(this.makeCode("]"));
      }
      return name;
    };

    Access.prototype.isComplex = NO;

    return Access;

  })(Base);

  exports.Index = Index = (function(_super) {
    __extends(Index, _super);

    function Index(index) {
      this.index = index;
      Index.__super__.constructor.call(this);
    }

    Index.prototype.children = ['index'];

    Index.prototype.compileToFragments = function(o) {
      return [].concat(this.makeCode("["), this.index.compileToFragments(o, LEVEL_PAREN), this.makeCode("]"));
    };

    Index.prototype.isComplex = function() {
      return this.index.isComplex();
    };

    return Index;

  })(Base);

  exports.Range = Range = (function(_super) {
    __extends(Range, _super);

    Range.prototype.children = ['from', 'to'];

    function Range(from, to, tag) {
      this.from = from;
      this.to = to;
      Range.__super__.constructor.call(this);
      this.exclusive = tag === 'exclusive';
      this.equals = this.exclusive ? '' : '=';
    }

    Range.prototype.compileVariables = function(o) {
      var step, _ref2, _ref3, _ref4, _ref5;
      o = merge(o, {
        top: true
      });
      _ref2 = this.cacheToCodeFragments(this.from.cache(o, LEVEL_LIST)), this.fromC = _ref2[0], this.fromVar = _ref2[1];
      _ref3 = this.cacheToCodeFragments(this.to.cache(o, LEVEL_LIST)), this.toC = _ref3[0], this.toVar = _ref3[1];
      if (step = del(o, 'step')) {
        _ref4 = this.cacheToCodeFragments(step.cache(o, LEVEL_LIST)), this.step = _ref4[0], this.stepVar = _ref4[1];
      }
      _ref5 = [this.fromVar.match(NUMBER), this.toVar.match(NUMBER)], this.fromNum = _ref5[0], this.toNum = _ref5[1];
      if (this.stepVar) {
        return this.stepNum = this.stepVar.match(NUMBER);
      }
    };

    Range.prototype.compileNode = function(o) {
      var cond, condPart, from, gt, idx, idxName, known, lt, namedIndex, stepPart, to, varPart, _ref2, _ref3;
      if (!this.fromVar) {
        this.compileVariables(o);
      }
      if (!o.index) {
        return this.compileArray(o);
      }
      known = this.fromNum && this.toNum;
      idx = del(o, 'index');
      idxName = del(o, 'name');
      namedIndex = idxName && idxName !== idx;
      varPart = "" + idx + " = " + this.fromC;
      if (this.toC !== this.toVar) {
        varPart += ", " + this.toC;
      }
      if (this.step !== this.stepVar) {
        varPart += ", " + this.step;
      }
      _ref2 = ["" + idx + " <" + this.equals, "" + idx + " >" + this.equals], lt = _ref2[0], gt = _ref2[1];
      condPart = this.stepNum ? parseNum(this.stepNum[0]) > 0 ? "" + lt + " " + this.toVar : "" + gt + " " + this.toVar : known ? ((_ref3 = [parseNum(this.fromNum[0]), parseNum(this.toNum[0])], from = _ref3[0], to = _ref3[1], _ref3), from <= to ? "" + lt + " " + to : "" + gt + " " + to) : (cond = this.stepVar ? "" + this.stepVar + " > 0" : "" + this.fromVar + " <= " + this.toVar, "" + cond + " ? " + lt + " " + this.toVar + " : " + gt + " " + this.toVar);
      stepPart = this.stepVar ? "" + idx + " += " + this.stepVar : known ? namedIndex ? from <= to ? "++" + idx : "--" + idx : from <= to ? "" + idx + "++" : "" + idx + "--" : namedIndex ? "" + cond + " ? ++" + idx + " : --" + idx : "" + cond + " ? " + idx + "++ : " + idx + "--";
      if (namedIndex) {
        varPart = "" + idxName + " = " + varPart;
      }
      if (namedIndex) {
        stepPart = "" + idxName + " = " + stepPart;
      }
      return [this.makeCode("" + varPart + "; " + condPart + "; " + stepPart)];
    };

    Range.prototype.compileArray = function(o) {
      var args, body, cond, hasArgs, i, idt, post, pre, range, result, vars, _i, _ref2, _ref3, _results;
      if (this.fromNum && this.toNum && Math.abs(this.fromNum - this.toNum) <= 20) {
        range = (function() {
          _results = [];
          for (var _i = _ref2 = +this.fromNum, _ref3 = +this.toNum; _ref2 <= _ref3 ? _i <= _ref3 : _i >= _ref3; _ref2 <= _ref3 ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this);
        if (this.exclusive) {
          range.pop();
        }
        return [this.makeCode("[" + (range.join(', ')) + "]")];
      }
      idt = this.tab + TAB;
      i = o.scope.freeVariable('i');
      result = o.scope.freeVariable('results');
      pre = "\n" + idt + result + " = [];";
      if (this.fromNum && this.toNum) {
        o.index = i;
        body = fragmentsToText(this.compileNode(o));
      } else {
        vars = ("" + i + " = " + this.fromC) + (this.toC !== this.toVar ? ", " + this.toC : '');
        cond = "" + this.fromVar + " <= " + this.toVar;
        body = "var " + vars + "; " + cond + " ? " + i + " <" + this.equals + " " + this.toVar + " : " + i + " >" + this.equals + " " + this.toVar + "; " + cond + " ? " + i + "++ : " + i + "--";
      }
      post = "{ " + result + ".push(" + i + "); }\n" + idt + "return " + result + ";\n" + o.indent;
      hasArgs = function(node) {
        return node != null ? node.contains(isLiteralArguments) : void 0;
      };
      if (hasArgs(this.from) || hasArgs(this.to)) {
        args = ', arguments';
      }
      return [this.makeCode("(function() {" + pre + "\n" + idt + "for (" + body + ")" + post + "}).apply(this" + (args != null ? args : '') + ")")];
    };

    return Range;

  })(Base);

  exports.Slice = Slice = (function(_super) {
    __extends(Slice, _super);

    Slice.prototype.children = ['range'];

    function Slice(range) {
      this.range = range;
      Slice.__super__.constructor.call(this);
    }

    Slice.prototype.compileNode = function(o) {
      var compiled, compiledText, from, fromCompiled, to, toStr, _ref2;
      _ref2 = this.range, to = _ref2.to, from = _ref2.from;
      fromCompiled = from && from.compileToFragments(o, LEVEL_PAREN) || [this.makeCode('0')];
      if (to) {
        compiled = to.compileToFragments(o, LEVEL_PAREN);
        compiledText = fragmentsToText(compiled);
        if (!(!this.range.exclusive && +compiledText === -1)) {
          toStr = ', ' + (this.range.exclusive ? compiledText : SIMPLENUM.test(compiledText) ? "" + (+compiledText + 1) : (compiled = to.compileToFragments(o, LEVEL_ACCESS), "+" + (fragmentsToText(compiled)) + " + 1 || 9e9"));
        }
      }
      return [this.makeCode(".slice(" + (fragmentsToText(fromCompiled)) + (toStr || '') + ")")];
    };

    return Slice;

  })(Base);

  exports.Obj = Obj = (function(_super) {
    __extends(Obj, _super);

    function Obj(props, generated) {
      this.generated = generated != null ? generated : false;
      this.objects = this.properties = props || [];
      Obj.__super__.constructor.call(this);
    }

    Obj.prototype.children = ['properties'];

    Obj.prototype.compileNode = function(o) {
      var answer, i, idt, indent, join, lastNoncom, node, prop, props, _i, _j, _len, _len1;
      props = this.properties;
      if (!props.length) {
        return [this.makeCode(this.front ? '({})' : '{}')];
      }
      if (this.generated) {
        for (_i = 0, _len = props.length; _i < _len; _i++) {
          node = props[_i];
          if (node instanceof Value) {
            node.error('cannot have an implicit value in an implicit object');
          }
        }
      }
      idt = o.indent += TAB;
      lastNoncom = this.lastNonComment(this.properties);
      answer = [];
      for (i = _j = 0, _len1 = props.length; _j < _len1; i = ++_j) {
        prop = props[i];
        join = i === props.length - 1 ? '' : prop === lastNoncom || prop instanceof Comment ? '\n' : ',\n';
        indent = prop instanceof Comment ? '' : idt;
        if (prop instanceof Assign && prop.variable instanceof Value && prop.variable.hasProperties()) {
          prop.variable.error('Invalid object key');
        }
        if (prop instanceof Value && prop["this"]) {
          prop = new Assign(prop.properties[0].name, prop, 'object');
        }
        if (!(prop instanceof Comment)) {
          if (!(prop instanceof Assign)) {
            prop = new Assign(prop, prop, 'object');
          }
          (prop.variable.base || prop.variable).asKey = true;
        }
        if (indent) {
          answer.push(this.makeCode(indent));
        }
        answer.push.apply(answer, prop.compileToFragments(o, LEVEL_TOP));
        if (join) {
          answer.push(this.makeCode(join));
        }
      }
      answer.unshift(this.makeCode("{" + (props.length && '\n')));
      answer.push(this.makeCode("" + (props.length && '\n' + this.tab) + "}"));
      if (this.front) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    Obj.prototype.assigns = function(name) {
      var prop, _i, _len, _ref2;
      _ref2 = this.properties;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        prop = _ref2[_i];
        if (prop.assigns(name)) {
          return true;
        }
      }
      return false;
    };

    Obj.prototype.icedToSlot = function(i) {
      var access, prop, _i, _len, _ref2, _results;
      _ref2 = this.properties;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        prop = _ref2[_i];
        if (prop instanceof Assign) {
          _results.push((prop.value.icedToSlot(i)).addAccess(prop.variable.icedToSlotAccess()));
        } else if (prop instanceof Value) {
          access = prop.icedToSlotAccess();
          _results.push((prop.icedToSlot(i)).addAccess(access));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Obj;

  })(Base);

  exports.Arr = Arr = (function(_super) {
    __extends(Arr, _super);

    function Arr(objs) {
      this.objects = objs || [];
      Arr.__super__.constructor.call(this);
    }

    Arr.prototype.children = ['objects'];

    Arr.prototype.compileNode = function(o) {
      var answer, compiledObjs, fragments, index, obj, _i, _len;
      if (!this.objects.length) {
        return [this.makeCode('[]')];
      }
      o.indent += TAB;
      answer = Splat.compileSplattedArray(o, this.objects);
      if (answer.length) {
        return answer;
      }
      answer = [];
      compiledObjs = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.objects;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          obj = _ref2[_i];
          _results.push(obj.compileToFragments(o, LEVEL_LIST));
        }
        return _results;
      }).call(this);
      for (index = _i = 0, _len = compiledObjs.length; _i < _len; index = ++_i) {
        fragments = compiledObjs[index];
        if (index) {
          answer.push(this.makeCode(", "));
        }
        answer.push.apply(answer, fragments);
      }
      if (fragmentsToText(answer).indexOf('\n') >= 0) {
        answer.unshift(this.makeCode("[\n" + o.indent));
        answer.push(this.makeCode("\n" + this.tab + "]"));
      } else {
        answer.unshift(this.makeCode("["));
        answer.push(this.makeCode("]"));
      }
      return answer;
    };

    Arr.prototype.assigns = function(name) {
      var obj, _i, _len, _ref2;
      _ref2 = this.objects;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        obj = _ref2[_i];
        if (obj.assigns(name)) {
          return true;
        }
      }
      return false;
    };

    return Arr;

  })(Base);

  exports.Class = Class = (function(_super) {
    __extends(Class, _super);

    function Class(variable, parent, body) {
      this.variable = variable;
      this.parent = parent;
      this.body = body != null ? body : new Block;
      Class.__super__.constructor.call(this);
      this.boundFuncs = [];
      this.body.classBody = true;
    }

    Class.prototype.children = ['variable', 'parent', 'body'];

    Class.prototype.determineName = function() {
      var decl, tail;
      if (!this.variable) {
        return null;
      }
      decl = (tail = last(this.variable.properties)) ? tail instanceof Access && tail.name.value : this.variable.base.value;
      if (__indexOf.call(STRICT_PROSCRIBED, decl) >= 0) {
        this.variable.error("class variable name may not be " + decl);
      }
      return decl && (decl = IDENTIFIER.test(decl) && decl);
    };

    Class.prototype.setContext = function(name) {
      return this.body.traverseChildren(false, function(node) {
        if (node.classBody) {
          return false;
        }
        if (node instanceof Literal && node.value === 'this') {
          return node.value = name;
        } else if (node instanceof Code) {
          node.klass = name;
          if (node.bound) {
            return node.context = name;
          }
        }
      });
    };

    Class.prototype.addBoundFunctions = function(o) {
      var bvar, lhs, _i, _len, _ref2;
      _ref2 = this.boundFuncs;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        bvar = _ref2[_i];
        lhs = (new Value(new Literal("this"), [new Access(bvar)])).compile(o);
        this.ctor.body.unshift(new Literal("" + lhs + " = " + (utility('bind')) + "(" + lhs + ", this)"));
      }
    };

    Class.prototype.addProperties = function(node, name, o) {
      var assign, base, exprs, func, props;
      props = node.base.properties.slice(0);
      exprs = (function() {
        var _results;
        _results = [];
        while (assign = props.shift()) {
          if (assign instanceof Assign) {
            base = assign.variable.base;
            delete assign.context;
            func = assign.value;
            if (base.value === 'constructor') {
              if (this.ctor) {
                assign.error('cannot define more than one constructor in a class');
              }
              if (func.bound) {
                assign.error('cannot define a constructor as a bound function');
              }
              if (func instanceof Code) {
                assign = this.ctor = func;
              } else {
                this.externalCtor = o.classScope.freeVariable('class');
                assign = new Assign(new Literal(this.externalCtor), func);
              }
            } else {
              if (assign.variable["this"]) {
                func["static"] = true;
              } else {
                assign.variable = new Value(new Literal(name), [new Access(new Literal('prototype')), new Access(base)]);
                if (func instanceof Code && func.bound) {
                  this.boundFuncs.push(base);
                  func.bound = false;
                }
              }
            }
          }
          _results.push(assign);
        }
        return _results;
      }).call(this);
      return compact(exprs);
    };

    Class.prototype.walkBody = function(name, o) {
      return this.traverseChildren(false, (function(_this) {
        return function(child) {
          var cont, exps, i, node, _i, _len, _ref2;
          cont = true;
          if (child instanceof Class) {
            return false;
          }
          if (child instanceof Block) {
            _ref2 = exps = child.expressions;
            for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
              node = _ref2[i];
              if (node instanceof Assign && node.variable.looksStatic(name)) {
                node.value["static"] = true;
              } else if (node instanceof Value && node.isObject(true)) {
                cont = false;
                exps[i] = _this.addProperties(node, name, o);
              }
            }
            child.expressions = exps = flatten(exps);
          }
          return cont && !(child instanceof Class);
        };
      })(this));
    };

    Class.prototype.hoistDirectivePrologue = function() {
      var expressions, index, node;
      index = 0;
      expressions = this.body.expressions;
      while ((node = expressions[index]) && (node instanceof Comment || node.isString())) {
        ++index;
      }
      return this.directives = expressions.splice(0, index);
    };

    Class.prototype.ensureConstructor = function(name) {
      if (!this.ctor) {
        this.ctor = new Code;
        if (this.externalCtor) {
          this.ctor.body.push(new Literal("" + this.externalCtor + ".apply(this, arguments)"));
        } else if (this.parent) {
          this.ctor.body.push(new Literal("" + name + ".__super__.constructor.apply(this, arguments)"));
        }
        this.ctor.body.makeReturn();
        this.body.expressions.unshift(this.ctor);
      }
      this.ctor.ctor = this.ctor.name = name;
      this.ctor.klass = null;
      return this.ctor.noReturn = true;
    };

    Class.prototype.compileNode = function(o) {
      var args, argumentsNode, func, jumpNode, klass, lname, name, superClass, _ref2;
      if (jumpNode = this.body.jumps()) {
        jumpNode.error('Class bodies cannot contain pure statements');
      }
      if (argumentsNode = this.body.contains(isLiteralArguments)) {
        argumentsNode.error("Class bodies shouldn't reference arguments");
      }
      name = this.determineName() || '_Class';
      if (name.reserved) {
        name = "_" + name;
      }
      lname = new Literal(name);
      func = new Code([], Block.wrap([this.body]));
      args = [];
      o.classScope = func.makeScope(o.scope);
      this.hoistDirectivePrologue();
      this.setContext(name);
      this.walkBody(name, o);
      this.ensureConstructor(name);
      this.addBoundFunctions(o);
      this.body.spaced = true;
      this.body.expressions.push(lname);
      if (this.parent) {
        superClass = new Literal(o.classScope.freeVariable('super', false));
        this.body.expressions.unshift(new Extends(lname, superClass));
        func.params.push(new Param(superClass));
        args.push(this.parent);
      }
      (_ref2 = this.body.expressions).unshift.apply(_ref2, this.directives);
      klass = new Parens(new Call(func, args));
      if (this.variable) {
        klass = new Assign(this.variable, klass);
      }
      return klass.compileToFragments(o);
    };

    return Class;

  })(Base);

  exports.Assign = Assign = (function(_super) {
    __extends(Assign, _super);

    function Assign(variable, value, context, options) {
      var forbidden, name, _ref2;
      this.variable = variable;
      this.value = value;
      this.context = context;
      Assign.__super__.constructor.call(this);
      this.param = options && options.param;
      this.subpattern = options && options.subpattern;
      forbidden = (_ref2 = (name = this.variable.unwrapAll().value), __indexOf.call(STRICT_PROSCRIBED, _ref2) >= 0);
      if (forbidden && this.context !== 'object') {
        this.variable.error("variable name may not be \"" + name + "\"");
      }
      this.icedlocal = options && options.icedlocal;
    }

    Assign.prototype.children = ['variable', 'value'];

    Assign.prototype.isStatement = function(o) {
      return (o != null ? o.level : void 0) === LEVEL_TOP && (this.context != null) && __indexOf.call(this.context, "?") >= 0;
    };

    Assign.prototype.assigns = function(name) {
      return this[this.context === 'object' ? 'value' : 'variable'].assigns(name);
    };

    Assign.prototype.unfoldSoak = function(o) {
      return unfoldSoak(o, this, 'variable');
    };

    Assign.prototype.compileNode = function(o) {
      var answer, compiledName, isValue, match, name, val, varBase, _ref2, _ref3, _ref4, _ref5;
      this.value.icedStatementAssertion();
      if (isValue = this.variable instanceof Value) {
        if (this.variable.isArray() || this.variable.isObject()) {
          return this.compilePatternMatch(o);
        }
        if (this.variable.isSplice()) {
          return this.compileSplice(o);
        }
        if ((_ref2 = this.context) === '||=' || _ref2 === '&&=' || _ref2 === '?=') {
          return this.compileConditional(o);
        }
        if ((_ref3 = this.context) === '**=' || _ref3 === '//=' || _ref3 === '%%=') {
          return this.compileSpecialMath(o);
        }
      }
      compiledName = this.variable.compileToFragments(o, LEVEL_LIST);
      name = fragmentsToText(compiledName);
      if (!this.context) {
        varBase = this.variable.unwrapAll();
        if (!varBase.isAssignable()) {
          this.variable.error("\"" + (this.variable.compile(o)) + "\" cannot be assigned");
        }
        if (!(typeof varBase.hasProperties === "function" ? varBase.hasProperties() : void 0)) {
          if (this.param || this.icedlocal) {
            o.scope.add(name, 'var', this.icedlocal);
          } else {
            o.scope.find(name);
          }
        }
      }
      if (this.value instanceof Code && (match = METHOD_DEF.exec(name))) {
        if (match[2]) {
          this.value.klass = match[1];
        }
        this.value.name = (_ref4 = (_ref5 = match[3]) != null ? _ref5 : match[4]) != null ? _ref4 : match[5];
      }
      val = this.value.compileToFragments(o, LEVEL_LIST);
      if (this.context === 'object') {
        return compiledName.concat(this.makeCode(": "), val);
      }
      answer = compiledName.concat(this.makeCode(" " + (this.context || '=') + " "), val);
      if (o.level <= LEVEL_LIST) {
        return answer;
      } else {
        return this.wrapInBraces(answer);
      }
    };

    Assign.prototype.compilePatternMatch = function(o) {
      var acc, assigns, code, expandedIdx, fragments, i, idx, isObject, ivar, name, obj, objects, olen, ref, rest, top, val, value, vvar, vvarText, _i, _len, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      top = o.level === LEVEL_TOP;
      value = this.value;
      objects = this.variable.base.objects;
      if (!(olen = objects.length)) {
        code = value.compileToFragments(o);
        if (o.level >= LEVEL_OP) {
          return this.wrapInBraces(code);
        } else {
          return code;
        }
      }
      isObject = this.variable.isObject();
      if (top && olen === 1 && !((obj = objects[0]) instanceof Splat)) {
        if (obj instanceof Assign) {
          _ref2 = obj, (_ref3 = _ref2.variable, idx = _ref3.base), obj = _ref2.value;
        } else {
          idx = isObject ? obj["this"] ? obj.properties[0].name : obj : new Literal(0);
        }
        acc = IDENTIFIER.test(idx.unwrap().value || 0);
        value = new Value(value);
        value.properties.push(new (acc ? Access : Index)(idx));
        if (_ref4 = obj.unwrap().value, __indexOf.call(RESERVED, _ref4) >= 0) {
          obj.error("assignment to a reserved word: " + (obj.compile(o)));
        }
        return new Assign(obj, value, null, {
          param: this.param
        }).compileToFragments(o, LEVEL_TOP);
      }
      vvar = value.compileToFragments(o, LEVEL_LIST);
      vvarText = fragmentsToText(vvar);
      assigns = [];
      expandedIdx = false;
      if (!IDENTIFIER.test(vvarText) || this.variable.assigns(vvarText)) {
        assigns.push([this.makeCode("" + (ref = o.scope.freeVariable('ref')) + " = ")].concat(__slice.call(vvar)));
        vvar = [this.makeCode(ref)];
        vvarText = ref;
      }
      for (i = _i = 0, _len = objects.length; _i < _len; i = ++_i) {
        obj = objects[i];
        idx = i;
        if (isObject) {
          if (obj instanceof Assign) {
            _ref5 = obj, (_ref6 = _ref5.variable, idx = _ref6.base), obj = _ref5.value;
          } else {
            if (obj.base instanceof Parens) {
              _ref7 = new Value(obj.unwrapAll()).cacheReference(o), obj = _ref7[0], idx = _ref7[1];
            } else {
              idx = obj["this"] ? obj.properties[0].name : obj;
            }
          }
        }
        if (!expandedIdx && obj instanceof Splat) {
          name = obj.name.unwrap().value;
          obj = obj.unwrap();
          val = "" + olen + " <= " + vvarText + ".length ? " + (utility('slice')) + ".call(" + vvarText + ", " + i;
          if (rest = olen - i - 1) {
            ivar = o.scope.freeVariable('i');
            val += ", " + ivar + " = " + vvarText + ".length - " + rest + ") : (" + ivar + " = " + i + ", [])";
          } else {
            val += ") : []";
          }
          val = new Literal(val);
          expandedIdx = "" + ivar + "++";
        } else if (!expandedIdx && obj instanceof Expansion) {
          if (rest = olen - i - 1) {
            if (rest === 1) {
              expandedIdx = "" + vvarText + ".length - 1";
            } else {
              ivar = o.scope.freeVariable('i');
              val = new Literal("" + ivar + " = " + vvarText + ".length - " + rest);
              expandedIdx = "" + ivar + "++";
              assigns.push(val.compileToFragments(o, LEVEL_LIST));
            }
          }
          continue;
        } else {
          name = obj.unwrap().value;
          if (obj instanceof Splat || obj instanceof Expansion) {
            obj.error("multiple splats/expansions are disallowed in an assignment");
          }
          if (typeof idx === 'number') {
            idx = new Literal(expandedIdx || idx);
            acc = false;
          } else {
            acc = isObject && IDENTIFIER.test(idx.unwrap().value || 0);
          }
          val = new Value(new Literal(vvarText), [new (acc ? Access : Index)(idx)]);
        }
        if ((name != null) && __indexOf.call(RESERVED, name) >= 0) {
          obj.error("assignment to a reserved word: " + (obj.compile(o)));
        }
        assigns.push(new Assign(obj, val, null, {
          param: this.param,
          subpattern: true
        }).compileToFragments(o, LEVEL_LIST));
      }
      if (!(top || this.subpattern)) {
        assigns.push(vvar);
      }
      fragments = this.joinFragmentArrays(assigns, ', ');
      if (o.level < LEVEL_LIST) {
        return fragments;
      } else {
        return this.wrapInBraces(fragments);
      }
    };

    Assign.prototype.compileConditional = function(o) {
      var fragments, left, right, _ref2;
      _ref2 = this.variable.cacheReference(o), left = _ref2[0], right = _ref2[1];
      if (!left.properties.length && left.base instanceof Literal && left.base.value !== "this" && !o.scope.check(left.base.value)) {
        this.variable.error("the variable \"" + left.base.value + "\" can't be assigned with " + this.context + " because it has not been declared before");
      }
      if (__indexOf.call(this.context, "?") >= 0) {
        o.isExistentialEquals = true;
        return new If(new Existence(left), right, {
          type: 'if'
        }).addElse(new Assign(right, this.value, '=')).compileToFragments(o);
      } else {
        fragments = new Op(this.context.slice(0, -1), left, new Assign(right, this.value, '=')).compileToFragments(o);
        if (o.level <= LEVEL_LIST) {
          return fragments;
        } else {
          return this.wrapInBraces(fragments);
        }
      }
    };

    Assign.prototype.compileSpecialMath = function(o) {
      var left, right, _ref2;
      _ref2 = this.variable.cacheReference(o), left = _ref2[0], right = _ref2[1];
      return new Assign(left, new Op(this.context.slice(0, -1), right, this.value)).compileToFragments(o);
    };

    Assign.prototype.compileSplice = function(o) {
      var answer, exclusive, from, fromDecl, fromRef, name, to, valDef, valRef, _ref2, _ref3, _ref4;
      _ref2 = this.variable.properties.pop().range, from = _ref2.from, to = _ref2.to, exclusive = _ref2.exclusive;
      name = this.variable.compile(o);
      if (from) {
        _ref3 = this.cacheToCodeFragments(from.cache(o, LEVEL_OP)), fromDecl = _ref3[0], fromRef = _ref3[1];
      } else {
        fromDecl = fromRef = '0';
      }
      if (to) {
        if (from instanceof Value && from.isSimpleNumber() && to instanceof Value && to.isSimpleNumber()) {
          to = to.compile(o) - fromRef;
          if (!exclusive) {
            to += 1;
          }
        } else {
          to = to.compile(o, LEVEL_ACCESS) + ' - ' + fromRef;
          if (!exclusive) {
            to += ' + 1';
          }
        }
      } else {
        to = "9e9";
      }
      _ref4 = this.value.cache(o, LEVEL_LIST), valDef = _ref4[0], valRef = _ref4[1];
      answer = [].concat(this.makeCode("[].splice.apply(" + name + ", [" + fromDecl + ", " + to + "].concat("), valDef, this.makeCode(")), "), valRef);
      if (o.level > LEVEL_TOP) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    return Assign;

  })(Base);

  exports.Code = Code = (function(_super) {
    __extends(Code, _super);

    function Code(params, body, tag) {
      Code.__super__.constructor.call(this);
      this.params = params || [];
      this.body = body || new Block;
      this.icedgen = tag === 'icedgen';
      this.icedPassedDeferral = null;
      this.bound = tag === 'boundfunc' || this.icedgen;
      this.isGenerator = this.body.contains(function(node) {
        var _ref2;
        return node instanceof Op && ((_ref2 = node.operator) === 'yield' || _ref2 === 'yield*');
      });
    }

    Code.prototype.children = ['params', 'body'];

    Code.prototype.isStatement = function() {
      return !!this.ctor;
    };

    Code.prototype.jumps = NO;

    Code.prototype.makeScope = function(parentScope) {
      return new Scope(parentScope, this.body, this);
    };

    Code.prototype.compileNode = function(o) {
      var answer, boundfunc, code, exprs, i, lit, p, param, params, ref, splats, uniqs, val, wasEmpty, wrapper, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      if (this.bound && ((_ref2 = o.scope.method) != null ? _ref2.bound : void 0)) {
        this.context = o.scope.method.context;
      }
      if (this.bound && !this.context) {
        this.context = '_this';
        wrapper = new Code([new Param(new Literal(this.context))], new Block([this]));
        boundfunc = new Call(wrapper, [new Literal('this')]);
        boundfunc.updateLocationDataIfMissing(this.locationData);
        return boundfunc.compileNode(o);
      }
      o.scope = del(o, 'classScope') || this.makeScope(o.scope);
      o.scope.shared = del(o, 'sharedScope') || this.icedgen;
      o.scope.icedgen = this.icedgen;
      o.indent += TAB;
      delete o.bare;
      delete o.isExistentialEquals;
      params = [];
      exprs = [];
      _ref3 = this.params;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        param = _ref3[_i];
        if (!(param instanceof Expansion)) {
          o.scope.parameter(param.asReference(o));
        }
      }
      _ref4 = this.params;
      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
        param = _ref4[_j];
        if (!(param.splat || param instanceof Expansion)) {
          continue;
        }
        _ref5 = this.params;
        for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
          p = _ref5[_k].name;
          if (!(!(param instanceof Expansion))) {
            continue;
          }
          if (p["this"]) {
            p = p.properties[0].name;
          }
          if (p.value) {
            o.scope.add(p.value, 'var', true);
          }
        }
        splats = new Assign(new Value(new Arr((function() {
          var _l, _len3, _ref6, _results;
          _ref6 = this.params;
          _results = [];
          for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
            p = _ref6[_l];
            _results.push(p.asReference(o));
          }
          return _results;
        }).call(this))), new Value(new Literal('arguments')));
        break;
      }
      _ref6 = this.params;
      for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
        param = _ref6[_l];
        if (param.isComplex()) {
          val = ref = param.asReference(o);
          if (param.value) {
            val = new Op('?', ref, param.value);
          }
          exprs.push(new Assign(new Value(param.name), val, '=', {
            param: true
          }));
        } else {
          ref = param;
          if (param.value) {
            lit = new Literal(ref.name.value + ' == null');
            val = new Assign(new Value(param.name), param.value, '=');
            exprs.push(new If(lit, val));
          }
        }
        if (!splats) {
          params.push(ref);
        }
      }
      wasEmpty = this.body.isEmpty();
      if (splats) {
        exprs.unshift(splats);
      }
      if (exprs.length) {
        (_ref7 = this.body.expressions).unshift.apply(_ref7, exprs);
      }
      for (i = _m = 0, _len4 = params.length; _m < _len4; i = ++_m) {
        p = params[i];
        params[i] = p.compileToFragments(o);
        o.scope.parameter(fragmentsToText(params[i]));
      }
      uniqs = [];
      this.eachParamName(function(name, node) {
        if (__indexOf.call(uniqs, name) >= 0) {
          node.error("multiple parameters named '" + name + "'");
        }
        return uniqs.push(name);
      });
      if (this.icedHasAutocbFlag) {
        wasEmpty = false;
      }
      if (!(wasEmpty || this.noReturn)) {
        this.body.makeReturn();
      }
      code = 'function';
      if (this.isGenerator) {
        code += '*';
      }
      if (this.ctor) {
        code += ' ' + this.name;
      }
      code += '(';
      answer = [this.makeCode(code)];
      for (i = _n = 0, _len5 = params.length; _n < _len5; i = ++_n) {
        p = params[i];
        if (i) {
          answer.push(this.makeCode(", "));
        }
        answer.push.apply(answer, p);
      }
      answer.push(this.makeCode(') {'));
      this.icedPatchBody(o);
      if (!this.body.isEmpty()) {
        answer = answer.concat(this.makeCode("\n"), this.body.compileWithDeclarations(o), this.makeCode("\n" + this.tab));
      }
      answer.push(this.makeCode('}'));
      if (this.ctor) {
        return [this.makeCode(this.tab)].concat(__slice.call(answer));
      }
      if (this.front || (o.level >= LEVEL_ACCESS)) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    Code.prototype.eachParamName = function(iterator) {
      var param, _i, _len, _ref2, _results;
      _ref2 = this.params;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        param = _ref2[_i];
        _results.push(param.eachName(iterator));
      }
      return _results;
    };

    Code.prototype.traverseChildren = function(crossScope, func) {
      if (crossScope) {
        return Code.__super__.traverseChildren.call(this, crossScope, func);
      }
    };

    Code.prototype.icedPatchBody = function(o) {
      var f, lhs, r, rhs;
      if (this.icedFoundArguments && this.icedNodeFlag) {
        o.scope.assign('_arguments', 'arguments');
      }
      if (this.icedNodeFlag && !this.icedgen) {
        this.icedPassedDeferral = o.scope.freeVariable(iced["const"].passed_deferral);
        lhs = new Value(new Literal(this.icedPassedDeferral));
        f = new Value(new Literal(iced["const"].ns));
        f.add(new Access(new Value(new Literal(iced["const"].findDeferral))));
        rhs = new Call(f, [new Value(new Literal('arguments'))]);
        this.body.unshift(new Assign(lhs, rhs));
      }
      if (this.icedNodeFlag && !this.icedgen) {
        r = this.icedHasAutocbFlag ? iced["const"].autocb : iced["const"].k_noop;
        rhs = new Value(new Literal(r));
        lhs = new Value(new Literal(iced["const"].k));
        return this.body.unshift(new Assign(lhs, rhs, null, {
          icedlocal: true
        }));
      }
    };

    Code.prototype.icedWalkAst = function(parent, o) {
      var cf_prev, fa_prev, faf_prev, fg_prev, param, _i, _len, _ref2;
      this.icedParentAwait = parent;
      fa_prev = o.foundAutocb;
      cf_prev = o.currFunc;
      fg_prev = o.foundArguments;
      faf_prev = o.foundAwaitFunc;
      o.foundAutocb = false;
      o.foundArguments = false;
      o.foundAwaitFunc = false;
      o.currFunc = this;
      _ref2 = this.params;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        param = _ref2[_i];
        if (param.name instanceof Literal && param.name.value === iced["const"].autocb) {
          o.foundAutocb = true;
          break;
        }
      }
      this.icedHasAutocbFlag = o.foundAutocb;
      Code.__super__.icedWalkAst.call(this, parent, o);
      this.icedFoundArguments = o.foundArguments;
      o.foundAwaitFunc = faf_prev;
      o.foundArguments = fg_prev;
      o.foundAutocb = fa_prev;
      o.currFunc = cf_prev;
      return false;
    };

    Code.prototype.icedWalkAstLoops = function(flood) {
      if (Code.__super__.icedWalkAstLoops.call(this, false)) {
        this.icedLoopFlag = true;
      }
      return false;
    };

    Code.prototype.icedWalkCpsPivots = function() {
      Code.__super__.icedWalkCpsPivots.call(this);
      return this.icedCpsPivotFlag = false;
    };

    Code.prototype.icedTraceName = function() {
      var parts;
      parts = [];
      if (this.klass) {
        parts.push(this.klass);
      }
      if (this.name) {
        parts.push(this.name);
      }
      return parts.join('.');
    };

    return Code;

  })(Base);

  exports.Param = Param = (function(_super) {
    __extends(Param, _super);

    function Param(name, value, splat) {
      var _ref2;
      this.name = name;
      this.value = value;
      this.splat = splat;
      Param.__super__.constructor.call(this);
      if (_ref2 = (name = this.name.unwrapAll().value), __indexOf.call(STRICT_PROSCRIBED, _ref2) >= 0) {
        this.name.error("parameter name \"" + name + "\" is not allowed");
      }
    }

    Param.prototype.children = ['name', 'value'];

    Param.prototype.compileToFragments = function(o) {
      return this.name.compileToFragments(o, LEVEL_LIST);
    };

    Param.prototype.asReference = function(o) {
      var node;
      if (this.reference) {
        return this.reference;
      }
      node = this.name;
      if (node["this"]) {
        node = node.properties[0].name;
        if (node.value.reserved) {
          node = new Literal(o.scope.freeVariable(node.value));
        }
      } else if (node.isComplex()) {
        node = new Literal(o.scope.freeVariable('arg'));
      }
      node = new Value(node);
      if (this.splat) {
        node = new Splat(node);
      }
      node.updateLocationDataIfMissing(this.locationData);
      return this.reference = node;
    };

    Param.prototype.isComplex = function() {
      return this.name.isComplex();
    };

    Param.prototype.eachName = function(iterator, name) {
      var atParam, node, obj, _i, _len, _ref2;
      if (name == null) {
        name = this.name;
      }
      atParam = function(obj) {
        var node;
        node = obj.properties[0].name;
        if (!node.value.reserved) {
          return iterator(node.value, node);
        }
      };
      if (name instanceof Literal) {
        return iterator(name.value, name);
      }
      if (name instanceof Value) {
        return atParam(name);
      }
      _ref2 = name.objects;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        obj = _ref2[_i];
        if (obj instanceof Assign) {
          this.eachName(iterator, obj.value.unwrap());
        } else if (obj instanceof Splat) {
          node = obj.name.unwrap();
          iterator(node.value, node);
        } else if (obj instanceof Value) {
          if (obj.isArray() || obj.isObject()) {
            this.eachName(iterator, obj.base);
          } else if (obj["this"]) {
            atParam(obj);
          } else {
            iterator(obj.base.value, obj.base);
          }
        } else if (!(obj instanceof Expansion)) {
          obj.error("illegal parameter " + (obj.compile()));
        }
      }
    };

    return Param;

  })(Base);

  exports.Splat = Splat = (function(_super) {
    __extends(Splat, _super);

    Splat.prototype.children = ['name'];

    Splat.prototype.isAssignable = YES;

    function Splat(name) {
      Splat.__super__.constructor.call(this);
      this.name = name.compile ? name : new Literal(name);
    }

    Splat.prototype.assigns = function(name) {
      return this.name.assigns(name);
    };

    Splat.prototype.compileToFragments = function(o) {
      return this.name.compileToFragments(o);
    };

    Splat.prototype.unwrap = function() {
      return this.name;
    };

    Splat.compileSplattedArray = function(o, list, apply) {
      var args, base, compiledNode, concatPart, fragments, i, index, node, _i, _len;
      index = -1;
      while ((node = list[++index]) && !(node instanceof Splat)) {
        continue;
      }
      if (index >= list.length) {
        return [];
      }
      if (list.length === 1) {
        node = list[0];
        fragments = node.compileToFragments(o, LEVEL_LIST);
        if (apply) {
          return fragments;
        }
        return [].concat(node.makeCode("" + (utility('slice')) + ".call("), fragments, node.makeCode(")"));
      }
      args = list.slice(index);
      for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
        node = args[i];
        compiledNode = node.compileToFragments(o, LEVEL_LIST);
        args[i] = node instanceof Splat ? [].concat(node.makeCode("" + (utility('slice')) + ".call("), compiledNode, node.makeCode(")")) : [].concat(node.makeCode("["), compiledNode, node.makeCode("]"));
      }
      if (index === 0) {
        node = list[0];
        concatPart = node.joinFragmentArrays(args.slice(1), ', ');
        return args[0].concat(node.makeCode(".concat("), concatPart, node.makeCode(")"));
      }
      base = (function() {
        var _j, _len1, _ref2, _results;
        _ref2 = list.slice(0, index);
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          node = _ref2[_j];
          _results.push(node.compileToFragments(o, LEVEL_LIST));
        }
        return _results;
      })();
      base = list[0].joinFragmentArrays(base, ', ');
      concatPart = list[index].joinFragmentArrays(args, ', ');
      return [].concat(list[0].makeCode("["), base, list[index].makeCode("].concat("), concatPart, (last(list)).makeCode(")"));
    };

    Splat.prototype.icedToSlot = function(i) {
      return new Slot(i, new Value(this.name), null, true);
    };

    return Splat;

  })(Base);

  exports.Expansion = Expansion = (function(_super) {
    __extends(Expansion, _super);

    function Expansion() {
      return Expansion.__super__.constructor.apply(this, arguments);
    }

    Expansion.prototype.isComplex = NO;

    Expansion.prototype.compileNode = function(o) {
      return this.error('Expansion must be used inside a destructuring assignment or parameter list');
    };

    Expansion.prototype.asReference = function(o) {
      return this;
    };

    Expansion.prototype.eachName = function(iterator) {};

    return Expansion;

  })(Base);

  exports.While = While = (function(_super) {
    __extends(While, _super);

    function While(condition, options) {
      this.condition = (options != null ? options.invert : void 0) ? condition.invert() : condition;
      this.guard = options != null ? options.guard : void 0;
    }

    While.prototype.children = ['condition', 'guard', 'body'];

    While.prototype.isStatement = YES;

    While.prototype.isLoop = YES;

    While.prototype.makeReturn = function(res) {
      if (res) {
        return While.__super__.makeReturn.apply(this, arguments);
      } else {
        this.returns = !this.jumps({
          loop: true
        });
        return this;
      }
    };

    While.prototype.addBody = function(body) {
      this.body = body;
      return this;
    };

    While.prototype.jumps = function() {
      var expressions, jumpNode, node, _i, _len;
      expressions = this.body.expressions;
      if (!expressions.length) {
        return false;
      }
      for (_i = 0, _len = expressions.length; _i < _len; _i++) {
        node = expressions[_i];
        if (jumpNode = node.jumps({
          loop: true
        })) {
          return jumpNode;
        }
      }
      return false;
    };

    While.prototype.compileNode = function(o) {
      var answer, body, rvar, set;
      this.condition.icedStatementAssertion();
      if (this.icedNodeFlag) {
        return this.icedCompileIced(o);
      }
      o.indent += TAB;
      set = '';
      body = this.body;
      if (body.isEmpty()) {
        body = this.makeCode('');
      } else {
        if (this.returns) {
          body.makeReturn(rvar = o.scope.freeVariable('results'));
          set = "" + this.tab + rvar + " = [];\n";
        }
        if (this.guard) {
          if (body.expressions.length > 1) {
            body.expressions.unshift(new If((new Parens(this.guard)).invert(), new Literal("continue")));
          } else {
            if (this.guard) {
              body = Block.wrap([new If(this.guard, body)]);
            }
          }
        }
        body = [].concat(this.makeCode("\n"), body.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab));
      }
      answer = [].concat(this.makeCode(set + this.tab + "while ("), this.condition.compileToFragments(o, LEVEL_PAREN), this.makeCode(") {"), body, this.makeCode("}"));
      if (this.returns) {
        if (this.icedHasAutocbFlag) {
          answer.push(this.makeCode("\n" + this.tab + iced["const"].autocb + "(" + rvar + ");"));
          answer.push(this.makeCode("\n" + this.tab + "return;"));
        } else {
          answer.push(this.makeCode("\n" + this.tab + "return " + rvar + ";"));
        }
      }
      return answer;
    };

    While.prototype.icedWrap = function(d) {
      var body, break_assign, break_block, break_body, break_expr, break_id, call1, call2, cond, condition, continue_assign, continue_block, continue_block_inner, continue_body, continue_fn, continue_id, f, guard_if, k_id, k_param, next_arg, next_assign, next_block, next_body, next_id, outStatements, rvar, rvar_init, rvar_value, top_assign, top_block, top_body, top_call, top_func, top_id, top_statements, tramp;
      condition = d.condition;
      body = d.body;
      rvar = d.rvar;
      outStatements = [];
      if (rvar) {
        rvar_value = new Value(new Literal(rvar));
      }
      top_id = new Value(new Literal(iced["const"].t_while));
      k_id = new Value(new Literal(iced["const"].k));
      k_param = new Param(new Literal(iced["const"].k));
      break_id = new Value(new Literal(iced["const"].b_while));
      if (rvar) {
        break_expr = new Call(k_id, [rvar_value]);
        break_block = new Block([break_expr]);
        break_body = new Code([], break_block, 'icedgen');
        break_assign = new Assign(break_id, break_body, null, {
          icedlocal: true
        });
      } else {
        break_assign = new Assign(break_id, k_id, null, {
          icedlocal: true
        });
      }
      continue_id = new Value(new Literal(iced["const"].c_while));
      continue_block_inner = new Block([new Call(top_id, [k_id])]);
      if (d.step) {
        continue_block_inner.unshift(d.step);
      }
      continue_fn = new Code([], continue_block_inner);
      tramp = new Value(new Literal(iced["const"].ns));
      tramp.add(new Access(new Value(new Literal(iced["const"].trampoline))));
      continue_block = new Block([new Call(tramp, [continue_fn])]);
      continue_body = new Code([], continue_block, 'icedgen');
      continue_assign = new Assign(continue_id, continue_body, null, {
        icedlocal: true
      });
      next_id = new Value(new Literal(iced["const"].n_while));
      if (rvar) {
        next_arg = new Param(new Literal(iced["const"].n_arg));
        f = rvar_value.copy();
        f.add(new Access(new Value(new Literal('push'))));
        call1 = new Call(f, [next_arg]);
        call2 = new Call(continue_id, []);
        next_block = new Block([call1, call2]);
        next_body = new Code([next_arg], next_block, 'icedgen');
        next_assign = new Assign(next_id, next_body, null, {
          icedlocal: true
        });
      } else {
        next_assign = new Assign(next_id, continue_id);
      }
      cond = new If(condition.invert(), new Block([new Call(break_id, [])]));
      if (d.guard) {
        continue_block = new Block([new Call(continue_id, [])]);
        guard_if = new If(d.guard, body);
        guard_if.addElse(continue_block);
        cond.addElse(new Block([d.pre_body, guard_if]));
      } else {
        cond.addElse(new Block([d.pre_body, body]));
      }
      top_body = new Block([break_assign, continue_assign, next_assign, cond]);
      top_func = new Code([k_param], top_body, 'icedgen');
      top_assign = new Assign(top_id, top_func, null, {
        icedlocal: true
      });
      top_call = new Call(top_id, [k_id]);
      top_statements = [];
      if (d.init) {
        top_statements = top_statements.concat(d.init);
      }
      if (rvar) {
        rvar_init = new Assign(rvar_value, new Arr);
        top_statements.push(rvar_init);
      }
      top_statements = top_statements.concat([top_assign, top_call]);
      return top_block = new Block(top_statements);
    };

    While.prototype.icedCallContinuation = function() {
      return this.body.icedThreadReturn(new IcedTailCall(iced["const"].n_while));
    };

    While.prototype.icedCompileIced = function(o) {
      var b, opts;
      opts = {
        condition: this.condition,
        body: this.body,
        guard: this.guard
      };
      if (this.returns) {
        opts.rvar = o.scope.freeVariable('results');
      }
      b = this.icedWrap(opts);
      return b.compileNode(o);
    };

    return While;

  })(Base);

  exports.Op = Op = (function(_super) {
    var CONVERSIONS, INVERSIONS;

    __extends(Op, _super);

    function Op(op, first, second, flip) {
      Op.__super__.constructor.call(this);
      if (op === 'in') {
        return new In(first, second);
      }
      if (op === 'do') {
        return this.generateDo(first);
      }
      if (op === 'new') {
        if (first instanceof Call && !first["do"] && !first.isNew) {
          return first.newInstance();
        }
        if (first instanceof Code && first.bound || first["do"]) {
          first = new Parens(first);
        }
      }
      this.operator = CONVERSIONS[op] || op;
      this.first = first;
      this.second = second;
      this.flip = !!flip;
      return this;
    }

    CONVERSIONS = {
      '==': '===',
      '!=': '!==',
      'of': 'in',
      'yieldfrom': 'yield*'
    };

    INVERSIONS = {
      '!==': '===',
      '===': '!=='
    };

    Op.prototype.children = ['first', 'second'];

    Op.prototype.isSimpleNumber = NO;

    Op.prototype.isYield = function() {
      var _ref2;
      return (_ref2 = this.operator) === 'yield' || _ref2 === 'yield*';
    };

    Op.prototype.isUnary = function() {
      return !this.second;
    };

    Op.prototype.isComplex = function() {
      var _ref2;
      return !(this.isUnary() && ((_ref2 = this.operator) === '+' || _ref2 === '-')) || this.first.isComplex();
    };

    Op.prototype.isChainable = function() {
      var _ref2;
      return (_ref2 = this.operator) === '<' || _ref2 === '>' || _ref2 === '>=' || _ref2 === '<=' || _ref2 === '===' || _ref2 === '!==';
    };

    Op.prototype.invert = function() {
      var allInvertable, curr, fst, op, _ref2;
      if (this.isChainable() && this.first.isChainable()) {
        allInvertable = true;
        curr = this;
        while (curr && curr.operator) {
          allInvertable && (allInvertable = curr.operator in INVERSIONS);
          curr = curr.first;
        }
        if (!allInvertable) {
          return new Parens(this).invert();
        }
        curr = this;
        while (curr && curr.operator) {
          curr.invert = !curr.invert;
          curr.operator = INVERSIONS[curr.operator];
          curr = curr.first;
        }
        return this;
      } else if (op = INVERSIONS[this.operator]) {
        this.operator = op;
        if (this.first.unwrap() instanceof Op) {
          this.first.invert();
        }
        return this;
      } else if (this.second) {
        return new Parens(this).invert();
      } else if (this.operator === '!' && (fst = this.first.unwrap()) instanceof Op && ((_ref2 = fst.operator) === '!' || _ref2 === 'in' || _ref2 === 'instanceof')) {
        return fst;
      } else {
        return new Op('!', this);
      }
    };

    Op.prototype.unfoldSoak = function(o) {
      var _ref2;
      return ((_ref2 = this.operator) === '++' || _ref2 === '--' || _ref2 === 'delete') && unfoldSoak(o, this, 'first');
    };

    Op.prototype.generateDo = function(exp) {
      var call, func, param, passedParams, ref, _i, _len, _ref2;
      passedParams = [];
      func = exp instanceof Assign && (ref = exp.value.unwrap()) instanceof Code ? ref : exp;
      _ref2 = func.params || [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        param = _ref2[_i];
        if (param.value) {
          passedParams.push(param.value);
          delete param.value;
        } else {
          passedParams.push(param);
        }
      }
      call = new Call(exp, passedParams);
      call["do"] = true;
      return call;
    };

    Op.prototype.compileSchemeWrapperArithmetic = function(o, wrapperName, name, schemeFn, makejs) {
      var wfn;
      wfn = new Value(new Literal(schemeNumberFunctionWrapper(wrapperName, name, schemeFn, makejs)));
      return new Call(wfn, [this.first, this.second]).compileNode(o);
    };

    Op.prototype.compileSchemeArithmetic = function(o, name, schemeFn) {
      var sfn;
      sfn = new Value(new Literal(schemeNumberFunction(name, schemeFn)));
      return new Call(sfn, [this.first, this.second]).compileNode(o);
    };

    Op.prototype.compileNode = function(o) {
      var answer, isChain, isNumber, lhs, relation, relationName, rhs, schemeNumber, schemeOp, sfn, _ref2, _ref3;
      isChain = this.isChainable() && this.first.isChainable();
      if (!isChain) {
        this.first.front = this.front;
      }
      if (this.operator === 'delete' && o.scope.check(this.first.unwrapAll().value)) {
        this.error('delete operand may not be argument or var');
      }
      if (((_ref2 = this.operator) === '--' || _ref2 === '++') && (_ref3 = this.first.unwrapAll().value, __indexOf.call(STRICT_PROSCRIBED, _ref3) >= 0)) {
        this.error("cannot increment/decrement \"" + (this.first.unwrapAll().value) + "\"");
      }
      if (this.isYield()) {
        return this.compileYield(o);
      }
      if (this.isUnary()) {
        if (o.numeric) {
          switch (this.operator) {
            case '+':
              sfn = new Value(new Literal(utility('SchemeNumber')));
              return new Call(sfn, [this.first]).compileNode(o);
            case '-':
              sfn = new Value(new Literal(schemeNumberFunction('neg', '-')));
              return new Call(sfn, [this.first]).compileNode(o);
          }
        }
        return this.compileUnary(o);
      }
      if (isChain) {
        return this.compileChain(o);
      }
      if (o.numeric) {
        switch (this.operator) {
          case '+':
            schemeNumber = utility('SchemeNumber');
            return this.compileSchemeWrapperArithmetic(o, 'add', 'add', '+', function(schemeAdd) {
              return "function (a, b) {\n  if (typeof a === 'string') {\n    return a + (typeof b === 'string' ? b : " + schemeNumber + "(b).toString());\n  } else if (typeof b === 'string') {\n    return " + schemeNumber + "(a).toString() + b;\n  }\n  return " + schemeAdd + "(a, b);\n}";
            });
          case '===':
            if (!(this.first.isString() || this.second.isString())) {
              isNumber = schemeNumberFunction('isn', 'number?');
              return this.compileSchemeWrapperArithmetic(o, 'eql', 'eql', '=', function(schemeEql) {
                return "function (a, b) {\n  if ((" + isNumber + "(a) or typeof a === 'number') and\n      (" + isNumber + "(b) or typeof b === 'number')) {\n    return " + schemeEql + "(a, b);\n  }\n  return a === b;\n}";
              });
            }
            break;
          case '!==':
            if (!(this.first.isString() || this.second.isString())) {
              isNumber = schemeNumberFunction('isn', 'number?');
              return this.compileSchemeWrapperArithmetic(o, 'neq', 'eql', '=', function(schemeEql) {
                return "function (a, b) {\n  if ((" + isNumber + "(a) or typeof a === 'number') and\n      (" + isNumber + "(b) or typeof b === 'number')) {\n    return !" + schemeEql + "(a, b);\n  }\n  return a !== b;\n}";
              });
            }
        }
        relationName = {
          '<': 'lt',
          '<=': 'le',
          '>': 'gt',
          '>=': 'ge'
        }[this.operator];
        if (relationName) {
          if (this.first.isNumber() || this.second.isNumber()) {
            return this.compileSchemeArithmetic(o, relationName, this.operator);
          }
          relation = this.operator;
          return this.compileSchemeWrapperArithmetic(o, relationName, relationName, relation, function(schemeRelation) {
            return "function (a, b) {\n  if (typeof a === 'string' and typeof b === 'string') {\n    return a " + relation + " b;\n  }\n  return " + schemeRelation + "(a, b);\n}";
          });
        }
        schemeOp = {
          '/': ['div'],
          '*': ['mul'],
          '-': ['sub'],
          '**': ['expt', 'expt'],
          '//': ['floordiv', 'div'],
          '%': ['modTruncate', 'mod0'],
          '%%': ['mod', 'mod']
        }[this.operator];
        if (schemeOp) {
          return this.compileSchemeArithmetic(o, schemeOp[0], schemeOp[1] || this.operator);
        }
      }
      switch (this.operator) {
        case '?':
          return this.compileExistence(o);
        case '**':
          return this.compilePower(o);
        case '//':
          return this.compileFloorDivision(o);
        case '%%':
          return this.compileModulo(o);
        default:
          lhs = this.first.compileToFragments(o, LEVEL_OP);
          rhs = this.second.compileToFragments(o, LEVEL_OP);
          answer = [].concat(lhs, this.makeCode(" " + this.operator + " "), rhs);
          if (o.level <= LEVEL_OP) {
            return answer;
          } else {
            return this.wrapInBraces(answer);
          }
      }
    };

    Op.prototype.compileChain = function(o) {
      var chainFirst, shared, _ref2;
      chainFirst = this.first;
      _ref2 = chainFirst.second.cache(o), chainFirst.second = _ref2[0], shared = _ref2[1];
      this.first = new Value(shared);
      return (new Op((this.invert ? '&&' : '||'), chainFirst, this)).compileNode(o);
    };

    Op.prototype.compileExistence = function(o) {
      var fst, ref;
      if (this.first.isComplex()) {
        ref = new Literal(o.scope.freeVariable('ref'));
        fst = new Parens(new Assign(ref, this.first));
      } else {
        fst = this.first;
        ref = fst;
      }
      return new If(new Existence(fst), ref, {
        type: 'if'
      }).addElse(this.second).compileToFragments(o);
    };

    Op.prototype.compileUnary = function(o) {
      var op, parts, plusMinus;
      parts = [];
      op = this.operator;
      parts.push([this.makeCode(op)]);
      if (op === '!' && this.first instanceof Existence) {
        this.first.negated = !this.first.negated;
        return this.first.compileToFragments(o);
      }
      if (o.level >= LEVEL_ACCESS) {
        return (new Parens(this)).compileToFragments(o);
      }
      plusMinus = op === '+' || op === '-';
      if ((op === 'new' || op === 'typeof' || op === 'delete') || plusMinus && this.first instanceof Op && this.first.operator === op) {
        parts.push([this.makeCode(' ')]);
      }
      if ((plusMinus && this.first instanceof Op) || (op === 'new' && this.first.isStatement(o))) {
        this.first = new Parens(this.first);
      }
      parts.push(this.first.compileToFragments(o, LEVEL_OP));
      if (this.flip) {
        parts.reverse();
      }
      return this.joinFragmentArrays(parts, '');
    };

    Op.prototype.compileYield = function(o) {
      var op, parts;
      parts = [];
      op = this.operator;
      if (o.scope.parent == null) {
        this.error('yield statements must occur within a function generator.');
      }
      if (__indexOf.call(Object.keys(this.first), 'expression') >= 0) {
        if (this.first.expression != null) {
          parts.push(this.first.expression.compileToFragments(o, LEVEL_OP));
        }
      } else {
        parts.push([this.makeCode("(" + op + " ")]);
        parts.push(this.first.compileToFragments(o, LEVEL_OP));
        parts.push([this.makeCode(")")]);
      }
      return this.joinFragmentArrays(parts, '');
    };

    Op.prototype.compilePower = function(o) {
      var pow;
      pow = new Value(new Literal('Math'), [new Access(new Literal('pow'))]);
      return new Call(pow, [this.first, this.second]).compileToFragments(o);
    };

    Op.prototype.compileFloorDivision = function(o) {
      var div, floor;
      floor = new Value(new Literal('Math'), [new Access(new Literal('floor'))]);
      div = new Op('/', this.first, this.second);
      return new Call(floor, [div]).compileToFragments(o);
    };

    Op.prototype.compileModulo = function(o) {
      var mod;
      mod = new Value(new Literal(utility('modulo')));
      return new Call(mod, [this.first, this.second]).compileToFragments(o);
    };

    Op.prototype.toString = function(idt) {
      return Op.__super__.toString.call(this, idt, this.constructor.name + ' ' + this.operator);
    };

    Op.prototype.icedWrapContinuation = function() {
      return this.icedCallContinuationFlag;
    };

    return Op;

  })(Base);

  exports.In = In = (function(_super) {
    __extends(In, _super);

    function In(object, array) {
      this.object = object;
      this.array = array;
      In.__super__.constructor.call(this);
    }

    In.prototype.children = ['object', 'array'];

    In.prototype.invert = NEGATE;

    In.prototype.compileNode = function(o) {
      var hasSplat, obj, _i, _len, _ref2;
      if (this.array instanceof Value && this.array.isArray() && this.array.base.objects.length) {
        _ref2 = this.array.base.objects;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          obj = _ref2[_i];
          if (!(obj instanceof Splat)) {
            continue;
          }
          hasSplat = true;
          break;
        }
        if (!hasSplat) {
          return this.compileOrTest(o);
        }
      }
      return this.compileLoopTest(o);
    };

    In.prototype.compileOrTest = function(o) {
      var cmp, cnj, i, item, ref, sub, tests, _i, _len, _ref2, _ref3, _ref4;
      _ref2 = this.object.cache(o, LEVEL_OP), sub = _ref2[0], ref = _ref2[1];
      _ref3 = this.negated ? [' !== ', ' && '] : [' === ', ' || '], cmp = _ref3[0], cnj = _ref3[1];
      tests = [];
      _ref4 = this.array.base.objects;
      for (i = _i = 0, _len = _ref4.length; _i < _len; i = ++_i) {
        item = _ref4[i];
        if (i) {
          tests.push(this.makeCode(cnj));
        }
        tests = tests.concat((i ? ref : sub), this.makeCode(cmp), item.compileToFragments(o, LEVEL_ACCESS));
      }
      if (o.level < LEVEL_OP) {
        return tests;
      } else {
        return this.wrapInBraces(tests);
      }
    };

    In.prototype.compileLoopTest = function(o) {
      var fragments, ref, sub, _ref2;
      _ref2 = this.object.cache(o, LEVEL_LIST), sub = _ref2[0], ref = _ref2[1];
      fragments = [].concat(this.makeCode(utility('indexOf') + ".call("), this.array.compileToFragments(o, LEVEL_LIST), this.makeCode(", "), ref, this.makeCode(") " + (this.negated ? '< 0' : '>= 0')));
      if (fragmentsToText(sub) === fragmentsToText(ref)) {
        return fragments;
      }
      fragments = sub.concat(this.makeCode(', '), fragments);
      if (o.level < LEVEL_LIST) {
        return fragments;
      } else {
        return this.wrapInBraces(fragments);
      }
    };

    In.prototype.toString = function(idt) {
      return In.__super__.toString.call(this, idt, this.constructor.name + (this.negated ? '!' : ''));
    };

    return In;

  })(Base);

  exports.Slot = Slot = (function(_super) {
    __extends(Slot, _super);

    function Slot(index, value, suffix, splat) {
      Slot.__super__.constructor.call(this);
      this.index = index;
      this.value = value;
      this.suffix = suffix;
      this.splat = splat;
      this.access = null;
    }

    Slot.prototype.addAccess = function(a) {
      this.access = a;
      return this;
    };

    Slot.prototype.children = ['value', 'suffix'];

    return Slot;

  })(Base);

  exports.Defer = Defer = (function(_super) {
    __extends(Defer, _super);

    function Defer(args, lineno) {
      var a, i;
      this.lineno = lineno;
      Defer.__super__.constructor.call(this);
      this.slots = flatten((function() {
        var _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
          a = args[i];
          _results.push(a.icedToSlot(i));
        }
        return _results;
      })());
      this.params = [];
      this.vars = [];
      this.custom = false;
    }

    Defer.prototype.children = ['slots'];

    Defer.prototype.setCustom = function() {
      this.custom = true;
      return this;
    };

    Defer.prototype.newParam = function() {
      var l;
      l = "" + iced["const"].slot + "_" + (this.params.length + 1);
      this.params.push(new Param(new Literal(l)));
      return new Value(new Literal(l));
    };

    Defer.prototype.makeAssignFn = function(o) {
      var a, args, assign, assignments, block, call, func, i, i_lit, inner_fn, lit, outer_block, outer_fn, prop, s, slot, _i, _len, _ref2;
      if (this.slots.length === 0) {
        return null;
      }
      assignments = [];
      args = [];
      i = 0;
      _ref2 = this.slots;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        s = _ref2[_i];
        i = s.index;
        a = new Value(new Literal("arguments"));
        i_lit = new Value(new Literal(i));
        if (s.splat) {
          func = new Value(new Literal(utility('slice')));
          func.add(new Access(new Value(new Literal('call'))));
          call = new Call(func, [a, i_lit]);
          slot = s.value;
          this.vars.push(slot);
          assign = new Assign(slot, call);
        } else {
          a.add(new Index(i_lit));
          if (s.access) {
            a.add(s.access);
          }
          if (!s.suffix) {
            lit = s.value.compile(o, LEVEL_TOP);
            if (lit === "_") {
              slot = new Value(new Literal(iced["const"].deferrals));
              slot.add(new Access(new Value(new Literal(iced["const"].retslot))));
            } else {
              slot = s.value;
              this.vars.push(slot);
            }
          } else {
            args.push(s.value);
            slot = this.newParam();
            if (s.suffix instanceof Index) {
              prop = new Index(this.newParam());
              args.push(s.suffix.index);
            } else {
              prop = s.suffix;
            }
            slot.add(prop);
          }
          assign = new Assign(slot, a);
        }
        assignments.push(assign);
      }
      block = new Block(assignments);
      inner_fn = new Code([], block, 'icedgen');
      outer_block = new Block([new Return(inner_fn)]);
      outer_fn = new Code(this.params, outer_block, 'icedgen');
      return call = new Call(outer_fn, args);
    };

    Defer.prototype.transform = function(o) {
      var assign_fn, assignments, context_assign, context_lhs, context_rhs, fn, ln_assign, ln_lhs, ln_rhs, meth;
      meth = new Value(new Literal(iced["const"].defer_method));
      if (this.custom) {
        fn = meth;
      } else {
        fn = new Value(new Literal(iced["const"].deferrals));
        fn.add(new Access(meth));
      }
      assignments = [];
      if ((assign_fn = this.makeAssignFn(o))) {
        assignments.push(new Assign(new Value(new Literal(iced["const"].assign_fn)), assign_fn, "object"));
      }
      ln_lhs = new Value(new Literal(iced["const"].lineno));
      ln_rhs = new Value(new Literal(this.lineno));
      ln_assign = new Assign(ln_lhs, ln_rhs, "object");
      assignments.push(ln_assign);
      if (this.custom) {
        context_lhs = new Value(new Literal(iced["const"].context));
        context_rhs = new Value(new Literal(iced["const"].deferrals));
        context_assign = new Assign(context_lhs, context_rhs, "object");
        assignments.push(context_assign);
      }
      o = new Obj(assignments);
      return new Call(fn, [new Value(o)]);
    };

    Defer.prototype.compileNode = function(o) {
      var call, name, scope, v, _i, _len, _ref2;
      call = this.transform(o);
      _ref2 = this.vars;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        v = _ref2[_i];
        name = v.compile(o, LEVEL_LIST);
        scope = o.scope;
        scope.add(name, 'var');
      }
      return call.compileNode(o);
    };

    Defer.prototype.icedWalkAst = function(p, o) {
      this.icedHasAutocbFlag = o.foundAutocb;
      o.foundDefer = true;
      this.parentFunc = o.currFunc;
      return Defer.__super__.icedWalkAst.call(this, p, o);
    };

    return Defer;

  })(Base);

  quote_path_for_emission = function(n) {
    return '"' + n.replace(/\\/g, '\\\\') + '"';
  };

  require_top_dir = function() {
    return quote_path_for_emission(pathmod.join(__dirname, "..", ".."));
  };

  exports.Await = Await = (function(_super) {
    __extends(Await, _super);

    function Await(body) {
      this.body = body;
      Await.__super__.constructor.call(this);
    }

    Await.prototype.transform = function(o) {
      var assign, assignments, body, call, cb_assignment, cb_lhs, cb_rhs, cls, fn_assignment, fn_lhs, fn_rhs, func_assignment, func_lhs, func_rhs, lhs, meth, n, name, rhs, trace, _ref2, _ref3;
      body = this.body;
      name = iced["const"].deferrals;
      o.scope.add(name, 'var');
      lhs = new Value(new Literal(name));
      cls = new Value(new Literal(iced["const"].ns));
      cls.add(new Access(new Value(new Literal(iced["const"].Deferrals))));
      assignments = [];
      if (n = (_ref2 = this.parentFunc) != null ? _ref2.icedPassedDeferral : void 0) {
        cb_lhs = new Value(new Literal(iced["const"].parent));
        cb_rhs = new Value(new Literal(n));
        cb_assignment = new Assign(cb_lhs, cb_rhs, "object");
        assignments.push(cb_assignment);
      }
      if (o.filename != null) {
        fn_lhs = new Value(new Literal(iced["const"].filename));
        fn_rhs = new Value(new Literal(quote_path_for_emission(o.filename)));
        fn_assignment = new Assign(fn_lhs, fn_rhs, "object");
        assignments.push(fn_assignment);
      }
      if (n = (_ref3 = this.parentFunc) != null ? _ref3.icedTraceName() : void 0) {
        func_lhs = new Value(new Literal(iced["const"].funcname));
        func_rhs = new Value(new Literal('"' + n + '"'));
        func_assignment = new Assign(func_lhs, func_rhs, "object");
        assignments.push(func_assignment);
      }
      trace = new Obj(assignments, true);
      call = new Call(cls, [new Value(new Literal(iced["const"].k)), trace]);
      rhs = new Op("new", call);
      assign = new Assign(lhs, rhs);
      body.unshift(assign);
      meth = lhs.copy().add(new Access(new Value(new Literal(iced["const"].fulfill))));
      call = new Call(meth, []);
      body.push(call);
      return this.body = body;
    };

    Await.prototype.children = ['body'];

    Await.prototype.isStatement = function() {
      return YES;
    };

    Await.prototype.makeReturn = THIS;

    Await.prototype.compileNode = function(o) {
      this.transform(o);
      return this.body.compileNode(o);
    };

    Await.prototype.icedWalkAst = function(p, o) {
      this.icedHasAutocbFlag = o.foundAutocb;
      this.parentFunc = o.currFunc;
      p = p || this;
      this.icedParentAwait = p;
      Await.__super__.icedWalkAst.call(this, p, o);
      return this.icedNodeFlag = o.foundAwaitFunc = o.foundAwait = true;
    };

    return Await;

  })(Base);

  IcedRuntime = (function(_super) {
    __extends(IcedRuntime, _super);

    function IcedRuntime(foundDefer, foundAwait) {
      this.foundDefer = foundDefer;
      this.foundAwait = foundAwait;
      IcedRuntime.__super__.constructor.call(this);
    }

    IcedRuntime.prototype.compileNode = function(o, level) {
      var access, accessname, assign, call, callv, file, inc, interp, k, klass, lhs_vec, ns, qmodname, req, rhs, v, val, window_mode, window_val, _i, _j, _len, _len1, _ref2;
      this.expressions = [];
      v = o.runtime ? o.runtime : o.bare ? "none" : this.foundDefer ? "node" : "none";
      if (o.runtime && !this.foundDefer && !o.runforce) {
        v = "none";
      }
      window_mode = false;
      window_val = null;
      inc = null;
      inc = (function() {
        switch (v) {
          case "inline":
          case "window":
            if (v === "window") {
              window_mode = true;
            }
            if (window_mode) {
              window_val = new Value(new Literal(v));
            }
            return InlineRuntime.generate(window_val ? window_val.copy() : null);
          case "node":
          case "browserify":
          case "interp":
            interp = v === "interp";
            qmodname = interp ? require_top_dir() : "'iced-runtime'";
            accessname = iced["const"].ns;
            file = new Literal(qmodname);
            access = new Access(new Literal(accessname));
            req = new Value(new Literal("require"));
            call = new Call(req, [file]);
            callv = new Value(call);
            if (interp) {
              callv.add(access);
            }
            ns = new Value(new Literal(iced["const"].ns));
            return new Assign(ns, callv);
          case "none":
            return null;
          default:
            throw SyntaxError("unexpected flag IcedRuntime " + v);
        }
      })();
      if (inc) {
        this.push(inc);
      }
      if (this.foundAwait) {
        rhs = new Code([], new Block([]));
        lhs_vec = [];
        _ref2 = [iced["const"].k_noop, iced["const"].k];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          k = _ref2[_i];
          val = new Value(new Literal(k));
          if (window_val) {
            klass = window_val.copy();
            klass.add(new Access(val));
            val = klass;
          }
          lhs_vec.push(val);
        }
        assign = rhs;
        for (_j = 0, _len1 = lhs_vec.length; _j < _len1; _j++) {
          v = lhs_vec[_j];
          assign = new Assign(v, assign);
        }
        this.push(assign);
      }
      if (this.isEmpty()) {
        return [];
      } else {
        return IcedRuntime.__super__.compileNode.call(this, o);
      }
    };

    IcedRuntime.prototype.icedWalkAst = function(p, o) {
      this.icedHasAutocbFlag = o.foundAutocb;
      return IcedRuntime.__super__.icedWalkAst.call(this, p, o);
    };

    return IcedRuntime;

  })(Block);

  exports.Try = Try = (function(_super) {
    __extends(Try, _super);

    function Try(attempt, errorVariable, recovery, ensure) {
      this.attempt = attempt;
      this.errorVariable = errorVariable;
      this.recovery = recovery;
      this.ensure = ensure;
    }

    Try.prototype.children = ['attempt', 'recovery', 'ensure'];

    Try.prototype.isStatement = YES;

    Try.prototype.jumps = function(o) {
      var _ref2;
      return this.attempt.jumps(o) || ((_ref2 = this.recovery) != null ? _ref2.jumps(o) : void 0);
    };

    Try.prototype.makeReturn = function(res) {
      if (this.attempt) {
        this.attempt = this.attempt.makeReturn(res);
      }
      if (this.recovery) {
        this.recovery = this.recovery.makeReturn(res);
      }
      return this;
    };

    Try.prototype.compileNode = function(o) {
      var catchPart, ensurePart, placeholder, tryPart;
      o.indent += TAB;
      tryPart = this.attempt.compileToFragments(o, LEVEL_TOP);
      catchPart = this.recovery ? (placeholder = new Literal('_error'), this.errorVariable ? this.recovery.unshift(new Assign(this.errorVariable, placeholder)) : void 0, [].concat(this.makeCode(" catch ("), placeholder.compileToFragments(o), this.makeCode(") {\n"), this.recovery.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab + "}"))) : !(this.ensure || this.recovery) ? [this.makeCode(' catch (_error) {}')] : [];
      ensurePart = this.ensure ? [].concat(this.makeCode(" finally {\n"), this.ensure.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab + "}")) : [];
      return [].concat(this.makeCode("" + this.tab + "try {\n"), tryPart, this.makeCode("\n" + this.tab + "}"), catchPart, ensurePart);
    };

    return Try;

  })(Base);

  exports.Throw = Throw = (function(_super) {
    __extends(Throw, _super);

    function Throw(expression) {
      this.expression = expression;
      Throw.__super__.constructor.call(this);
    }

    Throw.prototype.children = ['expression'];

    Throw.prototype.isStatement = YES;

    Throw.prototype.jumps = NO;

    Throw.prototype.makeReturn = THIS;

    Throw.prototype.compileNode = function(o) {
      return [].concat(this.makeCode(this.tab + "throw "), this.expression.compileToFragments(o), this.makeCode(";"));
    };

    return Throw;

  })(Base);

  exports.Existence = Existence = (function(_super) {
    __extends(Existence, _super);

    function Existence(expression) {
      this.expression = expression;
      Existence.__super__.constructor.call(this);
    }

    Existence.prototype.children = ['expression'];

    Existence.prototype.invert = NEGATE;

    Existence.prototype.compileNode = function(o) {
      var cmp, cnj, code, _ref2;
      this.expression.front = this.front;
      code = this.expression.compile(o, LEVEL_OP);
      if (IDENTIFIER.test(code) && !o.scope.check(code)) {
        _ref2 = this.negated ? ['===', '||'] : ['!==', '&&'], cmp = _ref2[0], cnj = _ref2[1];
        code = "typeof " + code + " " + cmp + " \"undefined\" " + cnj + " " + code + " " + cmp + " null";
      } else {
        code = "" + code + " " + (this.negated ? '==' : '!=') + " null";
      }
      return [this.makeCode(o.level <= LEVEL_COND ? code : "(" + code + ")")];
    };

    return Existence;

  })(Base);

  exports.Parens = Parens = (function(_super) {
    __extends(Parens, _super);

    function Parens(body) {
      this.body = body;
      Parens.__super__.constructor.call(this);
    }

    Parens.prototype.children = ['body'];

    Parens.prototype.unwrap = function() {
      return this.body;
    };

    Parens.prototype.isComplex = function() {
      return this.body.isComplex();
    };

    Parens.prototype.compileNode = function(o) {
      var bare, expr, fragments;
      expr = this.body.unwrap();
      if (expr instanceof Value && expr.isAtomic()) {
        expr.front = this.front;
        return expr.compileToFragments(o);
      }
      fragments = expr.compileToFragments(o, LEVEL_PAREN);
      bare = o.level < LEVEL_OP && (expr instanceof Op || expr instanceof Call || (expr instanceof For && expr.returns));
      if (bare) {
        return fragments;
      } else {
        return this.wrapInBraces(fragments);
      }
    };

    return Parens;

  })(Base);

  exports.For = For = (function(_super) {
    __extends(For, _super);

    function For(body, source) {
      var _ref2;
      For.__super__.constructor.call(this);
      this.source = source.source, this.guard = source.guard, this.step = source.step, this.name = source.name, this.index = source.index;
      this.body = Block.wrap([body]);
      this.own = !!source.own;
      this.object = !!source.object;
      if (this.object) {
        _ref2 = [this.index, this.name], this.name = _ref2[0], this.index = _ref2[1];
      }
      if (this.index instanceof Value) {
        this.index.error('index cannot be a pattern matching expression');
      }
      this.range = this.source instanceof Value && this.source.base instanceof Range && !this.source.properties.length;
      this.pattern = this.name instanceof Value;
      if (this.range && this.index) {
        this.index.error('indexes do not apply to range loops');
      }
      if (this.range && this.pattern) {
        this.name.error('cannot pattern match over range loops');
      }
      if (this.own && !this.object) {
        this.name.error('cannot use own with for-in');
      }
      this.returns = false;
    }

    For.prototype.children = ['body', 'source', 'guard', 'step'];

    For.prototype.compileNode = function(o) {
      var body, bodyFragments, compare, compareDown, declare, declareDown, defPart, defPartFragments, down, forPartFragments, guardPart, idt1, increment, index, ivar, kvar, kvarAssign, lastJumps, lvar, name, namePart, ref, resultPart, returnResult, rvar, scope, source, step, stepNum, stepVar, svar, varPart, _ref2, _ref3;
      body = Block.wrap([this.body]);
      lastJumps = (_ref2 = last(body.expressions)) != null ? _ref2.jumps() : void 0;
      if (lastJumps && lastJumps instanceof Return) {
        this.returns = false;
      }
      source = this.range ? this.source.base : this.source;
      scope = o.scope;
      if (!this.pattern) {
        name = this.name && (this.name.compile(o, LEVEL_LIST));
      }
      index = this.index && (this.index.compile(o, LEVEL_LIST));
      if (name && !this.pattern) {
        scope.find(name);
      }
      if (index) {
        scope.find(index);
      }
      if (this.returns) {
        rvar = scope.freeVariable('results');
      }
      ivar = (this.object && index) || scope.freeVariable('i');
      kvar = (this.range && name) || index || ivar;
      kvarAssign = kvar !== ivar ? "" + kvar + " = " : "";
      if (this.step && !this.range) {
        _ref3 = this.cacheToCodeFragments(this.step.cache(o, LEVEL_LIST)), step = _ref3[0], stepVar = _ref3[1];
        stepNum = stepVar.match(NUMBER);
      }
      if (this.pattern) {
        name = ivar;
      }
      varPart = '';
      guardPart = '';
      defPart = '';
      idt1 = this.tab + TAB;
      source.icedStatementAssertion();
      if (this.icedNodeFlag) {
        return this.icedCompileIced(o, {
          stepVar: stepVar,
          body: body,
          rvar: rvar,
          kvar: kvar,
          guard: this.guard
        });
      }
      if (this.range) {
        forPartFragments = source.compileToFragments(merge(o, {
          index: ivar,
          name: name,
          step: this.step
        }));
      } else {
        svar = this.source.compile(o, LEVEL_LIST);
        if ((name || this.own) && !IDENTIFIER.test(svar)) {
          defPart += "" + this.tab + (ref = scope.freeVariable('ref')) + " = " + svar + ";\n";
          svar = ref;
        }
        if (name && !this.pattern) {
          namePart = "" + name + " = " + svar + "[" + kvar + "]";
        }
        if (!this.object) {
          if (step !== stepVar) {
            defPart += "" + this.tab + step + ";\n";
          }
          if (!(this.step && stepNum && (down = parseNum(stepNum[0]) < 0))) {
            lvar = scope.freeVariable('len');
          }
          declare = "" + kvarAssign + ivar + " = 0, " + lvar + " = " + svar + ".length";
          declareDown = "" + kvarAssign + ivar + " = " + svar + ".length - 1";
          compare = "" + ivar + " < " + lvar;
          compareDown = "" + ivar + " >= 0";
          if (this.step) {
            if (stepNum) {
              if (down) {
                compare = compareDown;
                declare = declareDown;
              }
            } else {
              compare = "" + stepVar + " > 0 ? " + compare + " : " + compareDown;
              declare = "(" + stepVar + " > 0 ? (" + declare + ") : " + declareDown + ")";
            }
            increment = "" + ivar + " += " + stepVar;
          } else {
            increment = "" + (kvar !== ivar ? "++" + ivar : "" + ivar + "++");
          }
          forPartFragments = [this.makeCode("" + declare + "; " + compare + "; " + kvarAssign + increment)];
        }
      }
      if (this.returns) {
        resultPart = "" + this.tab + rvar + " = [];\n";
        returnResult = this.icedHasAutocbFlag ? "\n" + this.tab + iced["const"].autocb + "(" + rvar + "); return;" : "\n" + this.tab + "return " + rvar + ";";
        body.makeReturn(rvar);
      }
      if (this.guard) {
        if (body.expressions.length > 1) {
          body.expressions.unshift(new If((new Parens(this.guard)).invert(), new Literal("continue")));
        } else {
          if (this.guard) {
            body = Block.wrap([new If(this.guard, body)]);
          }
        }
      }
      if (this.pattern) {
        body.expressions.unshift(new Assign(this.name, new Literal("" + svar + "[" + kvar + "]")));
      }
      defPartFragments = [].concat(this.makeCode(defPart), this.pluckDirectCall(o, body));
      if (namePart) {
        varPart = "\n" + idt1 + namePart + ";";
      }
      if (this.object) {
        forPartFragments = [this.makeCode("" + kvar + " in " + svar)];
        if (this.own) {
          guardPart = "\n" + idt1 + "if (!" + (utility('hasProp')) + ".call(" + svar + ", " + kvar + ")) continue;";
        }
      }
      bodyFragments = body.compileToFragments(merge(o, {
        indent: idt1
      }), LEVEL_TOP);
      if (bodyFragments && (bodyFragments.length > 0)) {
        bodyFragments = [].concat(this.makeCode("\n"), bodyFragments, this.makeCode("\n"));
      }
      return [].concat(defPartFragments, this.makeCode("" + (resultPart || '') + this.tab + "for ("), forPartFragments, this.makeCode(") {" + guardPart + varPart), bodyFragments, this.makeCode("" + this.tab + "}" + (returnResult || '')));
    };

    For.prototype.pluckDirectCall = function(o, body) {
      var base, defs, expr, fn, idx, ref, val, _i, _len, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      defs = [];
      _ref2 = body.expressions;
      for (idx = _i = 0, _len = _ref2.length; _i < _len; idx = ++_i) {
        expr = _ref2[idx];
        expr = expr.unwrapAll();
        if (!(expr instanceof Call)) {
          continue;
        }
        val = (_ref3 = expr.variable) != null ? _ref3.unwrapAll() : void 0;
        if (!((val instanceof Code) || (val instanceof Value && ((_ref4 = val.base) != null ? _ref4.unwrapAll() : void 0) instanceof Code && val.properties.length === 1 && ((_ref5 = (_ref6 = val.properties[0].name) != null ? _ref6.value : void 0) === 'call' || _ref5 === 'apply')))) {
          continue;
        }
        fn = ((_ref7 = val.base) != null ? _ref7.unwrapAll() : void 0) || val;
        ref = new Literal(o.scope.freeVariable('fn'));
        base = new Value(ref);
        if (val.base) {
          _ref8 = [base, val], val.base = _ref8[0], base = _ref8[1];
        }
        body.expressions[idx] = new Call(base, expr.args);
        defs = defs.concat(this.makeCode(this.tab), new Assign(ref, fn).compileToFragments(o, LEVEL_TOP), this.makeCode(';\n'));
      }
      return defs;
    };

    For.prototype.icedCompileIced = function(o, d) {
      var a1, a2, a3, a4, a5, b, begin, body, condition, empty_arr, end, excl, guard, iname, init, ival, key, key_lit, key_val, keys, keys_access, keys_len, keys_val, kval, len, len_rhs, len_val, loop_body, loop_keys, loop_source, neg, pos, positive, pre_body, ref, ref_val, ref_val_copy, rvar, scope, source_access, step, stepVal;
      body = d.body;
      condition = null;
      init = [];
      step = null;
      scope = o.scope;
      pre_body = new Block([]);
      if (this.object) {
        ref = scope.freeVariable('ref');
        ref_val = new Value(new Literal(ref));
        a1 = new Assign(ref_val, this.source);
        keys = scope.freeVariable('keys');
        keys_val = new Value(new Literal(keys));
        key = scope.freeVariable('k');
        key_lit = new Literal(key);
        key_val = new Value(key_lit);
        empty_arr = new Value(new Arr);
        loop_body = new Block([key_val]);
        loop_source = {
          object: true,
          name: key_lit,
          source: ref_val
        };
        loop_keys = new For(loop_body, loop_source);
        a2 = new Assign(keys_val, loop_keys);
        iname = scope.freeVariable('i');
        ival = new Value(new Literal(iname));
        a3 = new Assign(ival, new Value(new Literal(0)));
        init = [a1, a2, a3];
        keys_len = keys_val.copy();
        keys_len.add(new Access(new Value(new Literal("length"))));
        condition = new Op('<', ival, keys_len);
        step = new Op('++', ival);
        if (this.name) {
          source_access = ref_val.copy();
          source_access.add(new Index(this.index));
          a5 = new Assign(this.name, source_access);
          pre_body.unshift(a5);
        }
        keys_access = keys_val.copy();
        keys_access.add(new Index(ival));
        a4 = new Assign(this.index, keys_access);
        pre_body.unshift(a4);
      } else if (this.range) {
        if (!this.name) {
          this.name = new Literal(d.kvar);
        }
        begin = new Value(new Literal("_begin"));
        end = new Value(new Literal("_end"));
        positive = new Value(new Literal("_positive"));
        stepVal = this.step || new Literal(1);
        step = new If(positive, new Op("+=", this.name, stepVal));
        step.addElse(new Op("-=", this.name, stepVal));
        excl = this.source.base.exclusive ? "=" : '';
        pos = new Op("&&", new Op("===", positive, new Literal(true)), new Op(">" + excl, this.name, this.source.base.to));
        neg = new Op("&&", new Op("===", positive, new Literal(false)), new Op("<" + excl, this.name, this.source.base.to));
        condition = new Op("||", new Parens(pos), new Parens(neg));
        condition = condition.invert();
        init = [new Assign(this.name, this.source.base.from), new Assign(begin, this.source.base.from), new Assign(end, this.source.base.to), new Assign(positive, new Op(">", end, begin))];
      } else if (!this.range && this.name) {
        kval = new Value(new Literal(d.kvar));
        len = scope.freeVariable('len');
        ref = scope.freeVariable('ref');
        ref_val = new Value(new Literal(ref));
        len_val = new Value(new Literal(len));
        a1 = new Assign(ref_val, this.source);
        len_rhs = ref_val.copy().add(new Access(new Value(new Literal("length"))));
        a2 = new Assign(len_val, len_rhs);
        a3 = new Assign(kval, new Value(new Literal(0)));
        init = [a1, a2, a3];
        condition = new Op('<', kval, len_val);
        step = new Op('++', kval);
        ref_val_copy = ref_val.copy();
        ref_val_copy.add(new Index(kval));
        a4 = new Assign(this.name, ref_val_copy);
        pre_body.unshift(a4);
      }
      rvar = d.rvar;
      guard = d.guard;
      b = this.icedWrap({
        condition: condition,
        body: body,
        init: init,
        step: step,
        rvar: rvar,
        guard: guard,
        pre_body: pre_body
      });
      return b.compileNode(o);
    };

    return For;

  })(While);

  exports.Switch = Switch = (function(_super) {
    __extends(Switch, _super);

    function Switch(subject, cases, otherwise) {
      this.subject = subject;
      this.cases = cases;
      this.otherwise = otherwise;
      Switch.__super__.constructor.call(this);
    }

    Switch.prototype.children = ['subject', 'cases', 'otherwise'];

    Switch.prototype.isStatement = YES;

    Switch.prototype.jumps = function(o) {
      var block, conds, jumpNode, _i, _len, _ref2, _ref3, _ref4;
      if (o == null) {
        o = {
          block: true
        };
      }
      _ref2 = this.cases;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        _ref3 = _ref2[_i], conds = _ref3[0], block = _ref3[1];
        if (jumpNode = block.jumps(o)) {
          return jumpNode;
        }
      }
      return (_ref4 = this.otherwise) != null ? _ref4.jumps(o) : void 0;
    };

    Switch.prototype.makeReturn = function(res) {
      var pair, _i, _len, _ref2, _ref3;
      _ref2 = this.cases;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        pair = _ref2[_i];
        pair[1].makeReturn(res);
      }
      if (res) {
        this.otherwise || (this.otherwise = new Block([new Literal('void 0')]));
      }
      if ((_ref3 = this.otherwise) != null) {
        _ref3.makeReturn(res);
      }
      return this;
    };

    Switch.prototype.compileNode = function(o) {
      var block, body, cond, conditions, expr, fragments, i, idt1, idt2, _i, _j, _len, _len1, _ref2, _ref3, _ref4;
      if (this.subject) {
        this.subject.icedStatementAssertion();
      }
      idt1 = o.indent + TAB;
      idt2 = o.indent = idt1 + TAB;
      fragments = [].concat(this.makeCode(this.tab + "switch ("), (this.subject ? this.subject.compileToFragments(o, LEVEL_PAREN) : this.makeCode("false")), this.makeCode(") {\n"));
      _ref2 = this.cases;
      for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
        _ref3 = _ref2[i], conditions = _ref3[0], block = _ref3[1];
        _ref4 = flatten([conditions]);
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          cond = _ref4[_j];
          if (!this.subject) {
            cond = cond.invert();
          }
          fragments = fragments.concat(this.makeCode(idt1 + "case "), cond.compileToFragments(o, LEVEL_PAREN), this.makeCode(":\n"));
        }
        if ((body = block.compileToFragments(o, LEVEL_TOP)).length > 0) {
          fragments = fragments.concat(body, this.makeCode('\n'));
        }
        if (i === this.cases.length - 1 && !this.otherwise) {
          break;
        }
        expr = this.lastNonComment(block.expressions);
        if (expr instanceof Return || (expr instanceof Literal && expr.jumps() && expr.value !== 'debugger')) {
          continue;
        }
        fragments.push(cond.makeCode(idt2 + 'break;\n'));
      }
      if (this.otherwise && this.otherwise.expressions.length) {
        fragments.push.apply(fragments, [this.makeCode(idt1 + "default:\n")].concat(__slice.call(this.otherwise.compileToFragments(o, LEVEL_TOP)), [this.makeCode("\n")]));
      }
      fragments.push(this.makeCode(this.tab + '}'));
      return fragments;
    };

    Switch.prototype.icedCallContinuation = function() {
      var block, condition, _i, _len, _ref2, _ref3;
      _ref2 = this.cases;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        _ref3 = _ref2[_i], condition = _ref3[0], block = _ref3[1];
        block.icedThreadReturn();
      }
      if (this.otherwise != null) {
        return this.otherwise.icedThreadReturn();
      } else {
        return this.otherwise = new Block([new IcedTailCall]);
      }
    };

    return Switch;

  })(Base);

  exports.If = If = (function(_super) {
    __extends(If, _super);

    function If(condition, body, options) {
      this.body = body;
      if (options == null) {
        options = {};
      }
      If.__super__.constructor.call(this);
      this.condition = options.type === 'unless' ? condition.invert() : condition;
      this.elseBody = null;
      this.isChain = false;
      this.soak = options.soak;
    }

    If.prototype.children = ['condition', 'body', 'elseBody'];

    If.prototype.bodyNode = function() {
      var _ref2;
      return (_ref2 = this.body) != null ? _ref2.unwrap() : void 0;
    };

    If.prototype.elseBodyNode = function() {
      var _ref2;
      return (_ref2 = this.elseBody) != null ? _ref2.unwrap() : void 0;
    };

    If.prototype.addElse = function(elseBody) {
      if (this.isChain) {
        this.elseBodyNode().addElse(elseBody);
      } else {
        this.isChain = elseBody instanceof If;
        this.elseBody = this.ensureBlock(elseBody);
        this.elseBody.updateLocationDataIfMissing(elseBody.locationData);
      }
      return this;
    };

    If.prototype.isStatement = function(o) {
      var _ref2;
      return (o != null ? o.level : void 0) === LEVEL_TOP || this.bodyNode().isStatement(o) || ((_ref2 = this.elseBodyNode()) != null ? _ref2.isStatement(o) : void 0);
    };

    If.prototype.jumps = function(o) {
      var _ref2;
      return this.body.jumps(o) || ((_ref2 = this.elseBody) != null ? _ref2.jumps(o) : void 0);
    };

    If.prototype.compileNode = function(o) {
      this.condition.icedStatementAssertion();
      if (this.isStatement(o || this.icedIsCpsPivot())) {
        return this.compileStatement(o);
      } else {
        return this.compileExpression(o);
      }
    };

    If.prototype.makeReturn = function(res) {
      if (res) {
        this.elseBody || (this.elseBody = new Block([new Literal('void 0')]));
      }
      this.body && (this.body = new Block([this.body.makeReturn(res)]));
      this.elseBody && (this.elseBody = new Block([this.elseBody.makeReturn(res)]));
      return this;
    };

    If.prototype.ensureBlock = function(node) {
      if (node instanceof Block) {
        return node;
      } else {
        return new Block([node]);
      }
    };

    If.prototype.compileStatement = function(o) {
      var answer, body, child, cond, exeq, ifPart, indent;
      child = del(o, 'chainChild');
      exeq = del(o, 'isExistentialEquals');
      if (exeq) {
        return new If(this.condition.invert(), this.elseBodyNode(), {
          type: 'if'
        }).compileToFragments(o);
      }
      indent = o.indent + TAB;
      cond = this.condition.compileToFragments(o, LEVEL_PAREN);
      body = this.ensureBlock(this.body).compileToFragments(merge(o, {
        indent: indent
      }));
      ifPart = [].concat(this.makeCode("if ("), cond, this.makeCode(") {\n"), body, this.makeCode("\n" + this.tab + "}"));
      if (!child) {
        ifPart.unshift(this.makeCode(this.tab));
      }
      if (!this.elseBody) {
        return ifPart;
      }
      answer = ifPart.concat(this.makeCode(' else '));
      if (this.isChain) {
        o.chainChild = true;
        answer = answer.concat(this.elseBody.unwrap().compileToFragments(o, LEVEL_TOP));
      } else {
        answer = answer.concat(this.makeCode("{\n"), this.elseBody.compileToFragments(merge(o, {
          indent: indent
        }), LEVEL_TOP), this.makeCode("\n" + this.tab + "}"));
      }
      return answer;
    };

    If.prototype.compileExpression = function(o) {
      var alt, body, cond, fragments;
      cond = this.condition.compileToFragments(o, LEVEL_COND);
      body = this.bodyNode().compileToFragments(o, LEVEL_LIST);
      alt = this.elseBodyNode() ? this.elseBodyNode().compileToFragments(o, LEVEL_LIST) : [this.makeCode('void 0')];
      fragments = cond.concat(this.makeCode(" ? "), body, this.makeCode(" : "), alt);
      if (o.level >= LEVEL_COND) {
        return this.wrapInBraces(fragments);
      } else {
        return fragments;
      }
    };

    If.prototype.unfoldSoak = function() {
      return this.soak && this;
    };

    If.prototype.icedCallContinuation = function() {
      if (this.elseBody) {
        this.elseBody.icedThreadReturn();
        this.isChain = false;
      } else {
        this.addElse(new IcedTailCall);
      }
      return this.body.icedThreadReturn();
    };

    return If;

  })(Base);

  Closure = {
    wrap: function(expressions, statement, noReturn) {
      var args, argumentsNode, call, func, meth;
      if (expressions.jumps()) {
        return expressions;
      }
      func = new Code([], Block.wrap([expressions]));
      args = [];
      argumentsNode = expressions.contains(this.isLiteralArguments);
      if (argumentsNode && expressions.classBody) {
        argumentsNode.error("Class bodies shouldn't reference arguments");
      }
      if (argumentsNode || expressions.contains(this.isLiteralThis)) {
        meth = new Literal(argumentsNode ? 'apply' : 'call');
        args = [new Literal('this')];
        if (argumentsNode) {
          args.push(new Literal('arguments'));
        }
        func = new Value(func, [new Access(meth)]);
      }
      func.noReturn = noReturn;
      call = new Call(func, args);
      if (statement) {
        return Block.wrap([call]);
      } else {
        return call;
      }
    },
    isLiteralArguments: function(node) {
      return node instanceof Literal && node.value === 'arguments' && !node.asKey;
    },
    isLiteralThis: function(node) {
      return (node instanceof Literal && node.value === 'this' && !node.asKey) || (node instanceof Code && node.bound) || (node instanceof Call && node.isSuper);
    }
  };

  unfoldSoak = function(o, parent, name) {
    var ifn;
    if (!(ifn = parent[name].unfoldSoak(o))) {
      return;
    }
    parent[name] = ifn.body;
    ifn.body = new Value(parent);
    return ifn;
  };

  CpsCascade = {
    wrap: function(statement, rest, returnValue, o) {
      var args, block, call, cont, e, func;
      func = new Code([new Param(new Literal(iced["const"].k))], Block.wrap([statement]), 'icedgen');
      args = [];
      if (returnValue) {
        returnValue.bindName(o);
        args.push(returnValue);
      }
      block = Block.wrap([rest]);
      if ((e = block.icedGetSingle()) && e instanceof IcedTailCall && e.canInline()) {
        cont = e.extractFunc();
      } else {
        cont = new Code(args, block, 'icedgen');
      }
      call = new Call(func, [cont]);
      return new Block([call]);
    }
  };

  IcedTailCall = (function(_super) {
    __extends(IcedTailCall, _super);

    function IcedTailCall(func, val) {
      this.func = func;
      if (val == null) {
        val = null;
      }
      IcedTailCall.__super__.constructor.call(this);
      if (!this.func) {
        this.func = iced["const"].k;
      }
      this.value = val;
    }

    IcedTailCall.prototype.children = ['value'];

    IcedTailCall.prototype.assignValue = function(v) {
      return this.value = v;
    };

    IcedTailCall.prototype.canInline = function() {
      return !this.value || this.value instanceof IcedReturnValue;
    };

    IcedTailCall.prototype.literalFunc = function() {
      return new Literal(this.func);
    };

    IcedTailCall.prototype.extractFunc = function() {
      return new Value(this.literalFunc());
    };

    IcedTailCall.prototype.compileNode = function(o) {
      var args, f, out;
      f = this.literalFunc();
      out = o.level === LEVEL_TOP ? this.value ? new Block([this.value, new Call(f)]) : new Call(f) : (args = this.value ? [this.value] : [], new Call(f, args));
      return out.compileNode(o);
    };

    return IcedTailCall;

  })(Base);

  IcedReturnValue = (function(_super) {
    __extends(IcedReturnValue, _super);

    IcedReturnValue.counter = 0;

    function IcedReturnValue() {
      IcedReturnValue.__super__.constructor.call(this, null, null, false);
    }

    IcedReturnValue.prototype.bindName = function(o) {
      var l;
      l = "" + (o.scope.freeVariable(iced["const"].param, false)) + "_" + (IcedReturnValue.counter++);
      return this.name = new Literal(l);
    };

    IcedReturnValue.prototype.compile = function(o) {
      if (!this.name) {
        this.bindName(o);
      }
      return IcedReturnValue.__super__.compile.call(this, o);
    };

    return IcedReturnValue;

  })(Param);

  InlineRuntime = {
    generate: function(ns_window) {
      var a1, a2, af, apply_call, assignments, body, call_meth, cn, cnt, cnt_member, constructor_assign, constructor_body, constructor_code, constructor_name, constructor_params, decr, defer_assign, defer_body, defer_code, defer_name, defer_params, dp, dp_value, fn, fn_assign, fn_code, fn_name, if_body, if_cond, if_expr, inc, inner_body, inner_code, inner_params, ip, k, k_member, klass, klass_assign, my_apply, my_if, my_null, ns, ns_obj, ns_val, obj, outer_block, p1, ret_member, tr_assign, tr_block, tr_code, tr_name, tr_params, _fulfill_assign, _fulfill_body, _fulfill_call, _fulfill_code, _fulfill_method, _fulfill_name;
      k = new Literal("continuation");
      cnt = new Literal("count");
      cn = new Value(new Literal(iced["const"].Deferrals));
      ns = new Value(new Literal(iced["const"].ns));
      if (ns_window) {
        ns_window.add(new Access(ns));
        ns = ns_window;
      }
      k_member = new Value(new Literal("this"));
      k_member.add(new Access(k));
      p1 = new Param(k_member);
      cnt_member = new Value(new Literal("this"));
      cnt_member.add(new Access(cnt));
      ret_member = new Value(new Literal("this"));
      ret_member.add(new Access(new Value(new Literal(iced["const"].retslot))));
      a1 = new Assign(cnt_member, new Value(new Literal(1)));
      a2 = new Assign(ret_member, NULL());
      constructor_params = [p1];
      constructor_body = new Block([a1, a2]);
      constructor_code = new Code(constructor_params, constructor_body);
      constructor_name = new Value(new Literal("constructor"));
      constructor_assign = new Assign(constructor_name, constructor_code);
      if_expr = new Call(k_member, [ret_member]);
      if_body = new Block([if_expr]);
      decr = new Op('--', cnt_member);
      if_cond = new Op('!', decr);
      my_if = new If(if_cond, if_body);
      _fulfill_body = new Block([my_if]);
      _fulfill_code = new Code([], _fulfill_body);
      _fulfill_name = new Value(new Literal(iced["const"].fulfill));
      _fulfill_assign = new Assign(_fulfill_name, _fulfill_code);
      inc = new Op("++", cnt_member);
      ip = new Literal("inner_params");
      dp = new Literal("defer_params");
      dp_value = new Value(dp);
      call_meth = new Value(dp);
      af = new Literal(iced["const"].assign_fn);
      call_meth.add(new Access(af, "soak"));
      my_apply = new Literal("apply");
      call_meth.add(new Access(my_apply, "soak"));
      my_null = NULL();
      apply_call = new Call(call_meth, [my_null, new Value(ip)]);
      _fulfill_method = new Value(new Literal("this"));
      _fulfill_method.add(new Access(new Literal(iced["const"].fulfill)));
      _fulfill_call = new Call(_fulfill_method, []);
      inner_body = new Block([apply_call, _fulfill_call]);
      inner_params = [new Param(ip, null, true)];
      inner_code = new Code(inner_params, inner_body, "boundfunc");
      defer_body = new Block([inc, inner_code]);
      defer_params = [new Param(dp)];
      defer_code = new Code(defer_params, defer_body);
      defer_name = new Value(new Literal(iced["const"].defer_method));
      defer_assign = new Assign(defer_name, defer_code);
      assignments = [constructor_assign, _fulfill_assign, defer_assign];
      obj = new Obj(assignments, true);
      body = new Block([new Value(obj)]);
      klass = new Class(null, null, body);
      klass_assign = new Assign(cn, klass, "object");
      outer_block = new Block([NULL()]);
      fn_code = new Code([], outer_block);
      fn_name = new Value(new Literal(iced["const"].findDeferral));
      fn_assign = new Assign(fn_name, fn_code, "object");
      fn = new Literal("_fn");
      tr_block = new Block([new Call(new Value(fn), [])]);
      tr_params = [new Param(fn)];
      tr_code = new Code(tr_params, tr_block);
      tr_name = new Value(new Literal(iced["const"].trampoline));
      tr_assign = new Assign(tr_name, tr_code, "object");
      ns_obj = new Obj([klass_assign, fn_assign, tr_assign], true);
      ns_val = new Value(ns_obj);
      return new Assign(ns, ns_val);
    }
  };

  UTILITIES = {
    "extends": function() {
      return "function(child, parent) { for (var key in parent) { if (" + (utility('hasProp')) + ".call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }";
    },
    bind: function() {
      return 'function(fn, me){ return function(){ return fn.apply(me, arguments); }; }';
    },
    indexOf: function() {
      return "[].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; }";
    },
    SchemeNumber: function() {
      return "typeof require === 'undefined' ? SchemeNumber : require('./../javascript-bignum/schemeNumber').SchemeNumber";
    },
    modulo: function() {
      return "function(a, b) { return (+a % (b = +b) + b) % b; }";
    },
    hasProp: function() {
      return '{}.hasOwnProperty';
    },
    slice: function() {
      return '[].slice';
    }
  };

  LEVEL_TOP = 1;

  LEVEL_PAREN = 2;

  LEVEL_LIST = 3;

  LEVEL_COND = 4;

  LEVEL_OP = 5;

  LEVEL_ACCESS = 6;

  TAB = '  ';

  IDENTIFIER_STR = "[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*";

  IDENTIFIER = RegExp("^" + IDENTIFIER_STR + "$");

  SIMPLENUM = /^[+-]?\d+$/;

  HEXNUM = /^[+-]?0x[\da-f]+/i;

  NUMBER = /^[+-]?(?:0x[\da-f]+|\d+\/\d+|\d*\.?\d+(?:e[+-]?\d+)?)$/i;

  EXACT_REAL = /^[+-]?\d+(\/\d+)?$/;

  METHOD_DEF = RegExp("^(" + IDENTIFIER_STR + ")(\\.prototype)?(?:\\.(" + IDENTIFIER_STR + ")|\\[(\"(?:[^\\\\\"\\r\\n]|\\\\.)*\"|'(?:[^\\\\'\\r\\n]|\\\\.)*')\\]|\\[(0x[\\da-fA-F]+|\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\])$");

  utility = function(name) {
    var ref;
    ref = "__" + name;
    Scope.root.assign(ref, UTILITIES[name]());
    return ref;
  };

  schemeNumberFunctionWrapper = function(wrapperName, name, schemeFn, makejs) {
    var ref, sref;
    ref = "__f_" + wrapperName;
    sref = schemeNumberFunction(name, schemeFn);
    Scope.root.assign(ref, makejs(sref));
    return ref;
  };

  schemeNumberFunction = function(name, schemeFn) {
    var ref, schemeNumber;
    ref = "__" + name;
    schemeNumber = utility('SchemeNumber');
    Scope.root.assign(ref, schemeNumber + (".fn['" + schemeFn + "']"));
    return ref;
  };

  schemeNumberValue = function(string, radix) {
    var args, name, ref, stringToNumber;
    if (radix == null) {
      radix = 10;
    }
    name = string.replace(/^\+/, '').replace(/\//g, 'D').replace(/-/g, 'M').replace(/\+/g, 'P').replace(/\./g, '_').replace('I', 'i');
    ref = "__n" + (radix === 10 ? '' : radix) + "_" + name;
    stringToNumber = schemeNumberFunction('snum', 'string->number');
    args = radix === 10 ? "('" + string + "')" : "('" + string + "', " + radix + ")";
    Scope.root.assign(ref, stringToNumber + args);
    return ref;
  };

  multident = function(code, tab) {
    code = code.replace(/\n/g, '$&' + tab);
    return code.replace(/\s+$/, '');
  };

  parseNum = function(x) {
    if (x == null) {
      return 0;
    } else if (x.match(HEXNUM)) {
      return parseInt(x, 16);
    } else {
      return parseFloat(x);
    }
  };

  isLiteralArguments = function(node) {
    return node instanceof Literal && node.value === 'arguments' && !node.asKey;
  };

  isLiteralThis = function(node) {
    return (node instanceof Literal && node.value === 'this' && !node.asKey) || (node instanceof Code && node.bound) || (node instanceof Call && node.isSuper);
  };

  unfoldSoak = function(o, parent, name) {
    var ifn;
    if (!(ifn = parent[name].unfoldSoak(o))) {
      return;
    }
    parent[name] = ifn.body;
    ifn.body = new Value(parent);
    return ifn;
  };

}).call(this);

}).call(this,"/")
},{"./constant-fold":3,"./helpers":4,"./lexer":6,"./scope":11,"iced-runtime":20,"path":14}],8:[function(_dereq_,module,exports){
(function (process){
/* parser generated by jison 0.4.15 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,21],$V1=[1,50],$V2=[1,77],$V3=[1,75],$V4=[1,76],$V5=[1,54],$V6=[1,55],$V7=[1,56],$V8=[1,57],$V9=[1,58],$Va=[1,59],$Vb=[1,48],$Vc=[1,49],$Vd=[1,29],$Ve=[1,64],$Vf=[1,65],$Vg=[1,74],$Vh=[1,45],$Vi=[1,28],$Vj=[1,47],$Vk=[1,62],$Vl=[1,63],$Vm=[1,61],$Vn=[1,40],$Vo=[1,46],$Vp=[1,60],$Vq=[1,69],$Vr=[1,70],$Vs=[1,71],$Vt=[1,72],$Vu=[1,44],$Vv=[1,68],$Vw=[1,31],$Vx=[1,32],$Vy=[1,33],$Vz=[1,34],$VA=[1,35],$VB=[1,36],$VC=[1,37],$VD=[1,78],$VE=[1,6,29,106],$VF=[1,88],$VG=[1,81],$VH=[1,80],$VI=[1,79],$VJ=[1,82],$VK=[1,83],$VL=[1,84],$VM=[1,85],$VN=[1,86],$VO=[1,87],$VP=[1,91],$VQ=[1,6,28,29,52,57,60,76,81,90,95,97,106,108,109,110,114,122,130,133,134,139,140,141,142,143,144,145],$VR=[1,97],$VS=[1,98],$VT=[1,99],$VU=[1,100],$VV=[1,102],$VW=[1,103],$VX=[1,96],$VY=[2,114],$VZ=[1,6,28,29,52,57,60,69,70,71,72,74,76,77,81,88,89,90,95,97,106,108,109,110,114,122,130,133,134,139,140,141,142,143,144,145],$V_=[2,79],$V$=[1,108],$V01=[2,58],$V11=[1,112],$V21=[1,117],$V31=[1,118],$V41=[1,120],$V51=[1,6,28,29,43,52,57,60,69,70,71,72,74,76,77,81,88,89,90,95,97,106,108,109,110,114,122,130,133,134,139,140,141,142,143,144,145],$V61=[2,76],$V71=[1,6,29,52,57,60,76,81,90,95,97,106,108,109,110,114,122,130,133,134,139,140,141,142,143,144,145],$V81=[1,158],$V91=[1,160],$Va1=[1,155],$Vb1=[1,6,28,29,43,52,57,60,69,70,71,72,74,76,77,81,83,88,89,90,95,97,106,108,109,110,114,122,130,133,134,137,138,139,140,141,142,143,144,145,146],$Vc1=[2,96],$Vd1=[1,6,28,29,46,52,57,60,69,70,71,72,74,76,77,81,88,89,90,95,97,106,108,109,110,114,122,130,133,134,139,140,141,142,143,144,145],$Ve1=[1,6,28,29,43,46,52,57,60,69,70,71,72,74,76,77,81,83,88,89,90,95,97,106,108,109,110,114,120,121,122,130,133,134,137,138,139,140,141,142,143,144,145,146],$Vf1=[1,207],$Vg1=[1,206],$Vh1=[2,56],$Vi1=[1,217],$Vj1=[6,28,29,52,57],$Vk1=[6,28,29,43,52,57,60],$Vl1=[1,6,28,29,52,57,60,76,81,90,95,97,106,108,109,110,114,122,130,133,134,140,141,142,143,144,145],$Vm1=[1,6,28,29,52,57,60,76,81,90,95,97,106,108,109,110,114,122,130,133,134,140,142,143,144,145],$Vn1=[1,236],$Vo1=[1,6,28,29,52,57,60,76,81,90,95,97,106,108,109,110,114,122,130],$Vp1=[1,6,28,29,52,57,60,76,81,90,95,97,106,109,122,130],$Vq1=[2,135],$Vr1=[1,6,28,29,43,52,57,60,69,70,71,72,74,76,77,81,88,89,90,95,97,106,108,109,110,114,120,121,122,130,133,134,139,140,141,142,143,144,145],$Vs1=[1,245],$Vt1=[6,28,29,57,90,95],$Vu1=[1,6,28,29,52,57,60,76,81,90,95,97,106,122,130],$Vv1=[120,121],$Vw1=[57,120,121],$Vx1=[1,255],$Vy1=[6,28,29,57,81],$Vz1=[6,28,29,46,57,81],$VA1=[1,6,28,29,52,57,60,76,81,90,95,97,106,108,109,110,114,122,130,133,134,142,143,144,145],$VB1=[11,13,31,33,34,36,37,38,39,40,41,48,49,50,54,55,76,79,82,86,87,92,93,94,100,104,105,108,110,112,114,123,129,131,132,133,134,135,137,138],$VC1=[2,124],$VD1=[6,28,29],$VE1=[2,57],$VF1=[1,266],$VG1=[1,267],$VH1=[1,6,28,29,52,57,60,76,81,90,95,97,102,103,106,108,109,110,114,122,125,127,130,133,134,139,140,141,142,143,144,145],$VI1=[29,125,127],$VJ1=[1,6,29,52,57,60,76,81,90,95,97,106,109,122,130],$VK1=[2,71],$VL1=[1,289],$VM1=[1,290],$VN1=[1,6,28,29,52,57,60,76,81,90,95,97,106,108,109,110,114,122,125,130,133,134,139,140,141,142,143,144,145],$VO1=[1,6,28,29,52,57,60,76,81,90,95,97,106,108,110,114,122,130],$VP1=[1,300],$VQ1=[1,301],$VR1=[6,28,29,57],$VS1=[1,6,28,29,52,57,60,76,81,90,95,97,102,106,108,109,110,114,122,130,133,134,139,140,141,142,143,144,145],$VT1=[28,57];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"Root":3,"Body":4,"Line":5,"TERMINATOR":6,"Expression":7,"Statement":8,"Return":9,"Comment":10,"STATEMENT":11,"Await":12,"AWAIT":13,"Block":14,"Value":15,"Invocation":16,"Code":17,"Operation":18,"Assign":19,"If":20,"Try":21,"While":22,"For":23,"Switch":24,"Class":25,"Throw":26,"Defer":27,"INDENT":28,"OUTDENT":29,"Identifier":30,"IDENTIFIER":31,"AlphaNumeric":32,"NUMBER":33,"STRING":34,"Literal":35,"JS":36,"REGEX":37,"DEBUGGER":38,"UNDEFINED":39,"NULL":40,"BOOL":41,"Assignable":42,"=":43,"AssignObj":44,"ObjAssignable":45,":":46,"ThisProperty":47,"RETURN":48,"HERECOMMENT":49,"PARAM_START":50,"ParamList":51,"PARAM_END":52,"FuncGlyph":53,"->":54,"=>":55,"OptComma":56,",":57,"Param":58,"ParamVar":59,"...":60,"Array":61,"Object":62,"Splat":63,"SimpleAssignable":64,"Accessor":65,"Parenthetical":66,"Range":67,"This":68,".":69,"?.":70,"::":71,"?::":72,"Index":73,"INDEX_START":74,"IndexValue":75,"INDEX_END":76,"INDEX_SOAK":77,"Slice":78,"{":79,"AssignList":80,"}":81,"CLASS":82,"EXTENDS":83,"OptFuncExist":84,"Arguments":85,"SUPER":86,"DEFER":87,"FUNC_EXIST":88,"CALL_START":89,"CALL_END":90,"ArgList":91,"THIS":92,"@":93,"[":94,"]":95,"RangeDots":96,"..":97,"Arg":98,"SimpleArgs":99,"TRY":100,"Catch":101,"FINALLY":102,"CATCH":103,"THROW":104,"(":105,")":106,"WhileSource":107,"WHILE":108,"WHEN":109,"UNTIL":110,"Loop":111,"LOOP":112,"ForBody":113,"FOR":114,"ForStart":115,"ForSource":116,"ForVariables":117,"OWN":118,"ForValue":119,"FORIN":120,"FOROF":121,"BY":122,"SWITCH":123,"Whens":124,"ELSE":125,"When":126,"LEADING_WHEN":127,"IfBlock":128,"IF":129,"POST_IF":130,"UNARY":131,"UNARY_MATH":132,"-":133,"+":134,"YIELD":135,"FROM":136,"--":137,"++":138,"?":139,"MATH":140,"**":141,"SHIFT":142,"COMPARE":143,"LOGIC":144,"RELATION":145,"COMPOUND_ASSIGN":146,"$accept":0,"$end":1},
terminals_: {2:"error",6:"TERMINATOR",11:"STATEMENT",13:"AWAIT",28:"INDENT",29:"OUTDENT",31:"IDENTIFIER",33:"NUMBER",34:"STRING",36:"JS",37:"REGEX",38:"DEBUGGER",39:"UNDEFINED",40:"NULL",41:"BOOL",43:"=",46:":",48:"RETURN",49:"HERECOMMENT",50:"PARAM_START",52:"PARAM_END",54:"->",55:"=>",57:",",60:"...",69:".",70:"?.",71:"::",72:"?::",74:"INDEX_START",76:"INDEX_END",77:"INDEX_SOAK",79:"{",81:"}",82:"CLASS",83:"EXTENDS",86:"SUPER",87:"DEFER",88:"FUNC_EXIST",89:"CALL_START",90:"CALL_END",92:"THIS",93:"@",94:"[",95:"]",97:"..",100:"TRY",102:"FINALLY",103:"CATCH",104:"THROW",105:"(",106:")",108:"WHILE",109:"WHEN",110:"UNTIL",112:"LOOP",114:"FOR",118:"OWN",120:"FORIN",121:"FOROF",122:"BY",123:"SWITCH",125:"ELSE",127:"LEADING_WHEN",129:"IF",130:"POST_IF",131:"UNARY",132:"UNARY_MATH",133:"-",134:"+",135:"YIELD",136:"FROM",137:"--",138:"++",139:"?",140:"MATH",141:"**",142:"SHIFT",143:"COMPARE",144:"LOGIC",145:"RELATION",146:"COMPOUND_ASSIGN"},
productions_: [0,[3,0],[3,1],[4,1],[4,3],[4,2],[5,1],[5,1],[8,1],[8,1],[8,1],[8,1],[12,2],[12,2],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[14,2],[14,3],[30,1],[32,1],[32,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[19,3],[19,4],[19,5],[44,1],[44,3],[44,5],[44,1],[45,1],[45,1],[45,1],[9,2],[9,1],[10,1],[17,5],[17,2],[53,1],[53,1],[56,0],[56,1],[51,0],[51,1],[51,3],[51,4],[51,6],[58,1],[58,2],[58,3],[58,1],[59,1],[59,1],[59,1],[59,1],[63,2],[64,1],[64,2],[64,2],[64,1],[42,1],[42,1],[42,1],[15,1],[15,1],[15,1],[15,1],[15,1],[65,2],[65,2],[65,2],[65,2],[65,2],[65,1],[65,1],[73,3],[73,2],[75,1],[75,1],[62,4],[80,0],[80,1],[80,3],[80,4],[80,6],[25,1],[25,2],[25,3],[25,4],[25,2],[25,3],[25,4],[25,5],[16,3],[16,3],[16,1],[16,2],[27,2],[84,0],[84,1],[85,2],[85,4],[68,1],[68,1],[47,2],[61,2],[61,4],[96,1],[96,1],[67,5],[78,3],[78,2],[78,2],[78,1],[91,1],[91,3],[91,4],[91,4],[91,6],[98,1],[98,1],[98,1],[99,1],[99,3],[21,2],[21,3],[21,4],[21,5],[101,3],[101,3],[101,2],[26,2],[66,3],[66,5],[107,2],[107,4],[107,2],[107,4],[22,2],[22,2],[22,2],[22,1],[111,2],[111,2],[23,2],[23,2],[23,2],[113,2],[113,2],[115,2],[115,3],[119,1],[119,1],[119,1],[119,1],[117,1],[117,3],[116,2],[116,2],[116,4],[116,4],[116,4],[116,6],[116,6],[24,5],[24,7],[24,4],[24,6],[124,1],[124,2],[126,3],[126,4],[128,3],[128,5],[20,1],[20,3],[20,3],[20,3],[18,2],[18,2],[18,2],[18,2],[18,2],[18,2],[18,3],[18,2],[18,2],[18,2],[18,2],[18,2],[18,3],[18,3],[18,3],[18,3],[18,3],[18,3],[18,3],[18,3],[18,3],[18,5],[18,4],[18,3]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:
return this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Block);
break;
case 2:
return this.$ = $$[$0];
break;
case 3:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(yy.Block.wrap([$$[$0]]));
break;
case 4:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-2].push($$[$0]));
break;
case 5:
this.$ = $$[$0-1];
break;
case 6: case 7: case 8: case 9: case 11: case 14: case 15: case 16: case 17: case 18: case 19: case 20: case 21: case 22: case 23: case 24: case 25: case 26: case 32: case 45: case 46: case 47: case 48: case 56: case 57: case 67: case 68: case 69: case 70: case 75: case 76: case 79: case 83: case 90: case 135: case 136: case 138: case 167: case 168: case 184: case 190:
this.$ = $$[$0];
break;
case 10: case 29: case 33: case 35:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Literal($$[$0]));
break;
case 12:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Await($$[$0]));
break;
case 13:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Await(yy.Block.wrap([$$[$0]])));
break;
case 27:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Block);
break;
case 28: case 91:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-1]);
break;
case 30:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Literal($$[$0], 'Number'));
break;
case 31:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Literal($$[$0], 'String'));
break;
case 34:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Literal($$[$0], 'RegExp'));
break;
case 36:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Undefined);
break;
case 37:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Null);
break;
case 38:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Bool($$[$0]));
break;
case 39:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Assign($$[$0-2], $$[$0]));
break;
case 40:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Assign($$[$0-3], $$[$0]));
break;
case 41:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Assign($$[$0-4], $$[$0-1]));
break;
case 42: case 72: case 77: case 78: case 80: case 81: case 82: case 169: case 170:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value($$[$0]));
break;
case 43:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Assign(yy.addLocationDataFn(_$[$0-2])(new yy.Value($$[$0-2])), $$[$0], 'object'));
break;
case 44:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Assign(yy.addLocationDataFn(_$[$0-4])(new yy.Value($$[$0-4])), $$[$0-1], 'object'));
break;
case 49:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Return($$[$0]));
break;
case 50:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Return);
break;
case 51:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Comment($$[$0]));
break;
case 52:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Code($$[$0-3], $$[$0], $$[$0-1]));
break;
case 53:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Code([], $$[$0], $$[$0-1]));
break;
case 54:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])('func');
break;
case 55:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])('boundfunc');
break;
case 58: case 96:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])([]);
break;
case 59: case 97: case 130: case 171:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])([$$[$0]]);
break;
case 60: case 98: case 131:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-2].concat($$[$0]));
break;
case 61: case 99: case 132:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])($$[$0-3].concat($$[$0]));
break;
case 62: case 100: case 134:
this.$ = yy.addLocationDataFn(_$[$0-5], _$[$0])($$[$0-5].concat($$[$0-2]));
break;
case 63:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Param($$[$0]));
break;
case 64:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Param($$[$0-1], null, true));
break;
case 65:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Param($$[$0-2], $$[$0]));
break;
case 66: case 137:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Expansion);
break;
case 71:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Splat($$[$0-1]));
break;
case 73:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0-1].add($$[$0]));
break;
case 74:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Value($$[$0-1], [].concat($$[$0])));
break;
case 84:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Access($$[$0]));
break;
case 85:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Access($$[$0].setCustom()));
break;
case 86:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Access($$[$0], 'soak'));
break;
case 87:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])([yy.addLocationDataFn(_$[$0-1])(new yy.Access(new yy.Literal('prototype'))), yy.addLocationDataFn(_$[$0])(new yy.Access($$[$0]))]);
break;
case 88:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])([yy.addLocationDataFn(_$[$0-1])(new yy.Access(new yy.Literal('prototype'), 'soak')), yy.addLocationDataFn(_$[$0])(new yy.Access($$[$0]))]);
break;
case 89:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Access(new yy.Literal('prototype')));
break;
case 92:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(yy.extend($$[$0], {
          soak: true
        }));
break;
case 93:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Index($$[$0]));
break;
case 94:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Slice($$[$0]));
break;
case 95:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Obj($$[$0-2], $$[$0-3].generated));
break;
case 101:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Class);
break;
case 102:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Class(null, null, $$[$0]));
break;
case 103:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Class(null, $$[$0]));
break;
case 104:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Class(null, $$[$0-1], $$[$0]));
break;
case 105:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Class($$[$0]));
break;
case 106:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Class($$[$0-1], null, $$[$0]));
break;
case 107:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Class($$[$0-2], $$[$0]));
break;
case 108:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Class($$[$0-3], $$[$0-1], $$[$0]));
break;
case 109: case 110:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Call($$[$0-2], $$[$0], $$[$0-1]));
break;
case 111:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Call('super', [new yy.Splat(new yy.Literal('arguments'))]));
break;
case 112:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Call('super', $$[$0]));
break;
case 113:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Defer($$[$0], yylineno));
break;
case 114:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(false);
break;
case 115:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(true);
break;
case 116:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])([]);
break;
case 117: case 133:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])($$[$0-2]);
break;
case 118: case 119:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value(new yy.Literal('this')));
break;
case 120:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Value(yy.addLocationDataFn(_$[$0-1])(new yy.Literal('this')), [yy.addLocationDataFn(_$[$0])(new yy.Access($$[$0]))], 'this'));
break;
case 121:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Arr([]));
break;
case 122:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Arr($$[$0-2]));
break;
case 123:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])('inclusive');
break;
case 124:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])('exclusive');
break;
case 125:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Range($$[$0-3], $$[$0-1], $$[$0-2]));
break;
case 126:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Range($$[$0-2], $$[$0], $$[$0-1]));
break;
case 127:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Range($$[$0-1], null, $$[$0]));
break;
case 128:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Range(null, $$[$0], $$[$0-1]));
break;
case 129:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Range(null, null, $$[$0]));
break;
case 139:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([].concat($$[$0-2], $$[$0]));
break;
case 140:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Try($$[$0]));
break;
case 141:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Try($$[$0-1], $$[$0][0], $$[$0][1]));
break;
case 142:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Try($$[$0-2], null, null, $$[$0]));
break;
case 143:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Try($$[$0-3], $$[$0-2][0], $$[$0-2][1], $$[$0]));
break;
case 144:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([$$[$0-1], $$[$0]]);
break;
case 145:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([yy.addLocationDataFn(_$[$0-1])(new yy.Value($$[$0-1])), $$[$0]]);
break;
case 146:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])([null, $$[$0]]);
break;
case 147:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Throw($$[$0]));
break;
case 148:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])((function () {
        if ($$[$0-1] instanceof yy.Block && $$[$0-1].expressions.length === 1 && $$[$0-1].expressions[0].isLiteralConstant()) {
          return $$[$0-1].expressions[0];
        } else {
          return new yy.Parens($$[$0-1]);
        }
      }()));
break;
case 149:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])((function () {
        if ($$[$0-2] instanceof yy.Block && $$[$0-2].expressions.length === 1 && $$[$0-2].expressions[0].isLiteralConstant()) {
          return $$[$0-2].expressions[0];
        } else {
          return new yy.Parens($$[$0-2]);
        }
      }()));
break;
case 150:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.While($$[$0]));
break;
case 151:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.While($$[$0-2], {
          guard: $$[$0]
        }));
break;
case 152:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.While($$[$0], {
          invert: true
        }));
break;
case 153:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.While($$[$0-2], {
          invert: true,
          guard: $$[$0]
        }));
break;
case 154:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0-1].addBody($$[$0]));
break;
case 155: case 156:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0].addBody(yy.addLocationDataFn(_$[$0-1])(yy.Block.wrap([$$[$0-1]]))));
break;
case 157:
this.$ = yy.addLocationDataFn(_$[$0], _$[$0])($$[$0]);
break;
case 158:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.While(yy.addLocationDataFn(_$[$0-1])(new yy.Literal('true'))).addBody($$[$0]));
break;
case 159:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.While(yy.addLocationDataFn(_$[$0-1])(new yy.Literal('true'))).addBody(yy.addLocationDataFn(_$[$0])(yy.Block.wrap([$$[$0]]))));
break;
case 160: case 161:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.For($$[$0-1], $$[$0]));
break;
case 162:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.For($$[$0], $$[$0-1]));
break;
case 163:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])({
          source: yy.addLocationDataFn(_$[$0])(new yy.Value($$[$0]))
        });
break;
case 164:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])((function () {
        $$[$0].own = $$[$0-1].own;
        $$[$0].name = $$[$0-1][0];
        $$[$0].index = $$[$0-1][1];
        return $$[$0];
      }()));
break;
case 165:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0]);
break;
case 166:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])((function () {
        $$[$0].own = true;
        return $$[$0];
      }()));
break;
case 172:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([$$[$0-2], $$[$0]]);
break;
case 173:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])({
          source: $$[$0]
        });
break;
case 174:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])({
          source: $$[$0],
          object: true
        });
break;
case 175:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])({
          source: $$[$0-2],
          guard: $$[$0]
        });
break;
case 176:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])({
          source: $$[$0-2],
          guard: $$[$0],
          object: true
        });
break;
case 177:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])({
          source: $$[$0-2],
          step: $$[$0]
        });
break;
case 178:
this.$ = yy.addLocationDataFn(_$[$0-5], _$[$0])({
          source: $$[$0-4],
          guard: $$[$0-2],
          step: $$[$0]
        });
break;
case 179:
this.$ = yy.addLocationDataFn(_$[$0-5], _$[$0])({
          source: $$[$0-4],
          step: $$[$0-2],
          guard: $$[$0]
        });
break;
case 180:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Switch($$[$0-3], $$[$0-1]));
break;
case 181:
this.$ = yy.addLocationDataFn(_$[$0-6], _$[$0])(new yy.Switch($$[$0-5], $$[$0-3], $$[$0-1]));
break;
case 182:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Switch(null, $$[$0-1]));
break;
case 183:
this.$ = yy.addLocationDataFn(_$[$0-5], _$[$0])(new yy.Switch(null, $$[$0-3], $$[$0-1]));
break;
case 185:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0-1].concat($$[$0]));
break;
case 186:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([[$$[$0-1], $$[$0]]]);
break;
case 187:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])([[$$[$0-2], $$[$0-1]]]);
break;
case 188:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.If($$[$0-1], $$[$0], {
          type: $$[$0-2]
        }));
break;
case 189:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])($$[$0-4].addElse(yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.If($$[$0-1], $$[$0], {
          type: $$[$0-2]
        }))));
break;
case 191:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-2].addElse($$[$0]));
break;
case 192: case 193:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.If($$[$0], yy.addLocationDataFn(_$[$0-2])(yy.Block.wrap([$$[$0-2]])), {
          type: $$[$0-1],
          statement: true
        }));
break;
case 194: case 195: case 198: case 199:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op($$[$0-1], $$[$0]));
break;
case 196:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])((function () {
        var result;
        if ($$[$0].isNumber()) {
          result = yy.ConstantFold.negate($$[$0].base.value);
          if (result) {
            return new yy.Value(new yy.Literal(result, 'Number'));
          }
        }
        return new yy.Op('-', $$[$0]);
      }()));
break;
case 197:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])((function () {
        if ($$[$0].isNumber()) {
          return $$[$0];
        } else {
          return new yy.Op('+', $$[$0]);
        }
      }()));
break;
case 200:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Op($$[$0-2].concat($$[$0-1]), $$[$0]));
break;
case 201:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('--', $$[$0]));
break;
case 202:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('++', $$[$0]));
break;
case 203:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('--', $$[$0-1], null, true));
break;
case 204:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('++', $$[$0-1], null, true));
break;
case 205:
this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Existence($$[$0-1]));
break;
case 206:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])((function () {
        var kind, result;
        if ($$[$0-2].isNumberOrString() && $$[$0].isNumberOrString()) {
          result = yy.ConstantFold.add($$[$0-2].base.value, $$[$0].base.value);
          if (result) {
            kind = /^['"]/.test(result) ? 'String' : 'Number';
            return new yy.Value(new yy.Literal(result, kind));
          }
        }
        return new yy.Op('+', $$[$0-2], $$[$0]);
      }()));
break;
case 207:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])((function () {
        var result;
        if ($$[$0-2].isNumber() && $$[$0].isNumber()) {
          result = yy.ConstantFold.sub($$[$0-2].base.value, $$[$0].base.value);
          if (result) {
            return new yy.Value(new yy.Literal(result, 'Number'));
          }
        }
        return new yy.Op('-', $$[$0-2], $$[$0]);
      }()));
break;
case 208:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])((function () {
        var result;
        if ($$[$0-2].isNumber() && $$[$0].isNumber()) {
          if ($$[$0-1] === '/') {
            result = yy.ConstantFold.div($$[$0-2].base.value, $$[$0].base.value);
            if (result) {
              return new yy.Value(new yy.Literal(result, 'Number'));
            }
          }
        }
        return new yy.Op($$[$0-1], $$[$0-2], $$[$0]);
      }()));
break;
case 209: case 210: case 211: case 212:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Op($$[$0-1], $$[$0-2], $$[$0]));
break;
case 213:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])((function () {
        if ($$[$0-1].charAt(0) === '!') {
          return new yy.Op($$[$0-1].slice(1), $$[$0-2], $$[$0]).invert();
        } else {
          return new yy.Op($$[$0-1], $$[$0-2], $$[$0]);
        }
      }()));
break;
case 214:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Assign($$[$0-2], $$[$0], $$[$0-1]));
break;
case 215:
this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Assign($$[$0-4], $$[$0-1], $$[$0-3]));
break;
case 216:
this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Assign($$[$0-3], $$[$0], $$[$0-2]));
break;
case 217:
this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Extends($$[$0-2], $$[$0]));
break;
}
},
table: [{1:[2,1],3:1,4:2,5:3,7:4,8:5,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{1:[3]},{1:[2,2],6:$VD},o($VE,[2,3]),o($VE,[2,6],{115:73,107:89,113:90,108:$Vq,110:$Vr,114:$Vt,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($VE,[2,7],{115:73,107:92,113:93,108:$Vq,110:$Vr,114:$Vt,130:$VP}),o($VQ,[2,14],{84:94,65:95,73:101,69:$VR,70:$VS,71:$VT,72:$VU,74:$VV,77:$VW,88:$VX,89:$VY}),o($VQ,[2,15],{73:101,84:104,65:105,69:$VR,70:$VS,71:$VT,72:$VU,74:$VV,77:$VW,88:$VX,89:$VY}),o($VQ,[2,16]),o($VQ,[2,17]),o($VQ,[2,18]),o($VQ,[2,19]),o($VQ,[2,20]),o($VQ,[2,21]),o($VQ,[2,22]),o($VQ,[2,23]),o($VQ,[2,24]),o($VQ,[2,25]),o($VQ,[2,26]),o($VQ,[2,8]),o($VQ,[2,9]),o($VQ,[2,10]),o($VQ,[2,11]),o($VZ,$V_,{43:[1,106]}),o($VZ,[2,80]),o($VZ,[2,81]),o($VZ,[2,82]),o($VZ,[2,83]),o([1,6,28,29,52,57,60,69,70,71,72,74,76,77,81,88,90,95,97,106,108,109,110,114,122,130,133,134,139,140,141,142,143,144,145],[2,111],{85:107,89:$V$}),o([6,28,52,57],$V01,{51:109,58:110,59:111,30:113,47:114,61:115,62:116,31:$V2,60:$V11,79:$Vg,93:$V21,94:$V31}),{14:119,28:$V41},{7:121,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:123,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:124,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:125,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:127,8:126,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,136:[1,128],137:$VB,138:$VC},{15:130,16:131,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:132,47:67,61:51,62:52,64:129,66:25,67:26,68:27,79:$Vg,86:$Vi,92:$Vk,93:$Vl,94:$Vm,105:$Vp},{15:130,16:131,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:132,47:67,61:51,62:52,64:133,66:25,67:26,68:27,79:$Vg,86:$Vi,92:$Vk,93:$Vl,94:$Vm,105:$Vp},o($V51,$V61,{83:[1,137],137:[1,134],138:[1,135],146:[1,136]}),o($VQ,[2,190],{125:[1,138]}),{14:139,28:$V41},{14:140,28:$V41},o($VQ,[2,157]),{14:141,28:$V41},{7:142,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,143],30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($V71,[2,101],{35:24,66:25,67:26,68:27,61:51,62:52,32:53,30:66,47:67,15:130,16:131,42:132,14:144,64:146,28:$V41,31:$V2,33:$V3,34:$V4,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,79:$Vg,83:[1,145],86:$Vi,92:$Vk,93:$Vl,94:$Vm,105:$Vp}),{7:147,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{85:148,89:$V$},o([1,6,28,29,52,57,60,76,81,90,95,97,106,108,109,110,114,122,130,139,140,141,142,143,144,145],[2,50],{15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,9:19,10:20,12:22,42:23,35:24,66:25,67:26,68:27,53:30,64:38,128:39,107:41,111:42,113:43,61:51,62:52,32:53,30:66,47:67,115:73,8:122,7:149,11:$V0,13:$V1,31:$V2,33:$V3,34:$V4,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,48:$Vb,49:$Vc,50:$Vd,54:$Ve,55:$Vf,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,112:$Vs,123:$Vu,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC}),o($VQ,[2,51]),{7:151,8:122,9:19,10:20,11:$V0,12:22,13:$V1,14:150,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:$V41,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($V51,[2,77]),o($V51,[2,78]),o($VZ,[2,32]),o($VZ,[2,33]),o($VZ,[2,34]),o($VZ,[2,35]),o($VZ,[2,36]),o($VZ,[2,37]),o($VZ,[2,38]),{4:152,5:3,7:4,8:5,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,153],30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:154,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:$V81,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,60:$V91,61:51,62:52,63:159,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,91:156,92:$Vk,93:$Vl,94:$Vm,95:$Va1,98:157,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($VZ,[2,118]),o($VZ,[2,119],{30:161,31:$V2}),{28:[2,54]},{28:[2,55]},o($Vb1,[2,72]),o($Vb1,[2,75]),{7:162,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:163,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:164,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:166,8:122,9:19,10:20,11:$V0,12:22,13:$V1,14:165,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:$V41,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{30:171,31:$V2,47:172,61:173,62:174,67:167,79:$Vg,93:$V21,94:$Vm,117:168,118:[1,169],119:170},{116:175,120:[1,176],121:[1,177]},o([6,28,57,81],$Vc1,{80:178,44:179,45:180,10:181,30:182,32:183,47:184,31:$V2,33:$V3,34:$V4,49:$Vc,93:$V21}),o($Vd1,[2,30]),o($Vd1,[2,31]),o($Ve1,[2,29]),o($VE,[2,5],{7:4,8:5,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,9:19,10:20,12:22,42:23,35:24,66:25,67:26,68:27,53:30,64:38,128:39,107:41,111:42,113:43,61:51,62:52,32:53,30:66,47:67,115:73,5:185,11:$V0,13:$V1,31:$V2,33:$V3,34:$V4,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,48:$Vb,49:$Vc,50:$Vd,54:$Ve,55:$Vf,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,108:$Vq,110:$Vr,112:$Vs,114:$Vt,123:$Vu,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC}),o($VQ,[2,205]),{7:186,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:187,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:188,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:189,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:190,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:191,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:192,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:193,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:194,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($VQ,[2,156]),o($VQ,[2,161]),{7:195,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($VQ,[2,155]),o($VQ,[2,160]),{85:196,89:$V$},o($Vb1,[2,73]),{89:[2,115]},{27:198,30:197,31:$V2,87:$Vj},{30:199,31:$V2},o($Vb1,[2,89],{30:200,31:$V2}),{30:201,31:$V2},o($Vb1,[2,90]),{7:203,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,60:$Vf1,61:51,62:52,64:38,66:25,67:26,68:27,75:202,78:204,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,96:205,97:$Vg1,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{73:208,74:$VV,77:$VW},{85:209,89:$V$},o($Vb1,[2,74]),{6:[1,211],7:210,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,212],30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($VZ,[2,112]),{7:215,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:$V81,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,60:$V91,61:51,62:52,63:159,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,90:[1,213],91:214,92:$Vk,93:$Vl,94:$Vm,98:157,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o([6,28],$Vh1,{56:218,52:[1,216],57:$Vi1}),o($Vj1,[2,59]),o($Vj1,[2,63],{43:[1,220],60:[1,219]}),o($Vj1,[2,66]),o($Vk1,[2,67]),o($Vk1,[2,68]),o($Vk1,[2,69]),o($Vk1,[2,70]),{30:161,31:$V2},{7:215,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:$V81,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,60:$V91,61:51,62:52,63:159,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,91:156,92:$Vk,93:$Vl,94:$Vm,95:$Va1,98:157,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($VQ,[2,53]),{4:222,5:3,7:4,8:5,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,29:[1,221],30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($Vl1,[2,194],{115:73,107:89,113:90,139:$VI}),{107:92,108:$Vq,110:$Vr,113:93,114:$Vt,115:73,130:$VP},o($Vm1,[2,195],{115:73,107:89,113:90,139:$VI,141:$VK}),o($Vm1,[2,196],{115:73,107:89,113:90,139:$VI,141:$VK}),o($Vm1,[2,197],{115:73,107:89,113:90,139:$VI,141:$VK}),o($VQ,[2,198],{115:73,107:92,113:93}),o($Vl1,[2,199],{115:73,107:89,113:90,139:$VI}),{7:223,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($VQ,[2,201],{69:$V61,70:$V61,71:$V61,72:$V61,74:$V61,77:$V61,88:$V61,89:$V61}),{65:95,69:$VR,70:$VS,71:$VT,72:$VU,73:101,74:$VV,77:$VW,84:94,88:$VX,89:$VY},{65:105,69:$VR,70:$VS,71:$VT,72:$VU,73:101,74:$VV,77:$VW,84:104,88:$VX,89:$VY},o([69,70,71,72,74,77,88,89],$V_),o($VQ,[2,202],{69:$V61,70:$V61,71:$V61,72:$V61,74:$V61,77:$V61,88:$V61,89:$V61}),o($VQ,[2,203]),o($VQ,[2,204]),{6:[1,226],7:224,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,225],30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:227,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{14:228,28:$V41,129:[1,229]},o($VQ,[2,140],{101:230,102:[1,231],103:[1,232]}),o($VQ,[2,154]),o($VQ,[2,162]),{28:[1,233],107:89,108:$Vq,110:$Vr,113:90,114:$Vt,115:73,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO},{124:234,126:235,127:$Vn1},o($VQ,[2,102]),{7:237,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($V71,[2,105],{14:238,28:$V41,69:$V61,70:$V61,71:$V61,72:$V61,74:$V61,77:$V61,88:$V61,89:$V61,83:[1,239]}),o($Vo1,[2,147],{115:73,107:89,113:90,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($Vb1,[2,113]),o($Vo1,[2,49],{115:73,107:89,113:90,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($VQ,[2,12]),o($Vp1,[2,13],{115:73,107:89,113:90,108:$Vq,110:$Vr,114:$Vt,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),{6:$VD,106:[1,240]},{4:241,5:3,7:4,8:5,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o([6,28,57,95],$Vq1,{115:73,107:89,113:90,96:242,60:[1,243],97:$Vg1,108:$Vq,110:$Vr,114:$Vt,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($Vr1,[2,121]),o([6,28,95],$Vh1,{56:244,57:$Vs1}),o($Vt1,[2,130]),{7:215,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:$V81,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,60:$V91,61:51,62:52,63:159,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,91:246,92:$Vk,93:$Vl,94:$Vm,98:157,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($Vt1,[2,136]),o($Vt1,[2,137]),o($Ve1,[2,120]),{14:247,28:$V41,107:89,108:$Vq,110:$Vr,113:90,114:$Vt,115:73,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO},o($Vu1,[2,150],{115:73,107:89,113:90,108:$Vq,109:[1,248],110:$Vr,114:$Vt,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($Vu1,[2,152],{115:73,107:89,113:90,108:$Vq,109:[1,249],110:$Vr,114:$Vt,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($VQ,[2,158]),o($Vp1,[2,159],{115:73,107:89,113:90,108:$Vq,110:$Vr,114:$Vt,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($VQ,[2,163]),o($Vv1,[2,165]),{30:171,31:$V2,47:172,61:173,62:174,79:$Vg,93:$V21,94:$V31,117:250,119:170},o($Vv1,[2,171],{57:[1,251]}),o($Vw1,[2,167]),o($Vw1,[2,168]),o($Vw1,[2,169]),o($Vw1,[2,170]),o($VQ,[2,164]),{7:252,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:253,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o([6,28,81],$Vh1,{56:254,57:$Vx1}),o($Vy1,[2,97]),o($Vy1,[2,42],{46:[1,256]}),o($Vy1,[2,45]),o($Vz1,[2,46]),o($Vz1,[2,47]),o($Vz1,[2,48]),o($VE,[2,4]),o($VA1,[2,206],{115:73,107:89,113:90,139:$VI,140:$VJ,141:$VK}),o($VA1,[2,207],{115:73,107:89,113:90,139:$VI,140:$VJ,141:$VK}),o($Vm1,[2,208],{115:73,107:89,113:90,139:$VI,141:$VK}),o($Vm1,[2,209],{115:73,107:89,113:90,139:$VI,141:$VK}),o([1,6,28,29,52,57,60,76,81,90,95,97,106,108,109,110,114,122,130,142,143,144,145],[2,210],{115:73,107:89,113:90,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK}),o([1,6,28,29,52,57,60,76,81,90,95,97,106,108,109,110,114,122,130,143,144],[2,211],{115:73,107:89,113:90,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,145:$VO}),o([1,6,28,29,52,57,60,76,81,90,95,97,106,108,109,110,114,122,130,144],[2,212],{115:73,107:89,113:90,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,145:$VO}),o([1,6,28,29,52,57,60,76,81,90,95,97,106,108,109,110,114,122,130,143,144,145],[2,213],{115:73,107:89,113:90,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL}),o($Vp1,[2,193],{115:73,107:89,113:90,108:$Vq,110:$Vr,114:$Vt,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($Vp1,[2,192],{115:73,107:89,113:90,108:$Vq,110:$Vr,114:$Vt,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($VZ,[2,109]),o($Vb1,[2,84]),o($Vb1,[2,85]),o($Vb1,[2,86]),o($Vb1,[2,87]),o($Vb1,[2,88]),{76:[1,257]},{60:$Vf1,76:[2,93],96:258,97:$Vg1,107:89,108:$Vq,110:$Vr,113:90,114:$Vt,115:73,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO},{76:[2,94]},{7:259,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,76:[2,129],79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($VB1,[2,123]),o($VB1,$VC1),o($Vb1,[2,92]),o($VZ,[2,110]),o($Vo1,[2,39],{115:73,107:89,113:90,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),{7:260,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:261,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($Vb1,[2,116]),o([6,28,90],$Vh1,{56:262,57:$Vs1}),o($Vt1,$Vq1,{115:73,107:89,113:90,60:[1,263],108:$Vq,110:$Vr,114:$Vt,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),{53:264,54:$Ve,55:$Vf},o($VD1,$VE1,{59:111,30:113,47:114,61:115,62:116,58:265,31:$V2,60:$V11,79:$Vg,93:$V21,94:$V31}),{6:$VF1,28:$VG1},o($Vj1,[2,64]),{7:268,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($VH1,[2,27]),{6:$VD,29:[1,269]},o($Vl1,[2,200],{115:73,107:89,113:90,139:$VI}),o($Vo1,[2,214],{115:73,107:89,113:90,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),{7:270,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:271,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($Vo1,[2,217],{115:73,107:89,113:90,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($VQ,[2,191]),{7:272,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($VQ,[2,141],{102:[1,273]}),{14:274,28:$V41},{14:277,28:$V41,30:275,31:$V2,62:276,79:$Vg},{124:278,126:235,127:$Vn1},{29:[1,279],125:[1,280],126:281,127:$Vn1},o($VI1,[2,184]),{7:283,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,99:282,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($VJ1,[2,103],{115:73,107:89,113:90,14:284,28:$V41,108:$Vq,110:$Vr,114:$Vt,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($VQ,[2,106]),{7:285,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($VZ,[2,148]),{6:$VD,29:[1,286]},{7:287,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o([11,13,31,33,34,36,37,38,39,40,41,48,49,50,54,55,79,82,86,87,92,93,94,100,104,105,108,110,112,114,123,129,131,132,133,134,135,137,138],$VC1,{6:$VK1,28:$VK1,57:$VK1,95:$VK1}),{6:$VL1,28:$VM1,95:[1,288]},o([6,28,29,90,95],$VE1,{15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,9:19,10:20,12:22,42:23,35:24,66:25,67:26,68:27,53:30,64:38,128:39,107:41,111:42,113:43,61:51,62:52,32:53,30:66,47:67,115:73,8:122,63:159,7:215,98:291,11:$V0,13:$V1,31:$V2,33:$V3,34:$V4,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,48:$Vb,49:$Vc,50:$Vd,54:$Ve,55:$Vf,60:$V91,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,108:$Vq,110:$Vr,112:$Vs,114:$Vt,123:$Vu,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC}),o($VD1,$Vh1,{56:292,57:$Vs1}),o($VN1,[2,188]),{7:293,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:294,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($Vv1,[2,166]),{30:171,31:$V2,47:172,61:173,62:174,79:$Vg,93:$V21,94:$V31,119:295},o([1,6,28,29,52,57,60,76,81,90,95,97,106,108,110,114,130],[2,173],{115:73,107:89,113:90,109:[1,296],122:[1,297],133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($VO1,[2,174],{115:73,107:89,113:90,109:[1,298],133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),{6:$VP1,28:$VQ1,81:[1,299]},o([6,28,29,81],$VE1,{45:180,10:181,30:182,32:183,47:184,44:302,31:$V2,33:$V3,34:$V4,49:$Vc,93:$V21}),{7:303,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,304],30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($Vb1,[2,91]),{7:305,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,76:[2,127],79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{76:[2,128],107:89,108:$Vq,110:$Vr,113:90,114:$Vt,115:73,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO},o($Vo1,[2,40],{115:73,107:89,113:90,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),{29:[1,306],107:89,108:$Vq,110:$Vr,113:90,114:$Vt,115:73,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO},{6:$VL1,28:$VM1,90:[1,307]},o($Vt1,$VK1),{14:308,28:$V41},o($Vj1,[2,60]),{30:113,31:$V2,47:114,58:309,59:111,60:$V11,61:115,62:116,79:$Vg,93:$V21,94:$V31},o($VR1,$V01,{58:110,59:111,30:113,47:114,61:115,62:116,51:310,31:$V2,60:$V11,79:$Vg,93:$V21,94:$V31}),o($Vj1,[2,65],{115:73,107:89,113:90,108:$Vq,110:$Vr,114:$Vt,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($VH1,[2,28]),{29:[1,311],107:89,108:$Vq,110:$Vr,113:90,114:$Vt,115:73,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO},o($Vo1,[2,216],{115:73,107:89,113:90,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),{14:312,28:$V41,107:89,108:$Vq,110:$Vr,113:90,114:$Vt,115:73,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO},{14:313,28:$V41},o($VQ,[2,142]),{14:314,28:$V41},{14:315,28:$V41},o($VS1,[2,146]),{29:[1,316],125:[1,317],126:281,127:$Vn1},o($VQ,[2,182]),{14:318,28:$V41},o($VI1,[2,185]),{14:319,28:$V41,57:[1,320]},o($VT1,[2,138],{115:73,107:89,113:90,108:$Vq,110:$Vr,114:$Vt,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($VQ,[2,104]),o($VJ1,[2,107],{115:73,107:89,113:90,14:321,28:$V41,108:$Vq,110:$Vr,114:$Vt,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),{106:[1,322]},{95:[1,323],107:89,108:$Vq,110:$Vr,113:90,114:$Vt,115:73,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO},o($Vr1,[2,122]),{7:215,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,60:$V91,61:51,62:52,63:159,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,98:324,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:215,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:$V81,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,60:$V91,61:51,62:52,63:159,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,91:325,92:$Vk,93:$Vl,94:$Vm,98:157,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($Vt1,[2,131]),{6:$VL1,28:$VM1,29:[1,326]},o($Vp1,[2,151],{115:73,107:89,113:90,108:$Vq,110:$Vr,114:$Vt,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($Vp1,[2,153],{115:73,107:89,113:90,108:$Vq,110:$Vr,114:$Vt,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($Vv1,[2,172]),{7:327,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:328,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:329,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($Vr1,[2,95]),{10:181,30:182,31:$V2,32:183,33:$V3,34:$V4,44:330,45:180,47:184,49:$Vc,93:$V21},o($VR1,$Vc1,{44:179,45:180,10:181,30:182,32:183,47:184,80:331,31:$V2,33:$V3,34:$V4,49:$Vc,93:$V21}),o($Vy1,[2,98]),o($Vy1,[2,43],{115:73,107:89,113:90,108:$Vq,110:$Vr,114:$Vt,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),{7:332,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{76:[2,126],107:89,108:$Vq,110:$Vr,113:90,114:$Vt,115:73,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO},o($VQ,[2,41]),o($Vb1,[2,117]),o($VQ,[2,52]),o($Vj1,[2,61]),o($VD1,$Vh1,{56:333,57:$Vi1}),o($VQ,[2,215]),o($VN1,[2,189]),o($VQ,[2,143]),o($VS1,[2,144]),o($VS1,[2,145]),o($VQ,[2,180]),{14:334,28:$V41},{29:[1,335]},o($VI1,[2,186],{6:[1,336]}),{7:337,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},o($VQ,[2,108]),o($VZ,[2,149]),o($VZ,[2,125]),o($Vt1,[2,132]),o($VD1,$Vh1,{56:338,57:$Vs1}),o($Vt1,[2,133]),o([1,6,28,29,52,57,60,76,81,90,95,97,106,108,109,110,114,130],[2,175],{115:73,107:89,113:90,122:[1,339],133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($VO1,[2,177],{115:73,107:89,113:90,109:[1,340],133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($Vo1,[2,176],{115:73,107:89,113:90,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($Vy1,[2,99]),o($VD1,$Vh1,{56:341,57:$Vx1}),{29:[1,342],107:89,108:$Vq,110:$Vr,113:90,114:$Vt,115:73,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO},{6:$VF1,28:$VG1,29:[1,343]},{29:[1,344]},o($VQ,[2,183]),o($VI1,[2,187]),o($VT1,[2,139],{115:73,107:89,113:90,108:$Vq,110:$Vr,114:$Vt,130:$VF,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),{6:$VL1,28:$VM1,29:[1,345]},{7:346,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{7:347,8:122,9:19,10:20,11:$V0,12:22,13:$V1,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:$V2,32:53,33:$V3,34:$V4,35:24,36:$V5,37:$V6,38:$V7,39:$V8,40:$V9,41:$Va,42:23,47:67,48:$Vb,49:$Vc,50:$Vd,53:30,54:$Ve,55:$Vf,61:51,62:52,64:38,66:25,67:26,68:27,79:$Vg,82:$Vh,86:$Vi,87:$Vj,92:$Vk,93:$Vl,94:$Vm,100:$Vn,104:$Vo,105:$Vp,107:41,108:$Vq,110:$Vr,111:42,112:$Vs,113:43,114:$Vt,115:73,123:$Vu,128:39,129:$Vv,131:$Vw,132:$Vx,133:$Vy,134:$Vz,135:$VA,137:$VB,138:$VC},{6:$VP1,28:$VQ1,29:[1,348]},o($Vy1,[2,44]),o($Vj1,[2,62]),o($VQ,[2,181]),o($Vt1,[2,134]),o($Vo1,[2,178],{115:73,107:89,113:90,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($Vo1,[2,179],{115:73,107:89,113:90,133:$VG,134:$VH,139:$VI,140:$VJ,141:$VK,142:$VL,143:$VM,144:$VN,145:$VO}),o($Vy1,[2,100])],
defaultActions: {64:[2,54],65:[2,55],96:[2,115],204:[2,94]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        throw new Error(str);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        function lex() {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof _dereq_ !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = _dereq_('fs').readFileSync(_dereq_('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && _dereq_.main === module) {
  exports.main(process.argv.slice(1));
}
}
}).call(this,_dereq_("FWaASH"))
},{"FWaASH":15,"fs":13,"path":14}],9:[function(_dereq_,module,exports){
// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var CoffeeScript, Module, binary, child_process, ext, findExtension, fork, helpers, loadFile, path, _i, _len, _ref;

  CoffeeScript = _dereq_('./coffee-script');

  child_process = _dereq_('child_process');

  helpers = _dereq_('./helpers');

  path = _dereq_('path');

  loadFile = function(module, filename) {
    var answer;
    answer = CoffeeScript._compileFile(filename, false, {
      runtime: "interp"
    });
    return module._compile(answer, filename);
  };

  if (_dereq_.extensions) {
    _ref = CoffeeScript.FILE_EXTENSIONS;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ext = _ref[_i];
      _dereq_.extensions[ext] = loadFile;
    }
    Module = _dereq_('module');
    findExtension = function(filename) {
      var curExtension, extensions;
      extensions = path.basename(filename).split('.');
      if (extensions[0] === '') {
        extensions.shift();
      }
      while (extensions.shift()) {
        curExtension = '.' + extensions.join('.');
        if (Module._extensions[curExtension]) {
          return curExtension;
        }
      }
      return '.js';
    };
    Module.prototype.load = function(filename) {
      var extension;
      this.filename = filename;
      this.paths = Module._nodeModulePaths(path.dirname(filename));
      extension = findExtension(filename);
      Module._extensions[extension](this, filename);
      return this.loaded = true;
    };
  }

  if (child_process) {
    fork = child_process.fork;
    binary = _dereq_.resolve('../../bin/coffee');
    child_process.fork = function(path, args, options) {
      if (helpers.isCoffee(path)) {
        if (!Array.isArray(args)) {
          options = args || {};
          args = [];
        }
        args = [path].concat(args);
        path = binary;
      }
      return fork(path, args, options);
    };
  }

}).call(this);

},{"./coffee-script":2,"./helpers":4,"child_process":13,"module":13,"path":14}],10:[function(_dereq_,module,exports){
// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var BALANCED_PAIRS, CALL_CLOSERS, EXPRESSION_CLOSE, EXPRESSION_END, EXPRESSION_START, IMPLICIT_CALL, IMPLICIT_END, IMPLICIT_FUNC, IMPLICIT_UNSPACED_CALL, INVERSES, LINEBREAKS, SINGLE_CLOSERS, SINGLE_LINERS, generate, left, rite, _i, _len, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  generate = function(tag, value, origin) {
    var tok;
    tok = [tag, value];
    tok.generated = true;
    if (origin) {
      tok.origin = origin;
    }
    return tok;
  };

  exports.Rewriter = (function() {
    function Rewriter() {}

    Rewriter.prototype.rewrite = function(tokens) {
      this.tokens = tokens;
      this.removeLeadingNewlines();
      this.closeOpenCalls();
      this.closeOpenIndexes();
      this.normalizeLines();
      this.tagPostfixConditionals();
      this.addImplicitBracesAndParens();
      this.addLocationDataToGeneratedTokens();
      return this.tokens;
    };

    Rewriter.prototype.scanTokens = function(block) {
      var i, token, tokens;
      tokens = this.tokens;
      i = 0;
      while (token = tokens[i]) {
        i += block.call(this, token, i, tokens);
      }
      return true;
    };

    Rewriter.prototype.detectEnd = function(i, condition, action) {
      var levels, token, tokens, _ref, _ref1;
      tokens = this.tokens;
      levels = 0;
      while (token = tokens[i]) {
        if (levels === 0 && condition.call(this, token, i)) {
          return action.call(this, token, i);
        }
        if (!token || levels < 0) {
          return action.call(this, token, i - 1);
        }
        if (_ref = token[0], __indexOf.call(EXPRESSION_START, _ref) >= 0) {
          levels += 1;
        } else if (_ref1 = token[0], __indexOf.call(EXPRESSION_END, _ref1) >= 0) {
          levels -= 1;
        }
        i += 1;
      }
      return i - 1;
    };

    Rewriter.prototype.removeLeadingNewlines = function() {
      var i, tag, _i, _len, _ref;
      _ref = this.tokens;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        tag = _ref[i][0];
        if (tag !== 'TERMINATOR') {
          break;
        }
      }
      if (i) {
        return this.tokens.splice(0, i);
      }
    };

    Rewriter.prototype.closeOpenCalls = function() {
      var action, condition;
      condition = function(token, i) {
        var _ref;
        return ((_ref = token[0]) === ')' || _ref === 'CALL_END') || token[0] === 'OUTDENT' && this.tag(i - 1) === ')';
      };
      action = function(token, i) {
        return this.tokens[token[0] === 'OUTDENT' ? i - 1 : i][0] = 'CALL_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'CALL_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.closeOpenIndexes = function() {
      var action, condition;
      condition = function(token, i) {
        var _ref;
        return (_ref = token[0]) === ']' || _ref === 'INDEX_END';
      };
      action = function(token, i) {
        return token[0] = 'INDEX_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'INDEX_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.matchTags = function() {
      var fuzz, i, j, pattern, _i, _ref, _ref1;
      i = arguments[0], pattern = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      fuzz = 0;
      for (j = _i = 0, _ref = pattern.length; 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        while (this.tag(i + j + fuzz) === 'HERECOMMENT') {
          fuzz += 2;
        }
        if (pattern[j] == null) {
          continue;
        }
        if (typeof pattern[j] === 'string') {
          pattern[j] = [pattern[j]];
        }
        if (_ref1 = this.tag(i + j + fuzz), __indexOf.call(pattern[j], _ref1) < 0) {
          return false;
        }
      }
      return true;
    };

    Rewriter.prototype.looksObjectish = function(j) {
      return this.matchTags(j, '@', null, ':') || this.matchTags(j, null, ':');
    };

    Rewriter.prototype.findTagsBackwards = function(i, tags) {
      var backStack, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      backStack = [];
      while (i >= 0 && (backStack.length || (_ref2 = this.tag(i), __indexOf.call(tags, _ref2) < 0) && ((_ref3 = this.tag(i), __indexOf.call(EXPRESSION_START, _ref3) < 0) || this.tokens[i].generated) && (_ref4 = this.tag(i), __indexOf.call(LINEBREAKS, _ref4) < 0))) {
        if (_ref = this.tag(i), __indexOf.call(EXPRESSION_END, _ref) >= 0) {
          backStack.push(this.tag(i));
        }
        if ((_ref1 = this.tag(i), __indexOf.call(EXPRESSION_START, _ref1) >= 0) && backStack.length) {
          backStack.pop();
        }
        i -= 1;
      }
      return _ref5 = this.tag(i), __indexOf.call(tags, _ref5) >= 0;
    };

    Rewriter.prototype.addImplicitBracesAndParens = function() {
      var stack;
      stack = [];
      return this.scanTokens(function(token, i, tokens) {
        var endImplicitCall, endImplicitObject, forward, inImplicit, inImplicitCall, inImplicitControl, inImplicitObject, newLine, nextTag, offset, prevTag, prevToken, ret, s, sameLine, stackIdx, stackTag, stackTop, startIdx, startImplicitCall, startImplicitObject, startsLine, tag, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        tag = token[0];
        prevTag = (prevToken = i > 0 ? tokens[i - 1] : [])[0];
        nextTag = (i < tokens.length - 1 ? tokens[i + 1] : [])[0];
        stackTop = function() {
          return stack[stack.length - 1];
        };
        startIdx = i;
        forward = function(n) {
          return i - startIdx + n;
        };
        inImplicit = function() {
          var _ref, _ref1;
          return (_ref = stackTop()) != null ? (_ref1 = _ref[2]) != null ? _ref1.ours : void 0 : void 0;
        };
        inImplicitCall = function() {
          var _ref;
          return inImplicit() && ((_ref = stackTop()) != null ? _ref[0] : void 0) === '(';
        };
        inImplicitObject = function() {
          var _ref;
          return inImplicit() && ((_ref = stackTop()) != null ? _ref[0] : void 0) === '{';
        };
        inImplicitControl = function() {
          var _ref;
          return inImplicit && ((_ref = stackTop()) != null ? _ref[0] : void 0) === 'CONTROL';
        };
        startImplicitCall = function(j) {
          var idx;
          idx = j != null ? j : i;
          stack.push([
            '(', idx, {
              ours: true
            }
          ]);
          tokens.splice(idx, 0, generate('CALL_START', '('));
          if (j == null) {
            return i += 1;
          }
        };
        endImplicitCall = function() {
          stack.pop();
          tokens.splice(i, 0, generate('CALL_END', ')'));
          return i += 1;
        };
        startImplicitObject = function(j, startsLine) {
          var idx;
          if (startsLine == null) {
            startsLine = true;
          }
          idx = j != null ? j : i;
          stack.push([
            '{', idx, {
              sameLine: true,
              startsLine: startsLine,
              ours: true
            }
          ]);
          tokens.splice(idx, 0, generate('{', generate(new String('{')), token));
          if (j == null) {
            return i += 1;
          }
        };
        endImplicitObject = function(j) {
          j = j != null ? j : i;
          stack.pop();
          tokens.splice(j, 0, generate('}', '}', token));
          return i += 1;
        };
        if (inImplicitCall() && (tag === 'IF' || tag === 'TRY' || tag === 'FINALLY' || tag === 'CATCH' || tag === 'CLASS' || tag === 'SWITCH')) {
          stack.push([
            'CONTROL', i, {
              ours: true
            }
          ]);
          return forward(1);
        }
        if (tag === 'INDENT' && inImplicit()) {
          if (prevTag !== '=>' && prevTag !== '->' && prevTag !== '[' && prevTag !== '(' && prevTag !== ',' && prevTag !== '{' && prevTag !== 'TRY' && prevTag !== 'ELSE' && prevTag !== '=') {
            while (inImplicitCall()) {
              endImplicitCall();
            }
          }
          if (inImplicitControl()) {
            stack.pop();
          }
          stack.push([tag, i]);
          return forward(1);
        }
        if (__indexOf.call(EXPRESSION_START, tag) >= 0) {
          stack.push([tag, i]);
          return forward(1);
        }
        if (__indexOf.call(EXPRESSION_END, tag) >= 0) {
          while (inImplicit()) {
            if (inImplicitCall()) {
              endImplicitCall();
            } else if (inImplicitObject()) {
              endImplicitObject();
            } else {
              stack.pop();
            }
          }
          stack.pop();
        }
        if ((__indexOf.call(IMPLICIT_FUNC, tag) >= 0 && token.spaced && !token.stringEnd || tag === '?' && i > 0 && !tokens[i - 1].spaced) && (__indexOf.call(IMPLICIT_CALL, nextTag) >= 0 || __indexOf.call(IMPLICIT_UNSPACED_CALL, nextTag) >= 0 && !((_ref = tokens[i + 1]) != null ? _ref.spaced : void 0) && !((_ref1 = tokens[i + 1]) != null ? _ref1.newLine : void 0))) {
          if (tag === '?') {
            tag = token[0] = 'FUNC_EXIST';
          }
          startImplicitCall(i + 1);
          ret = forward(2);
          return ret;
        }
        if (__indexOf.call(IMPLICIT_FUNC, tag) >= 0 && this.matchTags(i + 1, 'INDENT', null, ':') && !this.findTagsBackwards(i, ['CLASS', 'EXTENDS', 'IF', 'CATCH', 'SWITCH', 'LEADING_WHEN', 'FOR', 'WHILE', 'UNTIL'])) {
          startImplicitCall(i + 1);
          stack.push(['INDENT', i + 2]);
          return forward(3);
        }
        if (tag === ':') {
          if (this.tag(i - 2) === '@') {
            s = i - 2;
          } else {
            s = i - 1;
          }
          while (this.tag(s - 2) === 'HERECOMMENT') {
            s -= 2;
          }
          this.insideForDeclaration = nextTag === 'FOR';
          startsLine = s === 0 || (_ref2 = this.tag(s - 1), __indexOf.call(LINEBREAKS, _ref2) >= 0) || tokens[s - 1].newLine;
          if (stackTop()) {
            _ref3 = stackTop(), stackTag = _ref3[0], stackIdx = _ref3[1];
            if ((stackTag === '{' || stackTag === 'INDENT' && this.tag(stackIdx - 1) === '{') && (startsLine || this.tag(s - 1) === ',' || this.tag(s - 1) === '{')) {
              return forward(1);
            }
          }
          startImplicitObject(s, !!startsLine);
          return forward(2);
        }
        if (inImplicitObject() && __indexOf.call(LINEBREAKS, tag) >= 0) {
          stackTop()[2].sameLine = false;
        }
        newLine = prevTag === 'OUTDENT' || prevToken.newLine;
        if (__indexOf.call(IMPLICIT_END, tag) >= 0 || __indexOf.call(CALL_CLOSERS, tag) >= 0 && newLine) {
          while (inImplicit()) {
            _ref4 = stackTop(), stackTag = _ref4[0], stackIdx = _ref4[1], (_ref5 = _ref4[2], sameLine = _ref5.sameLine, startsLine = _ref5.startsLine);
            if (inImplicitCall() && prevTag !== ',') {
              endImplicitCall();
            } else if (inImplicitObject() && !this.insideForDeclaration && sameLine && tag !== 'TERMINATOR' && prevTag !== ':' && endImplicitObject()) {

            } else if (inImplicitObject() && tag === 'TERMINATOR' && prevTag !== ',' && !(startsLine && this.looksObjectish(i + 1))) {
              endImplicitObject();
            } else {
              break;
            }
          }
        }
        if (tag === ',' && !this.looksObjectish(i + 1) && inImplicitObject() && !this.insideForDeclaration && (nextTag !== 'TERMINATOR' || !this.looksObjectish(i + 2))) {
          offset = nextTag === 'OUTDENT' ? 1 : 0;
          while (inImplicitObject()) {
            endImplicitObject(i + offset);
          }
        }
        return forward(1);
      });
    };

    Rewriter.prototype.addLocationDataToGeneratedTokens = function() {
      return this.scanTokens(function(token, i, tokens) {
        var column, line, nextLocation, prevLocation, _ref, _ref1;
        if (token[2]) {
          return 1;
        }
        if (!(token.generated || token.explicit)) {
          return 1;
        }
        if (token[0] === '{' && (nextLocation = (_ref = tokens[i + 1]) != null ? _ref[2] : void 0)) {
          line = nextLocation.first_line, column = nextLocation.first_column;
        } else if (prevLocation = (_ref1 = tokens[i - 1]) != null ? _ref1[2] : void 0) {
          line = prevLocation.last_line, column = prevLocation.last_column;
        } else {
          line = column = 0;
        }
        token[2] = {
          first_line: line,
          first_column: column,
          last_line: line,
          last_column: column
        };
        return 1;
      });
    };

    Rewriter.prototype.normalizeLines = function() {
      var action, condition, indent, outdent, starter;
      starter = indent = outdent = null;
      condition = function(token, i) {
        var _ref, _ref1, _ref2, _ref3;
        return token[1] !== ';' && (_ref = token[0], __indexOf.call(SINGLE_CLOSERS, _ref) >= 0) && !(token[0] === 'TERMINATOR' && (_ref1 = this.tag(i + 1), __indexOf.call(EXPRESSION_CLOSE, _ref1) >= 0)) && !(token[0] === 'ELSE' && starter !== 'THEN') && !(((_ref2 = token[0]) === 'CATCH' || _ref2 === 'FINALLY') && (starter === '->' || starter === '=>')) || (_ref3 = token[0], __indexOf.call(CALL_CLOSERS, _ref3) >= 0) && this.tokens[i - 1].newLine;
      };
      action = function(token, i) {
        return this.tokens.splice((this.tag(i - 1) === ',' ? i - 1 : i), 0, outdent);
      };
      return this.scanTokens(function(token, i, tokens) {
        var j, tag, _i, _ref, _ref1, _ref2;
        tag = token[0];
        if (tag === 'TERMINATOR') {
          if (this.tag(i + 1) === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {
            tokens.splice.apply(tokens, [i, 1].concat(__slice.call(this.indentation())));
            return 1;
          }
          if (_ref = this.tag(i + 1), __indexOf.call(EXPRESSION_CLOSE, _ref) >= 0) {
            tokens.splice(i, 1);
            return 0;
          }
        }
        if (tag === 'CATCH') {
          for (j = _i = 1; _i <= 2; j = ++_i) {
            if (!((_ref1 = this.tag(i + j)) === 'OUTDENT' || _ref1 === 'TERMINATOR' || _ref1 === 'FINALLY')) {
              continue;
            }
            tokens.splice.apply(tokens, [i + j, 0].concat(__slice.call(this.indentation())));
            return 2 + j;
          }
        }
        if (__indexOf.call(SINGLE_LINERS, tag) >= 0 && this.tag(i + 1) !== 'INDENT' && !(tag === 'ELSE' && this.tag(i + 1) === 'IF')) {
          starter = tag;
          _ref2 = this.indentation(tokens[i]), indent = _ref2[0], outdent = _ref2[1];
          if (starter === 'THEN') {
            indent.fromThen = true;
          }
          tokens.splice(i + 1, 0, indent);
          this.detectEnd(i + 2, condition, action);
          if (tag === 'THEN') {
            tokens.splice(i, 1);
          }
          return 1;
        }
        return 1;
      });
    };

    Rewriter.prototype.tagPostfixConditionals = function() {
      var action, condition, original;
      original = null;
      condition = function(token, i) {
        var prevTag, tag;
        tag = token[0];
        prevTag = this.tokens[i - 1][0];
        return tag === 'TERMINATOR' || (tag === 'INDENT' && __indexOf.call(SINGLE_LINERS, prevTag) < 0);
      };
      action = function(token, i) {
        if (token[0] !== 'INDENT' || (token.generated && !token.fromThen)) {
          return original[0] = 'POST_' + original[0];
        }
      };
      return this.scanTokens(function(token, i) {
        if (token[0] !== 'IF') {
          return 1;
        }
        original = token;
        this.detectEnd(i + 1, condition, action);
        return 1;
      });
    };

    Rewriter.prototype.indentation = function(origin) {
      var indent, outdent;
      indent = ['INDENT', 2];
      outdent = ['OUTDENT', 2];
      if (origin) {
        indent.generated = outdent.generated = true;
        indent.origin = outdent.origin = origin;
      } else {
        indent.explicit = outdent.explicit = true;
      }
      return [indent, outdent];
    };

    Rewriter.prototype.generate = generate;

    Rewriter.prototype.tag = function(i) {
      var _ref;
      return (_ref = this.tokens[i]) != null ? _ref[0] : void 0;
    };

    return Rewriter;

  })();

  BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['{', '}'], ['INDENT', 'OUTDENT'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END']];

  exports.INVERSES = INVERSES = {};

  EXPRESSION_START = [];

  EXPRESSION_END = [];

  for (_i = 0, _len = BALANCED_PAIRS.length; _i < _len; _i++) {
    _ref = BALANCED_PAIRS[_i], left = _ref[0], rite = _ref[1];
    EXPRESSION_START.push(INVERSES[rite] = left);
    EXPRESSION_END.push(INVERSES[left] = rite);
  }

  EXPRESSION_CLOSE = ['CATCH', 'THEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);

  IMPLICIT_FUNC = ['IDENTIFIER', 'SUPER', ')', 'CALL_END', ']', 'INDEX_END', '@', 'THIS'];

  IMPLICIT_CALL = ['IDENTIFIER', 'NUMBER', 'STRING', 'JS', 'REGEX', 'NEW', 'PARAM_START', 'CLASS', 'IF', 'TRY', 'SWITCH', 'THIS', 'BOOL', 'NULL', 'UNDEFINED', 'UNARY', 'YIELD', 'UNARY_MATH', 'SUPER', 'THROW', '@', '->', '=>', '[', '(', '{', '--', '++'];

  IMPLICIT_UNSPACED_CALL = ['+', '-'];

  IMPLICIT_END = ['POST_IF', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR'];

  SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN'];

  SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN'];

  LINEBREAKS = ['TERMINATOR', 'INDENT', 'OUTDENT'];

  CALL_CLOSERS = ['.', '?.', '::', '?::'];

  IMPLICIT_FUNC.push('DEFER');

  IMPLICIT_CALL.push('DEFER');

  IMPLICIT_END.push('AWAIT');

}).call(this);

},{}],11:[function(_dereq_,module,exports){
// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var Scope, extend, iced, last, _ref;

  _ref = _dereq_('./helpers'), extend = _ref.extend, last = _ref.last;

  iced = _dereq_('iced-runtime');

  exports.Scope = Scope = (function() {
    Scope.root = null;

    function Scope(parent, expressions, method) {
      this.parent = parent;
      this.expressions = expressions;
      this.method = method;
      this.variables = [
        {
          name: 'arguments',
          type: 'arguments'
        }
      ];
      this.positions = {};
      if (!this.parent) {
        Scope.root = this;
      }
    }

    Scope.prototype.add = function(name, type, immediate) {
      if (this.shared && !immediate) {
        return this.parent.add(name, type, immediate);
      }
      if (Object.prototype.hasOwnProperty.call(this.positions, name)) {
        return this.variables[this.positions[name]].type = type;
      } else {
        return this.positions[name] = this.variables.push({
          name: name,
          type: type
        }) - 1;
      }
    };

    Scope.prototype.namedMethod = function() {
      var _ref1;
      if (((_ref1 = this.method) != null ? _ref1.name : void 0) || !this.parent) {
        return this.method;
      }
      return this.parent.namedMethod();
    };

    Scope.prototype.find = function(name) {
      if (this.check(name)) {
        return true;
      }
      this.add(name, 'var');
      return false;
    };

    Scope.prototype.parameter = function(name) {
      if (this.shared && this.parent.check(name, true)) {
        return;
      }
      return this.add(name, 'param');
    };

    Scope.prototype.check = function(name) {
      var _ref1;
      return !!(this.type(name) || ((_ref1 = this.parent) != null ? _ref1.check(name) : void 0));
    };

    Scope.prototype.temporary = function(name, index) {
      if (name.length > 1) {
        return '_' + name + (index > 1 ? index - 1 : '');
      } else {
        return '_' + (index + parseInt(name, 36)).toString(36).replace(/\d/g, 'a');
      }
    };

    Scope.prototype.type = function(name) {
      var v, _i, _len, _ref1;
      _ref1 = this.variables;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        v = _ref1[_i];
        if (v.name === name) {
          return v.type;
        }
      }
      return null;
    };

    Scope.prototype.freeVariable = function(name, reserve) {
      var index, temp;
      if (reserve == null) {
        reserve = true;
      }
      index = 0;
      while (this.check((temp = this.temporary(name, index)))) {
        index++;
      }
      if (reserve) {
        this.add(temp, 'var', true);
      }
      return temp;
    };

    Scope.prototype.assign = function(name, value) {
      this.add(name, {
        value: value,
        assigned: true
      }, true);
      return this.hasAssignments = true;
    };

    Scope.prototype.hasDeclarations = function() {
      return !!this.declaredVariables().length;
    };

    Scope.prototype.declaredVariables = function() {
      var realVars, tempVars, v, _i, _len, _ref1;
      realVars = [];
      tempVars = [];
      _ref1 = this.variables;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        v = _ref1[_i];
        if ((v.type === 'var') || (v.type === 'param' && v.name === iced["const"].k)) {
          (v.name.charAt(0) === '_' ? tempVars : realVars).push(v.name);
        }
      }
      return realVars.sort().concat(tempVars.sort());
    };

    Scope.prototype.assignedVariables = function() {
      var v, _i, _len, _ref1, _results;
      _ref1 = this.variables;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        v = _ref1[_i];
        if (v.type.assigned) {
          _results.push("" + v.name + " = " + v.type.value);
        }
      }
      return _results;
    };

    return Scope;

  })();

}).call(this);

},{"./helpers":4,"iced-runtime":20}],12:[function(_dereq_,module,exports){
// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var LineMap, SourceMap;

  LineMap = (function() {
    function LineMap(line) {
      this.line = line;
      this.columns = [];
    }

    LineMap.prototype.add = function(column, _arg, options) {
      var sourceColumn, sourceLine;
      sourceLine = _arg[0], sourceColumn = _arg[1];
      if (options == null) {
        options = {};
      }
      if (this.columns[column] && options.noReplace) {
        return;
      }
      return this.columns[column] = {
        line: this.line,
        column: column,
        sourceLine: sourceLine,
        sourceColumn: sourceColumn
      };
    };

    LineMap.prototype.sourceLocation = function(column) {
      var mapping;
      while (!((mapping = this.columns[column]) || (column <= 0))) {
        column--;
      }
      return mapping && [mapping.sourceLine, mapping.sourceColumn];
    };

    return LineMap;

  })();

  SourceMap = (function() {
    var BASE64_CHARS, VLQ_CONTINUATION_BIT, VLQ_SHIFT, VLQ_VALUE_MASK;

    function SourceMap() {
      this.lines = [];
    }

    SourceMap.prototype.add = function(sourceLocation, generatedLocation, options) {
      var column, line, lineMap, _base;
      if (options == null) {
        options = {};
      }
      line = generatedLocation[0], column = generatedLocation[1];
      lineMap = ((_base = this.lines)[line] || (_base[line] = new LineMap(line)));
      return lineMap.add(column, sourceLocation, options);
    };

    SourceMap.prototype.sourceLocation = function(_arg) {
      var column, line, lineMap;
      line = _arg[0], column = _arg[1];
      while (!((lineMap = this.lines[line]) || (line <= 0))) {
        line--;
      }
      return lineMap && lineMap.sourceLocation(column);
    };

    SourceMap.prototype.generate = function(options, code) {
      var buffer, lastColumn, lastSourceColumn, lastSourceLine, lineMap, lineNumber, mapping, needComma, v3, writingline, _i, _j, _len, _len1, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      if (code == null) {
        code = null;
      }
      writingline = 0;
      lastColumn = 0;
      lastSourceLine = 0;
      lastSourceColumn = 0;
      needComma = false;
      buffer = "";
      _ref = this.lines;
      for (lineNumber = _i = 0, _len = _ref.length; _i < _len; lineNumber = ++_i) {
        lineMap = _ref[lineNumber];
        if (lineMap) {
          _ref1 = lineMap.columns;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            mapping = _ref1[_j];
            if (!(mapping)) {
              continue;
            }
            while (writingline < mapping.line) {
              lastColumn = 0;
              needComma = false;
              buffer += ";";
              writingline++;
            }
            if (needComma) {
              buffer += ",";
              needComma = false;
            }
            buffer += this.encodeVlq(mapping.column - lastColumn);
            lastColumn = mapping.column;
            buffer += this.encodeVlq(0);
            buffer += this.encodeVlq(mapping.sourceLine - lastSourceLine);
            lastSourceLine = mapping.sourceLine;
            buffer += this.encodeVlq(mapping.sourceColumn - lastSourceColumn);
            lastSourceColumn = mapping.sourceColumn;
            needComma = true;
          }
        }
      }
      v3 = {
        version: 3,
        file: options.generatedFile || '',
        sourceRoot: options.sourceRoot || '',
        sources: options.sourceFiles || [''],
        names: [],
        mappings: buffer
      };
      if (options.inline) {
        v3.sourcesContent = [code];
      }
      return JSON.stringify(v3, null, 2);
    };

    VLQ_SHIFT = 5;

    VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT;

    VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1;

    SourceMap.prototype.encodeVlq = function(value) {
      var answer, nextChunk, signBit, valueToEncode;
      answer = '';
      signBit = value < 0 ? 1 : 0;
      valueToEncode = (Math.abs(value) << 1) + signBit;
      while (valueToEncode || !answer) {
        nextChunk = valueToEncode & VLQ_VALUE_MASK;
        valueToEncode = valueToEncode >> VLQ_SHIFT;
        if (valueToEncode) {
          nextChunk |= VLQ_CONTINUATION_BIT;
        }
        answer += this.encodeBase64(nextChunk);
      }
      return answer;
    };

    BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    SourceMap.prototype.encodeBase64 = function(value) {
      return BASE64_CHARS[value] || (function() {
        throw new Error("Cannot Base64 encode value: " + value);
      })();
    };

    return SourceMap;

  })();

  exports.SourceMap = SourceMap;

}).call(this);

},{}],13:[function(_dereq_,module,exports){

},{}],14:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,_dereq_("FWaASH"))
},{"FWaASH":15}],15:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],16:[function(_dereq_,module,exports){
var indexOf = _dereq_('indexof');

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{"indexof":17}],17:[function(_dereq_,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],18:[function(_dereq_,module,exports){
// Generated by IcedCoffeeScript 1.7.1-b
(function() {
  module.exports = {
    k: "__iced_k",
    k_noop: "__iced_k_noop",
    param: "__iced_p_",
    ns: "iced",
    runtime: "runtime",
    Deferrals: "Deferrals",
    deferrals: "__iced_deferrals",
    fulfill: "_fulfill",
    b_while: "_break",
    t_while: "_while",
    c_while: "_continue",
    n_while: "_next",
    n_arg: "__iced_next_arg",
    defer_method: "defer",
    slot: "__slot",
    assign_fn: "assign_fn",
    autocb: "autocb",
    retslot: "ret",
    trace: "__iced_trace",
    passed_deferral: "__iced_passed_deferral",
    findDeferral: "findDeferral",
    lineno: "lineno",
    parent: "parent",
    filename: "filename",
    funcname: "funcname",
    catchExceptions: 'catchExceptions',
    runtime_modes: ["node", "inline", "window", "none", "browserify", "interp"],
    trampoline: "trampoline",
    context: "context",
    defer_arg: "__iced_defer_"
  };

}).call(this);

},{}],19:[function(_dereq_,module,exports){
// Generated by IcedCoffeeScript 1.7.1-b
(function() {
  var C, Pipeliner, iced, __iced_k, __iced_k_noop, _iand, _ior, _timeout,
    __slice = [].slice;

  __iced_k = __iced_k_noop = function() {};

  C = _dereq_('./const');

  exports.iced = iced = _dereq_('./runtime');

  _timeout = function(cb, t, res, tmp) {
    var arr, rv, which, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    rv = new iced.Rendezvous;
    tmp[0] = rv.id(true).defer({
      assign_fn: (function(_this) {
        return function() {
          return function() {
            return arr = __slice.call(arguments, 0);
          };
        };
      })(this)(),
      lineno: 20,
      context: __iced_deferrals
    });
    setTimeout(rv.id(false).defer({
      lineno: 21,
      context: __iced_deferrals
    }), t);
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/iced/iced-runtime/src/library.iced"
        });
        rv.wait(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return which = arguments[0];
            };
          })(),
          lineno: 22
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        if (res) {
          res[0] = which;
        }
        return cb.apply(null, arr);
      };
    })(this));
  };

  exports.timeout = function(cb, t, res) {
    var tmp;
    tmp = [];
    _timeout(cb, t, res, tmp);
    return tmp[0];
  };

  _iand = function(cb, res, tmp) {
    var ok, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/iced/iced-runtime/src/library.iced"
        });
        tmp[0] = __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ok = arguments[0];
            };
          })(),
          lineno: 39
        });
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        if (!ok) {
          res[0] = false;
        }
        return cb();
      };
    })(this));
  };

  exports.iand = function(cb, res) {
    var tmp;
    tmp = [];
    _iand(cb, res, tmp);
    return tmp[0];
  };

  _ior = function(cb, res, tmp) {
    var ok, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/iced/iced-runtime/src/library.iced"
        });
        tmp[0] = __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ok = arguments[0];
            };
          })(),
          lineno: 58
        });
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        if (ok) {
          res[0] = true;
        }
        return cb();
      };
    })(this));
  };

  exports.ior = function(cb, res) {
    var tmp;
    tmp = [];
    _ior(cb, res, tmp);
    return tmp[0];
  };

  exports.Pipeliner = Pipeliner = (function() {
    function Pipeliner(window, delay) {
      this.window = window || 1;
      this.delay = delay || 0;
      this.queue = [];
      this.n_out = 0;
      this.cb = null;
      this[C.deferrals] = this;
      this["defer"] = this._defer;
    }

    Pipeliner.prototype.waitInQueue = function(cb) {
      var ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          var _results, _while;
          _results = [];
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = function() {
              return __iced_k(_results);
            };
            _continue = function() {
              return iced.trampoline(function() {
                return _while(__iced_k);
              });
            };
            _next = function(__iced_next_arg) {
              _results.push(__iced_next_arg);
              return _continue();
            };
            if (!(_this.n_out >= _this.window)) {
              return _break();
            } else {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/iced/iced-runtime/src/library.iced",
                  funcname: "Pipeliner.waitInQueue"
                });
                _this.cb = __iced_deferrals.defer({
                  lineno: 100
                });
                __iced_deferrals._fulfill();
              })(_next);
            }
          };
          _while(__iced_k);
        });
      })(this)((function(_this) {
        return function() {
          _this.n_out++;
          (function(__iced_k) {
            if (_this.delay) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/iced/iced-runtime/src/library.iced",
                  funcname: "Pipeliner.waitInQueue"
                });
                setTimeout(__iced_deferrals.defer({
                  lineno: 108
                }), _this.delay);
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            return cb();
          });
        };
      })(this));
    };

    Pipeliner.prototype.__defer = function(out, deferArgs) {
      var tmp, voidCb, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/iced/iced-runtime/src/library.iced",
            funcname: "Pipeliner.__defer"
          });
          voidCb = __iced_deferrals.defer({
            lineno: 122
          });
          out[0] = function() {
            var args, _ref;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            if ((_ref = deferArgs.assign_fn) != null) {
              _ref.apply(null, args);
            }
            return voidCb();
          };
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this.n_out--;
          if (_this.cb) {
            tmp = _this.cb;
            _this.cb = null;
            return tmp();
          }
        };
      })(this));
    };

    Pipeliner.prototype._defer = function(deferArgs) {
      var tmp;
      tmp = [];
      this.__defer(tmp, deferArgs);
      return tmp[0];
    };

    Pipeliner.prototype.flush = function(autocb) {
      var ___iced_passed_deferral, __iced_k, _results, _while;
      __iced_k = autocb;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      _results = [];
      _while = (function(_this) {
        var __iced_deferrals;
        return function(__iced_k) {
          var _break, _continue, _next;
          _break = function() {
            return __iced_k(_results);
          };
          _continue = function() {
            return iced.trampoline(function() {
              return _while(__iced_k);
            });
          };
          _next = function(__iced_next_arg) {
            _results.push(__iced_next_arg);
            return _continue();
          };
          if (!_this.n_out) {
            return _break();
          } else {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/iced/iced-runtime/src/library.iced",
                funcname: "Pipeliner.flush"
              });
              _this.cb = __iced_deferrals.defer({
                lineno: 151
              });
              __iced_deferrals._fulfill();
            })(_next);
          }
        };
      })(this);
      _while(__iced_k);
    };

    return Pipeliner;

  })();

}).call(this);

},{"./const":18,"./runtime":21}],20:[function(_dereq_,module,exports){
// Generated by IcedCoffeeScript 1.7.1-b
(function() {
  var k, mod, mods, v, _i, _len;

  exports["const"] = _dereq_('./const');

  mods = [_dereq_('./runtime'), _dereq_('./library')];

  for (_i = 0, _len = mods.length; _i < _len; _i++) {
    mod = mods[_i];
    for (k in mod) {
      v = mod[k];
      exports[k] = v;
    }
  }

}).call(this);

},{"./const":18,"./library":19,"./runtime":21}],21:[function(_dereq_,module,exports){
(function (process){
// Generated by IcedCoffeeScript 1.7.1-b
(function() {
  var C, Deferrals, Rendezvous, exceptionHandler, findDeferral, make_defer_return, stackWalk, tick_counter, trampoline, warn, __active_trace, __c, _trace_to_string,
    __slice = [].slice;

  C = _dereq_('./const');

  make_defer_return = function(obj, defer_args, id, trace_template, multi) {
    var k, ret, trace, v;
    trace = {};
    for (k in trace_template) {
      v = trace_template[k];
      trace[k] = v;
    }
    trace[C.lineno] = defer_args != null ? defer_args[C.lineno] : void 0;
    ret = function() {
      var inner_args, o, _ref;
      inner_args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (defer_args != null) {
        if ((_ref = defer_args.assign_fn) != null) {
          _ref.apply(null, inner_args);
        }
      }
      if (obj) {
        o = obj;
        if (!multi) {
          obj = null;
        }
        return o._fulfill(id, trace);
      } else {
        return warn("overused deferral at " + (_trace_to_string(trace)));
      }
    };
    ret[C.trace] = trace;
    return ret;
  };

  __c = 0;

  tick_counter = function(mod) {
    __c++;
    if ((__c % mod) === 0) {
      __c = 0;
      return true;
    } else {
      return false;
    }
  };

  __active_trace = null;

  _trace_to_string = function(tr) {
    var fn;
    fn = tr[C.funcname] || "<anonymous>";
    return "" + fn + " (" + tr[C.filename] + ":" + (tr[C.lineno] + 1) + ")";
  };

  warn = function(m) {
    return typeof console !== "undefined" && console !== null ? console.error("ICED warning: " + m) : void 0;
  };

  exports.trampoline = trampoline = function(fn) {
    if (!tick_counter(500)) {
      return fn();
    } else if (typeof process !== "undefined" && process !== null) {
      return process.nextTick(fn);
    } else {
      return setTimeout(fn);
    }
  };

  exports.Deferrals = Deferrals = (function() {
    function Deferrals(k, trace) {
      this.trace = trace;
      this.continuation = k;
      this.count = 1;
      this.ret = null;
    }

    Deferrals.prototype._call = function(trace) {
      var c;
      if (this.continuation) {
        __active_trace = trace;
        c = this.continuation;
        this.continuation = null;
        return c(this.ret);
      } else {
        return warn("Entered dead await at " + (_trace_to_string(trace)));
      }
    };

    Deferrals.prototype._fulfill = function(id, trace) {
      if (--this.count > 0) {

      } else {
        return trampoline(((function(_this) {
          return function() {
            return _this._call(trace);
          };
        })(this)));
      }
    };

    Deferrals.prototype.defer = function(args) {
      var self;
      this.count++;
      self = this;
      return make_defer_return(self, args, null, this.trace);
    };

    return Deferrals;

  })();

  exports.findDeferral = findDeferral = function(args) {
    var a, _i, _len;
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      a = args[_i];
      if (a != null ? a[C.trace] : void 0) {
        return a;
      }
    }
    return null;
  };

  exports.Rendezvous = Rendezvous = (function() {
    var RvId;

    function Rendezvous() {
      this.completed = [];
      this.waiters = [];
      this.defer_id = 0;
    }

    RvId = (function() {
      function RvId(rv, id, multi) {
        this.rv = rv;
        this.id = id;
        this.multi = multi;
      }

      RvId.prototype.defer = function(defer_args) {
        return this.rv._defer_with_id(this.id, defer_args, this.multi);
      };

      return RvId;

    })();

    Rendezvous.prototype.wait = function(cb) {
      var x;
      if (this.completed.length) {
        x = this.completed.shift();
        return cb(x);
      } else {
        return this.waiters.push(cb);
      }
    };

    Rendezvous.prototype.defer = function(defer_args) {
      var id;
      id = this.defer_id++;
      return this._defer_with_id(id, defer_args);
    };

    Rendezvous.prototype.id = function(i, multi) {
      multi = !!multi;
      return new RvId(this, i, multi);
    };

    Rendezvous.prototype._fulfill = function(id, trace) {
      var cb;
      if (this.waiters.length) {
        cb = this.waiters.shift();
        return cb(id);
      } else {
        return this.completed.push(id);
      }
    };

    Rendezvous.prototype._defer_with_id = function(id, defer_args, multi) {
      this.count++;
      return make_defer_return(this, defer_args, id, {}, multi);
    };

    return Rendezvous;

  })();

  exports.stackWalk = stackWalk = function(cb) {
    var line, ret, tr, _ref;
    ret = [];
    tr = cb ? cb[C.trace] : __active_trace;
    while (tr) {
      line = "   at " + (_trace_to_string(tr));
      ret.push(line);
      tr = tr != null ? (_ref = tr[C.parent]) != null ? _ref[C.trace] : void 0 : void 0;
    }
    return ret;
  };

  exports.exceptionHandler = exceptionHandler = function(err, logger) {
    var stack;
    if (!logger) {
      logger = console.error;
    }
    logger(err.stack);
    stack = stackWalk();
    if (stack.length) {
      logger("Iced 'stack' trace (w/ real line numbers):");
      return logger(stack.join("\n"));
    }
  };

  exports.catchExceptions = function(logger) {
    return typeof process !== "undefined" && process !== null ? process.on('uncaughtException', function(err) {
      exceptionHandler(err, logger);
      return process.exit(1);
    }) : void 0;
  };

}).call(this);

}).call(this,_dereq_("FWaASH"))
},{"./const":18,"FWaASH":15}]},{},[1])
(1)
});
})(this);