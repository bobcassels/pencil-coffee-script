// Generated by IcedCoffeeScript 1.8.0-c
(function() {
  var COMPLEX, IS_STRING, RATIONAL, SIGNED_RATIONAL, addSub, canonicalizeExactComplex, canonicalizeInexact, canonicalizeRational, complexParts, exactAdd, exactMul, flipSign, flipSignNeeded, gcd, limitExact, rationalParts, rationalPartsAdd, rationalReduce, realPartsValue, signedRationalParts,
    __modulo = function(a, b) { return (+a % (b = +b) + b) % b; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  COMPLEX = /^([+-]?)(\d+\/\d+|\d*\.?\d+(?:e[+-]?\d+)?)(i|([+-])(\d+\/\d+|\d*\.?\d+(?:e[+-]?\d+)?)i)?$/i;

  RATIONAL = /^(\d+)(?:\/(\d+))?$/;

  complexParts = function(string) {
    var imagPart, initialSign, parts;
    parts = COMPLEX.exec(string);
    if (parts != null) {
      imagPart = parts[3];
      initialSign = parts[1] || '+';
      if (imagPart == null) {
        return [initialSign, parts[2], '+', '0'];
      } else if (/^i$/i.test(imagPart)) {
        return ['+', '0', initialSign, parts[2]];
      } else {
        return [initialSign, parts[2], parts[4], parts[5]];
      }
    }
  };

  rationalParts = function(string) {
    var parts;
    parts = RATIONAL.exec(string);
    if (parts) {
      return [parts[1], parts[2] || '1'];
    }
  };

  realPartsValue = function(sign, string, rationalParts) {
    var value;
    value = rationalParts != null ? +rationalParts[0] / +rationalParts[1] : +string;
    if (sign === '-') {
      value = -value;
    }
    return value;
  };

  limitExact = Math.pow(2, 53);

  exactAdd = function(aSign, a, bSign, b) {
    var result;
    if ((a != null) && (b != null)) {
      a = +a;
      b = +b;
      if (aSign === '-') {
        a = -a;
      }
      if (bSign === '-') {
        b = -b;
      }
      result = a + b;
      if (Math.abs(result) < limitExact) {
        return result;
      }
    }
  };

  exactMul = function(a, b) {
    var result;
    if ((a != null) && (b != null)) {
      result = +a * +b;
      if (Math.abs(result) < limitExact) {
        return result;
      }
    }
  };

  gcd = function(a, b) {
    var _ref;
    while (b !== 0) {
      _ref = [b, __modulo(a, b)], a = _ref[0], b = _ref[1];
    }
    return a;
  };

  canonicalizeInexact = function(x) {
    var xString;
    xString = x.toString();
    if (/[.eE]|^[^\d]+$/.test(xString)) {
      return xString;
    } else {
      return "" + xString + ".0";
    }
  };

  canonicalizeRational = function(numerator, denominator) {
    var factor;
    factor = gcd(numerator, denominator);
    numerator = numerator / factor;
    denominator = denominator / factor;
    if (denominator === 1) {
      return numerator.toString();
    } else {
      return "" + numerator + "/" + denominator;
    }
  };

  canonicalizeExactComplex = function(real, imag) {
    var imagSign;
    if (imag === '0') {
      return real;
    } else {
      if (real === '0') {
        real = '';
      }
      imagSign = real !== '' && /^-/.test(imag) ? '' : '+';
      return "" + real + imagSign + imag + "i";
    }
  };

  rationalPartsAdd = function(aSign, a, bSign, b) {
    var denominator, numerator;
    denominator = exactMul(a[1], b[1]);
    if (denominator != null) {
      numerator = exactAdd(aSign, exactMul(a[0], b[1]), bSign, exactMul(b[0], a[1]));
      if (numerator != null) {
        return canonicalizeRational(numerator, denominator);
      }
    }
  };

  flipSignNeeded = function(sign) {
    if (sign === '-') {
      return '+';
    } else {
      return '-';
    }
  };

  flipSign = function(sign) {
    if (sign === '-') {
      return '';
    } else {
      return '-';
    }
  };

  exports.negate = function(value) {
    var parts;
    parts = complexParts(value);
    if (parts[3] === '0') {
      if (parts[0] === '-') {
        return parts[1];
      } else {
        return "-" + parts[1];
      }
    } else {
      if (parts[1] === '0') {
        return "" + (flipSign(parts[2])) + parts[3] + "i";
      } else {
        return "" + (flipSign(parts[0])) + parts[1] + (flipSignNeeded(parts[2])) + parts[3] + "i";
      }
    }
  };

  addSub = function(value1, value2, operation) {
    var addSubNative, flipSignMaybe, imag, imagSign, parts1, parts2, rationalParts1imag, rationalParts1real, rationalParts2imag, rationalParts2real, real;
    parts1 = complexParts(value1);
    parts2 = complexParts(value2);
    rationalParts1real = rationalParts(parts1[1]);
    rationalParts1imag = rationalParts(parts1[3]);
    rationalParts2real = rationalParts(parts2[1]);
    rationalParts2imag = rationalParts(parts2[3]);
    if (rationalParts1real && rationalParts1imag && rationalParts2real && rationalParts2imag) {
      flipSignMaybe = function(sign) {
        if (operation === '-') {
          return flipSign(sign);
        } else {
          return sign;
        }
      };
      real = rationalPartsAdd(parts1[0], rationalParts1real, flipSignMaybe(parts2[0]), rationalParts2real);
      imag = rationalPartsAdd(parts1[2], rationalParts1imag, flipSignMaybe(parts2[2]), rationalParts2imag);
      if ((real != null) && (imag != null)) {
        return canonicalizeExactComplex(real, imag);
      }
    } else {
      addSubNative = function(a, b) {
        if (operation === '-') {
          return a - b;
        } else {
          return a + b;
        }
      };
      real = addSubNative(realPartsValue(parts1[0], parts1[1], rationalParts1real), realPartsValue(parts2[0], parts2[1], rationalParts2real));
      if (parts1[3] === '0' && parts2[3] === '0') {
        return canonicalizeInexact(real);
      } else {
        imag = addSubNative(realPartsValue(parts1[2], parts1[3], rationalParts1imag), realPartsValue(parts2[2], parts2[3], rationalParts2imag));
        imagSign = imag < 0 ? '' : '+';
        return "" + (canonicalizeInexact(real)) + imagSign + (canonicalizeInexact(imag)) + "i";
      }
    }
  };

  IS_STRING = /^['"]/;

  exports.add = function(value1, value2) {
    var string;
    if (IS_STRING.test(value1)) {
      if (IS_STRING.test(value2)) {
        string = eval(value1) + eval(value2);
        string = string.replace(/\n/g, '\\n');
        if (__indexOf.call(string, '"') >= 0) {
          if (__indexOf.call(string, "'") >= 0) {
            return "\"" + (string.replace(/"/g, '\\"')) + "\"";
          } else {
            return "'" + string + "'";
          }
        } else {
          return "\"" + string + "\"";
        }
      }
    } else if (!IS_STRING.test(value2)) {
      return addSub(value1, value2, '+');
    }
  };

  exports.sub = function(value1, value2) {
    return addSub(value1, value2, '-');
  };

  rationalReduce = function(num, den) {
    if ((num != null) && (den != null) && num < Math.pow(2, 53) && 0 < den && den < Math.pow(2, 53)) {
      return canonicalizeRational(num, den);
    }
  };

  SIGNED_RATIONAL = /^([+-]?)(\d+)(\/(\d+))?(i?)$/;

  signedRationalParts = function(string) {
    var match;
    match = SIGNED_RATIONAL.exec(string);
    return [match[1] !== '-', +match[2], +(match[4] || 1), match[5] !== ''];
  };

  exports.div = function(value1, value2) {
    var aDen, aImag, aNum, aPositive, bDen, bImag, bNum, bPositive, imag, positive, rational, sign, _ref, _ref1;
    if (SIGNED_RATIONAL.test(value1) && SIGNED_RATIONAL.test(value2)) {
      _ref = signedRationalParts(value1), aPositive = _ref[0], aNum = _ref[1], aDen = _ref[2], aImag = _ref[3];
      _ref1 = signedRationalParts(value2), bPositive = _ref1[0], bNum = _ref1[1], bDen = _ref1[2], bImag = _ref1[3];
      positive = aPositive === bPositive;
      rational = rationalReduce(exactMul(aNum, bDen), exactMul(aDen, bNum));
      imag = aImag === bImag ? '' : 'i';
      if (!aImag && bImag) {
        positive = !positive;
      }
      sign = positive ? '' : '-';
      if (rational) {
        return "" + sign + rational + imag;
      }
    }
  };

}).call(this);
